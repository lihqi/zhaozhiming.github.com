
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Hacker and Geeker's Way</title>
  <meta name="author" content="赵芝明">

  
  <meta name="description" content="有过编程经验的朋友都知道设计模式中的单例模式，最近又重新看了一遍设计模式，今天将单例模式的几种形式介绍一下： 1、懒汉形式（延迟加载） Singleton.java 1
2
3
4
5
6
7
8
9
10
11
12
13
public class Singleton{ private &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://zhaozhiming.github.io/blog/page/2">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/stylesheets/data-table.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Hacker and Geeker's Way" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href='http://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic' rel='stylesheet' type='text/css'>


  

</head>

<body   >
  <header role="banner"><hgroup>
</hgroup>

</header>
  <!-- <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:zhaozhiming.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav> -->
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/12/20/5-type-of-singleton-pattern/">单例模式的5种形式</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-12-20T17:53:00+08:00" pubdate data-updated="true">Dec 20<span>th</span>, 2012</time>
        
        
          | <a href="/blog/2012/12/20/5-type-of-singleton-pattern/#comments">Comments</a>
         
      </p>
    
  </header>


  <div class="entry-content"><p>有过编程经验的朋友都知道设计模式中的单例模式，最近又重新看了一遍设计模式，今天将单例模式的几种形式介绍一下：</p>

<h3>1、懒汉形式（延迟加载）</h3>

<figure class='code'><figcaption><span>Singleton.java </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Singleton</span><span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="n">Singleton</span> <span class="n">singleton</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kd">static</span> <span class="n">Single</span> <span class="nf">newInstance</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">singleton</span><span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">singleton</span><span class="o">=</span> <span class="k">new</span> <span class="n">Singleton</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">singleton</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个是标准的单例模式，通过newInstance里面的判断来进行延迟加载单例对象，这里加了synchronized关键字可以避免多线程问题，但会影响程序性能。</p>

<h3>2、饿汉形式（贪婪加载）</h3>

<figure class='code'><figcaption><span>Singleton.java </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Singleton</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="n">Singleton</span> <span class="n">singleton</span><span class="o">=</span> <span class="k">new</span> <span class="n">Singleton</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="nf">singleton</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Singleton</span> <span class="nf">newInstance</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">singleton</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在单例对象声明的时候就直接初始化对象，可以避免多线程问题，但是如果对象初始化比较复杂，会导致程序初始化缓慢。</p>

<h3>3、双重检查加锁</h3>

<figure class='code'><figcaption><span>Singleton.java </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Singleton</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">volatile</span> <span class="kd">static</span> <span class="n">Singleton</span> <span class="n">singleton</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Singleton</span> <span class="nf">newInstance</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">singleton</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="kd">synchronized</span> <span class="o">(</span><span class="n">Singleton</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                <span class="k">if</span> <span class="o">(</span><span class="n">singleton</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                    <span class="n">singleton</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton</span><span class="o">();</span>
</span><span class='line'>                <span class="o">}</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">singleton</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个是懒汉形式的加强版，将synchronized关键字移到了newInstance方法里面，同时将singleton对象加上volatile关键字，这种方式既可以避免多线程问题，又不会降低程序的性能。但volatile关键字也有一些性能问题，不建议大量使用。</p>

<h3>4、Lazy initialization holder class</h3>

<figure class='code'><figcaption><span>Singleton.java </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Singleton</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">SingletonHolder</span> <span class="o">{</span>
</span><span class='line'>        <span class="kd">private</span> <span class="kd">static</span> <span class="n">Singleton</span> <span class="n">singleton</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Singleton</span> <span class="nf">newInstance</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">SingletonHolder</span><span class="o">.</span><span class="na">singleton</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里创建了一个内部静态类，通过内部类的机制使得单例对象可以延迟加载，同时内部类相当于是外部类的静态部分，所以可以通过jvm来保证其线程安全。这种形式比较推荐。</p>

<h3>5、枚举</h3>

<figure class='code'><figcaption><span>Singleton.java </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">enum</span> <span class="n">Singleton</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">singleton</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>单因素的枚举类已经实现了单例，这种方法更加简单。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/12/20/first-experience-at-idea-12/">IDEA12使用初体验</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-12-20T17:06:00+08:00" pubdate data-updated="true">Dec 20<span>th</span>, 2012</time>
        
        
          | <a href="/blog/2012/12/20/first-experience-at-idea-12/#comments">Comments</a>
         
      </p>
    
  </header>


  <div class="entry-content"><p>最近将开发工具IDEA升级到了12.0版本，被它新的UI界面深深吸引，看下面，很酷哦~</p>

<p><img src="/images/20164405-12c5f44041bf43af8351e3812f69cf3b.PNG"></p>

<h3>一、下载安装</h3>

<p>在IDEA官网下载最近版本12.0，有免费的社区版，还有收费的无限制版，大家可以自行下载。</p>

<p>下载后进行安装，windows系统直接执行exe文件即可，ubuntu系统先将下载包解压，然后执行bin文件夹里面的idea.sh就可以运行了。</p>

<h3>二、使用新的UI界面</h3>

<p>安装完后的IDEA默认UI可不是上面那个，需要先去到setting里面设置，如下图：</p>

<p><img src="/images/20165722-72e913a55f7e436b89b87bb1fe1d6126.PNG"></p>

<ol>
<li>点击进入setting窗口；</li>
<li>选择Appearance；</li>
<li>在theme里面选择Darcula，没错，新UI主题的名称就叫Darcula，设置好了保存。</li>
</ol>


<h3>三、正确设置中文乱码</h3>

<p>使用Darcula主题的时候，发现中文变成了一堆乱码，这个问题可以也可以在setting里面解决：</p>

<p><img src="/images/20170004-5ac2c44f1bde48c2a842afd551cf9f3c.PNG"></p>

<p>同样进入setting的Appearance页面，将Override default fonts by(not recommended) 勾选上，然后选择字体，如果觉得字体太小，还可以选择字体大小。设置以后，IDEA就可以正常使用了。</p>

<p>喜欢的这个开发工具的原因是里面的重构功能非常强大，还有快捷操作也很多，可以让你少敲很多代码，很多时候一个alt + enter就可以搞定一切。希望喜欢的朋友去下来试试，用过之后你会发现比eclipse好的不是一点半点。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/12/07/the-elements-of-jacoco/">Jacoco的原理</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-12-07T19:47:00+08:00" pubdate data-updated="true">Dec 7<span>th</span>, 2012</time>
        
        
          | <a href="/blog/2012/12/07/the-elements-of-jacoco/#comments">Comments</a>
         
      </p>
    
  </header>


  <div class="entry-content"><h2>覆盖率计数器</h2>

<p>Jacoco使用一系列的不同的计数器来做覆盖率的度量计算。所有这些计数器都是从java的class文件中获取信息，这些class文件可以（可选）包含调试的信息在里面。即使在没有源码的情况下，这种方法也可以实时有效地对应用程序进行度量和分析。在大部分情况下，收集到的信息可以映射到源码，可视化到每一行代码的粒度。但这种方法还是有一些限制。这些class文件必须使用调试信息来编译，这样才可以计算行的覆盖率和提供出源码的高亮。但不是所有的JAVA语言的结构都可以直接编译成一致的二进制代码。在这种情况下，java 编译器会创建所谓的“合成”代码，会导致产生一些不期望得到的覆盖率结果。</p>

<h4>指令（C0 Coverage）</h4>

<p>Jacoco最小的计数单元是单个java二进制代码指令。指令覆盖率提供了代码是否被执行的信息。这个度量完全独立源码格式，并且总是可用，即使class文件里面没有调试信息。</p>

<h4>分支（C1 Coverage）</h4>

<p>Jacoco也计算分支的覆盖率，包括所有的if和switch语句。这个度量计算一个方法里面的总分支数，确定执行和不执行的分支数量。分支覆盖率总是可用的，即使class文件里面没有调试信息。注意异常处理是不在分支度量里面统计的。</p>

<p>如果class文件使用调试信息编译的话，产生的覆盖率可以映射到源码行并且高亮提示：</p>

<ul>
<li>没有覆盖：在这一行中没有分支被执行（红色方块）</li>
<li>部分覆盖：这一行的分支中只有一部分被执行（黄色方块）</li>
<li>完全覆盖：这一行的所有分支都被执行（绿色方块）</li>
</ul>


<h4>圈复杂度</h4>

<p>Jacoco同样可以为每一个非抽象方法计算复杂度，最终计算出类、包和组的复杂度。根据由McCabe1996圈复杂度的定义是，在（线性）组合中，计算在一个方法里面所有可能路径的最小数目。所以复杂度可以作为度量单元测试是否有完全覆盖所有场景的一个依据。复杂度即使是在没有调试信息的情况下也可以计算。</p>

<p>圈复杂度V（G）的正式定义是基于方法的控制流图的有向图表示：</p>

<p>v(G) = E &ndash; N + 2</p>

<p>E是边界的数量，N是节点的数量。Jacoco 基于下面的方程来计算复杂度，B是分支的数量，D是决策点的数量：</p>

<p>v(G) = B &ndash; D + 1</p>

<p>基于每个分支的被覆盖情况，Jacoco也为每个方法计算覆盖和缺失的复杂度。缺失的复杂度同样表示测试案例没有完全覆盖到这个模块。注意Jacoco不将异常处理作为分支，try/catch块也同样不增加复杂度。</p>

<h4>行</h4>

<p>所有的class文件使用debug信息编译之后，就可以计算行的覆盖率信息。一行源代码是否被执行，要看这一行中是否至少有一个指令被执行。</p>

<p>由于实际上一行代码一般被编译成多个二进制代码指令，这样源码在高亮显示时，会显示成3种不同的状态：</p>

<ul>
<li>没有覆盖：这一行中没有指令被执行（红色背景）</li>
<li>部分覆盖：这一行中只有一部分指令被执行（黄色背景）</li>
<li>完全覆盖：这一行中所有指令都被覆盖（绿色背景</li>
</ul>


<h4>方法</h4>

<p>每一个非抽象方法至少包含一个指令。一个方法是否执行取决于方法中是否有至少一个指令被执行。在Jacoco中，构造器和静态初始化同样会像方法一样统计。其中一些方法可能没有可以直接对应的源码，比如默认构造器或常量的初始化命令。</p>

<h4>类</h4>

<p>一个方法是否执行取决于类中是否有至少一个方法被执行。注意Jacoco认为构造器和静态初始化都是方法。Java的接口一般包含静态初始化，所以接口也同样被认为是可执行的类。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/12/02/use-jacoco-in-jenkins-and-sonar-part-4/">在jenkins和sonar中集成jacoco(四)&#8211;在sonar中集成jacoco</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-12-02T14:46:00+08:00" pubdate data-updated="true">Dec 2<span>nd</span>, 2012</time>
        
        
          | <a href="/blog/2012/12/02/use-jacoco-in-jenkins-and-sonar-part-4/#comments">Comments</a>
         
      </p>
    
  </header>


  <div class="entry-content"><p>首先要得到之前的单元测试和集成测试的覆盖率文件，还有对应的class文件以及单元测试的覆盖率报告，材料准备齐全之后，使用如下命令：</p>

<figure class='code'><figcaption><span>build.xml </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;taskdef</span> <span class="na">uri=</span><span class="s">&quot;antlib:org.sonar.ant&quot;</span> <span class="na">resource=</span><span class="s">&quot;org/sonar/ant/antlib.xml&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>        <span class="nt">&lt;classpath</span> <span class="na">path=</span><span class="s">&quot;${env.SONAR-ANT-TASK.JAR}&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/taskdef&gt;</span>
</span><span class='line'>
</span><span class='line'>    <span class="nt">&lt;target</span> <span class="na">name=</span><span class="s">&quot;sonar&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>        <span class="nt">&lt;sonar:sonar</span> <span class="na">key=</span><span class="s">&quot;${sonar.project.key}&quot;</span> <span class="na">version=</span><span class="s">&quot;${sonar.project.version}&quot;</span> <span class="na">xmlns:sonar=</span><span class="s">&quot;antlib:org.sonar.ant&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>            <span class="nt">&lt;sources&gt;</span>
</span><span class='line'>                <span class="nt">&lt;path</span> <span class="na">location=</span><span class="s">&quot;${src.dir}&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>            <span class="nt">&lt;/sources&gt;</span>
</span><span class='line'>
</span><span class='line'>            <span class="nt">&lt;property</span> <span class="na">key=</span><span class="s">&quot;sonar.projectName&quot;</span> <span class="na">value=</span><span class="s">&quot;jacoco_demo&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>            <span class="nt">&lt;property</span> <span class="na">key=</span><span class="s">&quot;sonar.sourceEncoding&quot;</span> <span class="na">value=</span><span class="s">&quot;UTF-8&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>            <span class="nt">&lt;property</span> <span class="na">key=</span><span class="s">&quot;sonar.dynamicAnalysis&quot;</span> <span class="na">value=</span><span class="s">&quot;reuseReports&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>            <span class="nt">&lt;property</span> <span class="na">key=</span><span class="s">&quot;sonar.surefire.reportsPath&quot;</span> <span class="na">value=</span><span class="s">&quot;${junit.dir}&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>            <span class="nt">&lt;property</span> <span class="na">key=</span><span class="s">&quot;sonar.core.codeCoveragePlugin&quot;</span> <span class="na">value=</span><span class="s">&quot;jacoco&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>            <span class="nt">&lt;property</span> <span class="na">key=</span><span class="s">&quot;sonar.jacoco.reportPath&quot;</span> <span class="na">value=</span><span class="s">&quot;${basedir}/ut.exec&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>            <span class="nt">&lt;property</span> <span class="na">key=</span><span class="s">&quot;sonar.jacoco.itReportPath&quot;</span> <span class="na">value=</span><span class="s">&quot;${basedir}/uat.exec&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>
</span><span class='line'>            <span class="nt">&lt;tests&gt;</span>
</span><span class='line'>                <span class="nt">&lt;path</span> <span class="na">location=</span><span class="s">&quot;${src.test.dir}&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>            <span class="nt">&lt;/tests&gt;</span>
</span><span class='line'>
</span><span class='line'>            <span class="nt">&lt;binaries&gt;</span>
</span><span class='line'>                <span class="nt">&lt;path</span> <span class="na">location=</span><span class="s">&quot;${build.src.class}&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>                <span class="nt">&lt;path</span> <span class="na">location=</span><span class="s">&quot;${build.test.class}&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>            <span class="nt">&lt;/binaries&gt;</span>
</span><span class='line'>
</span><span class='line'>            <span class="nt">&lt;libraries&gt;</span>
</span><span class='line'>                <span class="nt">&lt;path</span> <span class="na">location=</span><span class="s">&quot;${build.lib.dir}&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>            <span class="nt">&lt;/libraries&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/sonar:sonar&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/target&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>参数解释：</p>

<ul>
<li>sonar.dynamicAnalysis是指单元测试报告的生成方式，值为reuseReports是指给出生成好的单元测试报告路径。</li>
<li>sonar.surefire.reportsPath是指单元测试报告的路径。</li>
<li>sonar.core.codeCoveragePlugin是覆盖率插件，有jacoco,cobetura等。</li>
<li>sonar.jacoco.reportPath是单元测试覆盖率文件的路径。</li>
<li>sonar.jacoco.itReportPath是集成测试覆盖率文件的路径。</li>
</ul>


<p>更多参数可以参考这里：<a href="http://docs.codehaus.org/display/SONAR/Code+Coverage+by+Unit+Tests">单元测试</a>，<a href="http://docs.codehaus.org/display/SONAR/Code+Coverage+by+Integration+Tests">集成测试</a><br/>
在sonar 3.3的版本会自动将单元测试和集成测试的覆盖率合并，最后附上sonar上的覆盖率显示：</p>

<p><img src="/images/2012112914305954.png"><br/>
<img src="/images/2012112914311753.png"></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/12/01/use-jacoco-in-jenkins-and-sonar-part-3/">在jenkins和sonar中集成jacoco(三)&#8211;使用jacoco收集集成测试的覆盖率</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-12-01T14:45:00+08:00" pubdate data-updated="true">Dec 1<span>st</span>, 2012</time>
        
        
          | <a href="/blog/2012/12/01/use-jacoco-in-jenkins-and-sonar-part-3/#comments">Comments</a>
         
      </p>
    
  </header>


  <div class="entry-content"><p>我们系统使用weblogic做服务器，集成测试框架使用的是junit+selenium。</p>

<p>首先，要把jacoco的jacocoagent.jar包放到部署应用的服务器上，接着在系统服务的JAVA_OPTIONS 后面添加如下参数：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>-javaagent:<span class="o">[</span>yourpath/<span class="o">]</span>jacocoagent.jar<span class="o">=</span><span class="nv">includes</span><span class="o">=</span>com.xxx.xxx.*,output<span class="o">=</span>tcpserver,address<span class="o">=</span>xxx.xxx.xxx.xxx,port<span class="o">=</span>xxxxx
</span></code></pre></td></tr></table></div></figure>


<p>参数解释：</p>

<ol>
<li>前面的yourpath是放jacocoagent.jar文件的目录路径；</li>
<li>includes是指要收集哪些类（注意不要关写包名，最后要写.*)，不写的话默认是*，会收集应用服务上所有的类，包括服务器和其他中间件的类，一般要过滤；</li>
<li>output有4个值，分别是file,tcpserver,tcpclient,mbean，默认是file。使用file的方式只有在停掉应用服务的时候才能产生覆盖率文件，而使用tcpserver的方式可以在不停止应用服务的情况下下载覆盖率文件，后面会介绍如何使用dump方法来得到覆盖率文件。</li>
<li>address是ip， port是端口，这是使用tcpserver方式需要的2个参数，也是后面dump方法要用到的。（这里的address我只能使用服务器的ip，如果使用其他ip，服务启动时会报错。）</li>
</ol>


<p>更多参数可以参考<a href="http://www.eclemma.org/jacoco/trunk/doc/agent.html">java agent</a>。<br/>
配置完应用服务的JAVA_OPTIONS之后，启动服务器，然后可以开始跑你的集成测试，跑完之后，实际上jacocoagent已经将覆盖率数据记录下来了，我们可以使用下面的ant任务来dump出覆盖率文件：</p>

<figure class='code'><figcaption><span>build.xml </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'>　 <span class="nt">&lt;target</span> <span class="na">name=</span><span class="s">&quot;downloadUatCoverageData&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>        <span class="nt">&lt;jacoco:dump</span> <span class="na">address=</span><span class="s">&quot;xxx.xxx.xxx.xxx&quot;</span> <span class="na">port=</span><span class="s">&quot;xxxx&quot;</span> <span class="na">reset=</span><span class="s">&quot;true&quot;</span> <span class="na">destfile=</span><span class="s">&quot;${basedir}/uat.exec&quot;</span> <span class="na">append=</span><span class="s">&quot;false&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/target&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里的address和port是刚才在JAVA_OPTIONS里面写的address和port的值，destfile是指生成的覆盖率文件路径。</p>

<p><strong>注意，这里虽然得到了集成测试的覆盖率文件，但是需要应用服务器上的类文件才能产出相应的覆盖率报告，如果类文件是其他JVM编译的，产出的报告覆盖率是0%。</strong></p>

<p>有2种方法可以得到覆盖率文件所需的class文件：</p>

<ol>
<li>将应用服务部署的包（ear或war或jar）包下载下来之后解压，即可得到对应的class文件；</li>
<li>在前面做单元测试之后，可以将class文件打成一个zip包，然后上传到服务器，最后在需要的时候去服务器上取。</li>
</ol>


<p>得到集成测试的覆盖率文件之后，结合之前取到的单元测试覆盖率文件，我们可以将2个文件合并，得到综合的覆盖率文件，命令如下：</p>

<figure class='code'><figcaption><span>build.xml </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'>　<span class="nt">&lt;target</span> <span class="na">name=</span><span class="s">&quot;mergeCoverage&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>        <span class="nt">&lt;jacoco:merge</span> <span class="na">destfile=</span><span class="s">&quot;merged.exec&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>            <span class="nt">&lt;fileset</span> <span class="na">dir=</span><span class="s">&quot;${basedir}&quot;</span> <span class="na">includes=</span><span class="s">&quot;*.exec&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/jacoco:merge&gt;</span>
</span><span class='line'>   <span class="nt">&lt;/target&gt;</span>
</span></code></pre></td></tr></table></div></figure>



</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/11/30/use-jacoco-in-jenkins-and-sonar-part-2/">在jenkins和sonar中集成jacoco(二)&#8211;在jenkins中生成jacoco覆盖率报告</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-11-30T14:45:00+08:00" pubdate data-updated="true">Nov 30<span>th</span>, 2012</time>
        
        
          | <a href="/blog/2012/11/30/use-jacoco-in-jenkins-and-sonar-part-2/#comments">Comments</a>
         
      </p>
    
  </header>


  <div class="entry-content"><p>先要在jenkins上安装jacoco的插件，安装完成之后在job的配置项中可以增加这个选项：</p>

<p><img src="/images/2012112911555041.png"><br/>
<img src="/images/2012112911561356.png"></p>

<p>第一个录入框是你的覆盖率文件（exec），第二个是class文件目录，第三个是源代码文件目录。</p>

<p>配置好了之后进行构建，构建完成之后job首页就会出现覆盖率的趋势图，鼠标点击趋势图可以看到覆盖率详情，包括具体覆盖率数据和源码的覆盖率情况：</p>

<p>趋势图<br/>
<img src="/images/2012112911373757.png" title="趋势图" ></p>

<p>覆盖率详情  <br/>
<img src="/images/2012112911394918.png" title="覆盖率详情" ></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/11/29/use-jacoco-in-jenkins-and-sonar-part-1/">在jenkins和sonar中集成jacoco(一)&#8211;使用jacoco收集单元测试的覆盖率</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-11-29T14:45:00+08:00" pubdate data-updated="true">Nov 29<span>th</span>, 2012</time>
        
        
          | <a href="/blog/2012/11/29/use-jacoco-in-jenkins-and-sonar-part-1/#comments">Comments</a>
         
      </p>
    
  </header>


  <div class="entry-content"><p>  之前系统的持续集成覆盖率工具使用的是cobetura，使用的过程中虽然没什么问题，但感觉配置比较麻烦，现在准备改用jacoco这个覆盖率工具来代替它。接下来我介绍一下jenkins配置jacoco，并且在sonar显示单元测试和集成测试覆盖率的过程。</p>

<p>用jacoco来实现单元测试的覆盖率比较简单，在ant脚本中先增加下面的任务：</p>

<figure class='code'><figcaption><span>build.xml </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;taskdef</span> <span class="na">uri=</span><span class="s">&quot;antlib:org.jacoco.ant&quot;</span> <span class="na">resource=</span><span class="s">&quot;org/jacoco/ant/antlib.xml&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>        <span class="nt">&lt;classpath</span> <span class="na">path=</span><span class="s">&quot;${basedir}/jacoco_lib/jacocoant.jar&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'><span class="nt">&lt;/taskdef&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里要引入jacoco的jar包jacocoant.jar，增加了这个命令之后，将原有的单元测试任务用 jacoco:coverage包括起来，实例代码如下：</p>

<figure class='code'><figcaption><span>build.xml </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;target</span> <span class="na">name=</span><span class="s">&quot;unitTest&quot;</span> <span class="na">depends=</span><span class="s">&quot;test_compile&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>        <span class="nt">&lt;mkdir</span> <span class="na">dir=</span><span class="s">&quot;${junit.dir}&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>        <span class="nt">&lt;jacoco:coverage</span> <span class="na">destfile=</span><span class="s">&quot;${basedir}/ut.exec&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>            <span class="nt">&lt;junit</span> <span class="na">fork=</span><span class="s">&quot;true&quot;</span> <span class="na">forkmode=</span><span class="s">&quot;once&quot;</span> <span class="na">printsummary=</span><span class="s">&quot;on&quot;</span> <span class="na">failureproperty=</span><span class="s">&quot;unit.test.failure&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>                <span class="nt">&lt;classpath&gt;</span>
</span><span class='line'>                    <span class="nt">&lt;pathelement</span> <span class="na">location=</span><span class="s">&quot;${build.class}&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>                    <span class="nt">&lt;fileset</span> <span class="na">dir=</span><span class="s">&quot;${build.lib.dir}&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>                <span class="nt">&lt;/classpath&gt;</span>
</span><span class='line'>
</span><span class='line'>                <span class="nt">&lt;formatter</span> <span class="na">type=</span><span class="s">&quot;xml&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>                <span class="nt">&lt;batchtest</span> <span class="na">todir=</span><span class="s">&quot;${junit.dir}&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>                    <span class="nt">&lt;fileset</span> <span class="na">dir=</span><span class="s">&quot;${src.test.dir}&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>                        <span class="nt">&lt;include</span> <span class="na">name=</span><span class="s">&quot;**/*Test.java&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>                    <span class="nt">&lt;/fileset&gt;</span>
</span><span class='line'>                <span class="nt">&lt;/batchtest&gt;</span>
</span><span class='line'>            <span class="nt">&lt;/junit&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/jacoco:coverage&gt;</span>
</span><span class='line'>　　　　<span class="c">&lt;!-- 其他内容 --&gt;</span>
</span><span class='line'><span class="nt">&lt;/target&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>jacoco:coverage的destfile参数是指生成的覆盖率文件路径，不写默认文件名为jacoco.exec。另外在forkmode这个参数设置为once，可以提高你的单元测试的执行效率。</p>

<p>这样跑完单元测试后，就会在指定路径下生成覆盖率文件ut.exec（或默认的jacoco.exec，在工程根目录下）。</p>

<p>如果要在本地生成jacoco的覆盖率报告，可以增加如下任务：</p>

<figure class='code'><figcaption><span>build.xml </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;target</span> <span class="na">name=</span><span class="s">&quot;jacocoReport&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>        <span class="nt">&lt;delete</span> <span class="na">dir=</span><span class="s">&quot;${basedir}/jacoco&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>        <span class="nt">&lt;mkdir</span> <span class="na">dir=</span><span class="s">&quot;${result.jacoco.report.dir}/ut&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>        <span class="nt">&lt;jacoco:report&gt;</span>
</span><span class='line'>            <span class="nt">&lt;executiondata&gt;</span>
</span><span class='line'>                <span class="nt">&lt;file</span> <span class="na">file=</span><span class="s">&quot;${basedir}/ut.exec&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>            <span class="nt">&lt;/executiondata&gt;</span>
</span><span class='line'>
</span><span class='line'>            <span class="nt">&lt;structure</span> <span class="na">name=</span><span class="s">&quot;jacoco_demo&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>                <span class="nt">&lt;classfiles&gt;</span>
</span><span class='line'>                    <span class="nt">&lt;fileset</span> <span class="na">dir=</span><span class="s">&quot;${build.dir}&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>                <span class="nt">&lt;/classfiles&gt;</span>
</span><span class='line'>                <span class="nt">&lt;sourcefiles</span> <span class="na">encoding=</span><span class="s">&quot;UTF-8&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>                    <span class="nt">&lt;fileset</span> <span class="na">dir=</span><span class="s">&quot;${src.dir}&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>                <span class="nt">&lt;/sourcefiles&gt;</span>
</span><span class='line'>            <span class="nt">&lt;/structure&gt;</span>
</span><span class='line'>            <span class="nt">&lt;html</span> <span class="na">destdir=</span><span class="s">&quot;${result.jacoco.report.dir}/ut&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/jacoco:report&gt;</span>
</span><span class='line'><span class="nt">&lt;/target&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>生成覆盖率报告需要覆盖率文件（exec）、源码、编译后的class文件。这里导出的格式是html，还有xml和cvs 2种格式可以导出，具体参考<a href="http://www.eclemma.org/jacoco/trunk/doc/ant.html#report">jacoco:report</a>。<br/>
注意，这里的class文件和exec文件必须用同一个jvm执行，如果是用JVM A来编译class文件，然后用JVM B来生成覆盖率文件，生成出来的报告覆盖率会为0%。<strong>这一点对生成集成测试的覆盖率特别重要。</strong></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/09/17/continuous-integration-on-a-dollar-a-day/">持续集成一天一美元</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-09-17T21:53:00+08:00" pubdate data-updated="true">Sep 17<span>th</span>, 2012</time>
        
        
          | <a href="/blog/2012/09/17/continuous-integration-on-a-dollar-a-day/#comments">Comments</a>
         
      </p>
    
  </header>


  <div class="entry-content"><p>原文：<a href="http://jamesshore.com/Blog/Continuous-Integration-on-a-Dollar-a-Day.html">http://jamesshore.com/Blog/Continuous-Integration-on-a-Dollar-a-Day.html</a>
有一种持续集成，比使用像CruiseControl这样的构建服务来的更容易更便宜。实际上，它是如此简单，你可以从现在开始做这件事，不用为你还没有构建服务而感到不舒服。</p>

<p>（肮脏的小秘密？我将要告诉你的是比使用CruiseControl更好的东西!）</p>

<h3>第一步：找一台老的电脑</h3>

<p>找一台你以前用来做开发的电脑，不要太老&hellip;它需要用来跑构建程序。找一个没用的显示器和一个废弃的角落，把它连接起来，放一张破旧的椅子在前面，不需要太舒适&hellip;你不会想这里坐太久。</p>

<h3>第二步：找一只橡皮鸡(<em>不是真的鸡</em>)</h3>

<p><img src="http://www.jamesshore.com/Blog/usbchicken.jpg"><br/>
<em>我的办公室，大概在2001年</em></p>

<p>你如果想要也可以使用其他东西，比如毛绒绒的玩具。玩具要搞笑、没有菱角，这样你用力把它扔向某人时不会不小心伤害到别人的眼睛（特别是你误中他人的时候）。如果你没有合适的东西，不要让这一步搁置你的下一步行动。即兴创作，有趣就行。</p>

<p>我想<a href="http://www.cs.cmu.edu/afs/cs.cmu.edu/user/sprite/www/Origami/crane_gif.html">这个</a>有助于即兴创作，但我做不来，所以你不会也没关系。</p>

<h3>第三步：买一个桌铃</h3>

<p>那种你轻拍就会发出“叮”的铃铛。不要因为你没有一个桌铃就停止做持续集成，可以后面再做这一步。现在你已经有开始的势头了。旧电脑，就绪。插线，就绪。搞笑玩具，就绪。你离开始做持续集成已经越来越近了（如果你真的没钱，你可以完全跳过这一步（译者注：指桌铃））。</p>

<h3>第四步：让你的构建自动化</h3>

<p>噢！这是最难的一步。好消息是CruiseControl 的好处之一就是可以使你的构建自动化。更好的消息是你接下来要做的持续集成，可以做的事情比CruiseControl的自动化构建要多，并且我将帮你获得所有的这些好处。但你还是需要让你的构建自动化。</p>

<p>好吧，这个很难，我知道。如果你已经依赖你的IDE为你构建，让构建自动化可能意味着要做很多的工作。现在，你可能要创建一个批处理文件来跑你的IDE并要求它来构建。程序运行的时间太长不是件好事，所以还是回来做正确的事情吧。</p>

<p>如果你已经有了自动化检查的单元测试，比如JUnit/NUnit 测试，也将它们放到构建里面。</p>

<p>在你继续之前，走向那台旧电脑（见第一步），然后确认你的版本库中的最新代码可以成功构建。没有使用任何版本控制工具？额&hellip;好吧&hellip;放下键盘然后离开电脑。现在，跟我读：“原谅我，老天爷，我错了。我又一次没有使用版本控制来编程。我会马上下载TortoiseSvn（译者注：现在当然是git了），安装使用它。从今以后我不会再犯了。”谢谢。</p>

<p>如果一个干净运行的自动化构建超过10分钟，那么请停下来。你还没为持续集成做好准备，你需要加速你的构建。你可以做接下来的步骤，或者你可以使用CruiseControl，但真正的持续集成现在还不属于你。</p>

<h3>第五步：洗脑</h3>

<p>这在列表中绝对，毫无疑问，100%是最重要的一步。让你团队中的所有开发人员一起去到一个房间。</p>

<p>如果有人问，不，这不是开会。你将要在5分钟内完成某件事情。有用，简短，所以这不是一个会议。</p>

<p>现在，在保证没有动用武力胁迫的情况下，让每个人都同意下面的话：</p>

<blockquote><p>“从现在开始，我们版本库中的代码将一直构建成功并且可以跑过所有测试。”</p></blockquote>


<p>如果有人抱怨这个太难了，让他们知道，通过持续集成来做这个很简单。额，应该说更简单。如果他们仍然认为这太难了，可以委婉地提醒他们的工作，你知道，构建软件。</p>

<p>噢，太残酷了，还是不要说的好。啊，我刚失去了10个粉丝，呀，又一个，11个。</p>

<p>实际上，“每个人都同意这是个好主意”的部分真的非常重要。你看，能够一直依赖你的软件构建，是持续集成的革命性部分。想象一下如果你知道你刚从版本库上下下来的代码可以工作，你的生活会变得多轻松。</p>

<p>让我来讲一个小故事。我维护开源软件的一块叫NUnitAsp。去年，我开了一门课来专门将它。在讲课期间，有人要求增加一个NUnitAsp没有的功能。我看了下代码发现很容易就可以增加。所以我做了修改（花了几分钟）。然后我跑我的构建，96秒后有个新的发布文件，然后把它拿出来。真实的故事，我们甚至有一个编程奖品，我们叫它“找bug得杯具”（我们人很好，即使没有找到bug的人我们也给他杯具）。</p>

<p>好了，你的持续集成可能还没到那一步。你需要像我的那个项目一样有很好的自动化测试来构建和发布。所以让我来讲另外一个故事。在另外一个项目，没有那么成功，我们所有人在代码的不同部分上工作。虽然我们每天都很小心的检入代码，但我们没有构建整个工程或跑测试。（测试？我们没有任何自动化测试。）六个月以后，我们尝试去集成，但没有东西可以组装在一起。我们花费了一个星期才让程序跑起来。我甚至不想描述在这个过程中有多少个bug了。持续集成，即使没有好的测试，也意味着你将再次不会面对这种噩梦了。</p>

<p>我讨厌试图去说服人们相信这是个好主意。我告诉你要刷牙了吗？但你还是会每天做。这个对你有好处。不想做？那就不要做！不是我的问题。</p>

<p>12&hellip;13&hellip;14，15，16&hellip;妹的。（译者注：指粉丝流失）</p>

<p>不然怎样，如果没有让每个人都同意这样做，那么这个过程将不会有效。你还能指望什么？</p>

<h3>第六步：启动！</h3>

<p>在<a href="http://jamesshore.com/Blog/Continuous-Integration-Checklist.html">这里</a>看到可打印的清单。
你已经准备好了！让我们浏览一下预启动清单：</p>

<ol>
<li>构建电脑？就绪。</li>
<li>搞笑玩具？就绪。</li>
<li>烦人的闹铃？可选。</li>
<li>自动构建？就绪。</li>
<li>团队同意？就绪。</li>
</ol>


<p>现在，让我们开始吧！</p>

<p>首先，每天至少检入代码2次。这是“持续”的部分。当你熟练以后，你将每1~2个小时检入一次。</p>

<p>在获取版本库的最新代码之前，看下有没有人手里有橡皮鸡。如果有，先等他们把代码检入。</p>

<p>当你检入时，遵循以下步骤：</p>

<p>A 在本地跑构建/测试脚本，确认100%通过。 <br/>
B 把橡皮鸡从它原来的地方拿过来。如果橡皮鸡不在原地，找一下看在谁那里，然后一直烦着他们直到他们检入代码。<br/>
C 从版本库下载最新代码然后再次运行构建脚本。如果没有运行成功，你知道刚下的代码有问题。发发牢骚抱怨一下，然后找到最后检入代码的那个人帮你解决问题。解决问题后重新开始。<br/>
D 检入你的代码。<br/>
E 走向那台破旧的构建电脑，从版本库获取最新代码，再次运行构建脚本。如果没有运行成功，将你检入的代码还原。没成功的原因，可能是你安装了一些新的软件，或者修改了一个环境变量，或者设置注册表环境，或者忘记添加文件到版本库，或者其他原因。不管怎样，你需要在你的电脑上修复这个问题然后重新试一次。你可以暂时保留橡皮鸡，但如果其他人需要你要还回去（然后重新开始）。<br/>
F 让铃铛响起来。（其他人会为你鼓掌，或以其他方式为你高兴。）把橡皮鸡放回去，你已经做完了。</p>

<p>顺便说一下，当步骤E失败了，你可能会冒险在构建机器上直接修复问题，但如果你这样做了，下一个可怜的家伙下载了最新代码后将会构建失败。</p>

<p>最后，但并非最不重要：保持你的构建时间在10分钟之内，少于5分钟更好。如果运行时间太长，这个过程将不再是一件愉快的事情而是痛苦的开始。而且一般来说快速构建对你有好处，不管怎样，因为速度慢的构建往往意味着测试方法的缺陷。</p>

<h3>为什么比 CruiseControl 好？</h3>

<ol>
<li>代码在版本控制中总是周期性地可以构建和通过测试。</li>
<li>如果出错了，你知道问题出在哪里。要么是你的代码（在步骤A失败了），要么是其他人的代码（在步骤C失败了），或者是环境改变了（在步骤E失败了）。反正你可以找到原因，让修复问题更简单。</li>
<li>当其他人没有等CruiseControl 跑完构建就跑去吃午饭时，你不用再去修复其他人引起的构建失败。</li>
<li>你会让构建运行的时间保持简短（长时间运行的构建会让你痛苦），这意味着测试写得更好，使设计更佳。</li>
</ol>


<h3>高级课程</h3>

<p>一旦你让基础设施工作起来了，你可以继续真正完善你的持续集成的使用。一个可选的做法是让你的构建独立起来，换句话说，你构建所需的所有东西就只是你的源控制，一旦你得到代码了，你就可以断开网络连接去构建。这个好处是让你的构建更可信，允许你轻易地去构建老版本。这也有助于找出数据库配置和迁移的错误。</p>

<p>真正给力的测试也是一个好的选择。如果你真的拥有给力的测试，那么你可以盖着帽子好好休息了。</p>

<p>我同样喜欢让我的构建脚本来构建一个安装包。人们经常从他们的测试和集成过程中拿掉安装程序，然后忍受花费额外时间来构建一个安装包。这是快速构建带来的众多好处之一，让你做这件事情更容易，虽然自动测试安装程序是一件痛苦的事情。</p>

<p>嗯&hellip;我讨厌承认&hellip;安装CruiseControl 也是一个好主意，等你从高级课程毕业了再接触比较好。而现在，你已经真正做到熟悉（持续集成）基础（团队同意，快速测试，永不破坏的构建），你已经不大可能回到坏实践中去了。</p>

<p>最后祝你好运！别忘了给我一美元。</p>

<p><em>相关材料：</em></p>

<ul>
<li><a href="http://www.martinfowler.com/articles/continuousIntegration.html">Continuous Integration</a> (Martin Fowler)</li>
<li><a href="http://jamesshore.com/Blog/Red-Green-Refactor.html">Red-Green-Refactor</a> (James Shore)</li>
<li><a href="http://jamesshore.com/Blog/Continuous-Integration-is-an-Attitude.html">Continuous Integration is an Attitude, Not a Tool</a> (James Shore)</li>
<li><a href="http://blogs.msdn.com/mswanson/articles/169058.aspx">Automated Continuous Integration and the Ambient Orb</a> (Michael Swanson)</li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/08/06/read-toyota-product-method/">读《丰田生产方式》——联系敏捷开发的思考</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-08-06T10:16:00+08:00" pubdate data-updated="true">Aug 6<span>th</span>, 2012</time>
        
        
          | <a href="/blog/2012/08/06/read-toyota-product-method/#comments">Comments</a>
         
      </p>
    
  </header>


  <div class="entry-content"><p>平时工作和同事讨论敏捷，曾多次听到丰田的精益思想，说是很多敏捷的想法都是从丰田的精益思想中得来的，后来在Kent Beck的《解析极限编程》里看到有这样一本书是讲丰田的精益思想的，找来看了一下，发现书中讲的一些思想或者实践和敏捷开发很相似，下面我就讲讲我对于丰田生产方式和敏捷开发的一些联系。</p>

<h2>一、逆向思维，由生产的最后一道工序为起点，从后往前推进。</h2>

<p>丰田生产方式的两大支柱是准时化和自动化。准时化（Just In Time）是指通过流水作业装配一辆汽车的过程中，所需零部件在需要的时刻，以需要的数量，不多不少的送到生产线的旁边。如何达到这种不多不少的状态呢？丰田的做法是由生产的最后一道工序为起点，从后往前推进。这样以最后要生产的汽车数量，就可以推测所需的零部件各是多少，从而达到降低浪费的目的。</p>

<p>在敏捷开发中，我们如何做到准时化？从相关的敏捷实践来看，测试驱动开发（TDD）就是达到这一目的的过程。先从原始需求上面得到一个个的Story，Story规定了需求的入口和出口，然后再驱动出测试案例，最后由测试案例驱动出产品代码，这样就能保证产品代码的功能是包括了原始需求所要求的功能，但又避免产生过渡设计。这个也是减少浪费的一种过程。</p>

<h2>二、每个工人都有一根警报线，在生产过程中发现产品有问题，随时拉线让整个生产线停止，等待解决问题后再恢复生产。</h2>

<p>丰田生产方式的另外一个支柱是自动化。丰田使用了很多自动化机器，但自动化的标准不是简单的去使用机器，而是实现人的自动化。丰田几乎所有的机器设备都装有自动停止装置，平时机器自动运转的时候用不到人，如果生产过程中发现问题，人会去停止机器，然后修复问题，重新启动机器。如果在生产过程中发现问题没有及时停止生产，那就可能生产出大量的残次品，这些残次品无法装配到汽车上，是一种很大的浪费。</p>

<p>在敏捷开发中，持续集成体现的就是这种自动化思想。在持续集成的过程中，一旦发现问题（比如单元测试跑失败了），服务器就会马上停止构建，并通知相关的开发人员进行问题修复，等问题修复完成后，再重新进行构建。这样每当问题出现，我们就可以以最小的代价找到问题的根源，然后修复它。如果等问题遗留到后面的测试阶段或者生产阶段，再去找问题的根源，所需的代价就要大的多得多。</p>

<p>光有持续集成的服务器还不行，服务器不会自己去编译、测试、部署，所有这些行为都需要人去开发出相应的脚本，然后在服务器上运行，这就是所谓的“人的自动化”。开发人员应该将所有可以自动化的东西都做成自动化，让单元测试自动化，集成测试自动化，部署自动化，总之一个目的，减少浪费，这也是丰田生产一直追求的目标之一。</p>

<h2>三、看板</h2>

<p>看板在丰田生产中是一种工具，在生产中起到一个传递情报和指令的作用。</p>

<p>敏捷开发很好的运用了看板。有过敏捷开发经验的同学应该知道，敏捷中的看板就是整天摆在你跟前的那块白板，白板上将开发过程分成好几个阶段，每个阶段上面贴着该阶段下的开发任务，通过白板可以随时了解项目的进展。</p>

<h2>其他思想和实践</h2>

<p>除了和敏捷开发有这些联系外，丰田生产方式还有一些思想和实践适合软件开发。</p>

<h4>一人掌握多种技能，每个人都是多面手。</h4>

<p>由于历史和文化的原因，美国的的制度是，车工始终是车工，焊工永远是焊工；日本的制度是，工人既能操作车床，也能开钻床，而且能焊接，能够学会和掌握多种技能。</p>

<p>两种制度孰优孰劣很难确定，但个人认为，在软件开发高速发展的今天，开发人员应该要有更高的要求。开发人员所掌握的技能不仅仅是会编写产品代码，还要会写单元测试，会部署，会搭建环境等等。比如在缺少测试人员的情况下，开发人员可以自己测试，依靠开发的编程技能可以写出更好的测试代码。要能够快速学会和掌握多种技能。</p>

<h4>反复问5个为什么</h4>

<p>比如一台机器不转动了，你就要问：</p>

<ol>
<li>为什么机器停了？——“因为超负荷，保险丝断了。”</li>
<li>“为什么超负荷了呢？”——“因为轴承部分的润滑不够。&#8221;</li>
<li>&ldquo;为什么润滑不够？”——“因为润滑泵吸不上油来。”</li>
<li>“为什么吸不上油来呢？”——“因为油泵轴磨损，松动了。”</li>
<li>“为什么磨损了呢？”——因为没有安装过滤器，混进了铁屑。”</li>
</ol>


<p>通过问5个为什么就可以知道需要安装过滤器了。如果问题问的不彻底，可能是加上润滑油，或者换上油泵轴了事，这样等过了一段时间后问题还是会出现。丰田生产方式可以说是丰田人反复问5个为什么才创造出来的。</p>

<h4>拥抱小团队，不要大块头</h4>

<p>团队合作高于一切，由于合作或其他种种原因，人少的团队反而容易取胜。小船容易转舵，大船步履阑珊，小团队的灵活性更强，这也符合敏捷开发的原则——要做到简洁。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/08/05/best-practices-in-rails-with-web-app-design/">《Agile Web Development With Rails》读后感&#8211;rails基于web设计的best Practices</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-08-05T18:18:00+08:00" pubdate data-updated="true">Aug 5<span>th</span>, 2012</time>
        
        
          | <a href="/blog/2012/08/05/best-practices-in-rails-with-web-app-design/#comments">Comments</a>
         
      </p>
    
  </header>


  <div class="entry-content"><p>最近看完《Agile Web Development with Rails》一书，受益匪浅。书中先是用一个简单的web应用带你进入Rails的世界，然后在你大致熟悉之后，再带你了解Rails的一些细节，比如ActiveRecord，ActiveController等。最让我觉得Rails美的是其中的一些best practices，这些都可以很好地借鉴到平时的开发中去。下面我简单举几个在Rails中我认为比较好的一些best practies。</p>

<h3>数据库迁移</h3>

<p>在Rails中，SQL脚本可以通过命令来生成，生成的脚本以时间戳加意图命名，比如创建表的SQL脚本文件可能是“20120529151027_create_products.rb&#8221;，加时间戳可以让人一眼就知道脚本的执行顺序，实际上Rails在也是根据时间戳来执行脚本的。创建完脚本后只要简单的执行&#8221;rake db:migrate&#8221;命令即可完成脚本的执行，在Rails中会有脚本执行的记录，已经执行过的脚本不会重复执行。另外，在每个SQL脚本中，不仅有执行的操作，还有回滚的操作。比如：</p>

<figure class='code'><figcaption><span>demo.rb </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">AddPriceToLineItem</span> <span class="o">&lt;</span> <span class="ss">ActiveRecord</span><span class="p">:</span><span class="ss">:Migration</span>
</span><span class='line'>    <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">up</span>
</span><span class='line'>    <span class="err">　　</span><span class="n">add_column</span> <span class="ss">:line_items</span><span class="p">,</span> <span class="ss">:price</span><span class="p">,</span> <span class="ss">:decimal</span><span class="p">,</span> <span class="ss">:precision</span> <span class="o">=&gt;</span> <span class="mi">8</span><span class="p">,</span> <span class="ss">:scale</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="ss">:default</span> <span class="o">=&gt;</span> <span class="mi">0</span>
</span><span class='line'>
</span><span class='line'>    <span class="err">　　</span><span class="n">say_with_time</span> <span class="s2">&quot;Updating prices...&quot;</span> <span class="k">do</span>
</span><span class='line'>      <span class="err">　　</span><span class="no">LineItem</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="ss">:all</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">lineitem</span><span class="o">|</span>
</span><span class='line'>        <span class="err">　　</span><span class="n">lineitem</span><span class="o">.</span><span class="n">update_attribute</span> <span class="ss">:price</span><span class="p">,</span> <span class="n">lineitem</span><span class="o">.</span><span class="n">product</span><span class="o">.</span><span class="n">price</span>
</span><span class='line'>         <span class="k">end</span>
</span><span class='line'>    <span class="err">　　</span><span class="k">end</span>
</span><span class='line'>  <span class="err">　</span><span class="k">end</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">down</span>
</span><span class='line'>    <span class="err">　　</span><span class="n">remove_column</span> <span class="ss">:line_items</span><span class="p">,</span> <span class="ss">:price</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里的up方法是正常执行时的操作，down方法则是回滚时所做的操作。如果发现执行的脚本有问题，简单地执行“rake db:rollback&#8221;即可回退到脚本执行前的状态。</p>

<h3>Convention over Configuration</h3>

<p>在上面创建的脚本中可以看到，Rails的表名都是复数形式，因为Rails认为每张表都会存放很多个同一类型的数据，因此是复数，这种清晰的命名规范不仅体现在数据库，还有其他很多地方。比如，model的文件名都是单数形式存在，controller都是以复数形式存在。Rails将MVC各模块连接起来就是通过COC约定，举个简单例子，product的model文件是product.rb，controller文件是products_controller.rb，而view文件则是放在对应的product文件夹里面，每个view文件名以action方法名开头，这样在写代码的时候就可以不用具体指定要发送给哪个controller，给哪个model存储数据，让哪个页面显示数据，只要你遵守了COC约定，Rails会帮你跳转到最合适的地方。</p>

<h3>分层的页面布局</h3>

<p>在书中的例子，作者会建议你将页面分成一个个小的局部文件。实际上Rails也是推荐你这么做的，局部文件只需以下划线开头，Rails就会帮你识别出来。小的页面文件结构简单，容易维护，比如有显示列标题的页面，其中嵌套显示具体行内容的页面，其中再嵌套分页页面文件。对比平时在工作里遇到的一个个硕大无比的jsp文件，rails的页面文件让人有了进入世外桃源的感觉。</p>

<p>Rails还有其他很多的best practices，这里只是简单的介绍。Rails框架集中了很多开发中遇到的常见问题的解决方案，而且是一些最佳的解决方案，像集中了很多经验丰富的大师智慧一样，使用Rails并学习其中的best practices，能让你在web开发上少走很多弯路。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/3/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <ul id="recent_posts">
      <li class="post">
      <a href="http://zhaozhiming.github.io" alt="Home"><img src="/images/Home.png"></a>
      <a href="http://zhaozhiming.github.io/archives/" alt="Archives"><img src="/images/Calendar.png"></a>
      <a href="mailto:kingzzm1982@sina.com" alt="E-Mail"><img src="/images/Envelope.png"></a>
      <a href="http://zhaozhiming.github.io/atom.xml" alt="subscribe feed"><img src="/images/rss_big.png"></a>
      </li>
  </ul>
</section>
<section>
    <h1>Follow Me</h1>
	<ul id="followlists">
		<li class="post">
			<a href="http://weibo.com/u/2497707964" title="新浪微博" target="_blank"><img src="/images/social/sinaweibo.ico" /></a>
			<a href="https://github.com/zhaozhiming" title="github" target="_blank"><img src="/images/social/github.ico" /></a>
			<a href="http://www.linkedin.com/in/zhaozhiming" title="Linkedin" target="_blank"><img src="/images/social/linkedin.ico" /></a>
		</li>
	</ul>
</section>



<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2013/09/05/my-octopress-setting/">我的octopress配置</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/06/04/facebook-engineer-culture/">Facebook的工程师文化——《打造facebook》读后感</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/05/20/use-sonar-create-customer-js-verify-rule-part-3/">利用Sonar定制自定义JS扫描规则（三）——SSLR JavaScript Toolkit 使用说明</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/05/19/use-sonar-create-customer-js-verify-rule-part-2/">利用Sonar定制自定义JS扫描规则（二）——自定义JS扫描规则</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/05/19/use-sonar-create-customer-js-verify-rule-part-1/">利用Sonar定制自定义JS扫描规则（一）——sonar环境搭建</a>
      </li>
    
  </ul>
</section>
<section>
  <h1>Tags</h1>
  <ul class="tag-cloud">
	<a style="font-size: 125%" href="/tags/agile/">agile</a>
<a style="font-size: 194%" href="/tags/ant/">ant</a>
<a style="font-size: 171%" href="/tags/jacoco/">jacoco</a>
<a style="font-size: 180%" href="/tags/java/">java</a>
<a style="font-size: 187%" href="/tags/javascript/">javascript</a>
<a style="font-size: 210%" href="/tags/jenkins/">jenkins</a>
<a style="font-size: 145%" href="/tags/js/">js</a>
<a style="font-size: 159%" href="/tags/junit/">junit</a>
<a style="font-size: 145%" href="/tags/plugins/">plugins</a>
<a style="font-size: 194%" href="/tags/sonar/">sonar</a>

  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/zhaozhiming">@zhaozhiming</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'zhaozhiming',
            count: 5,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>

<section>
  <h1>友情链接</h1>
  <ul>
    <li>
      <a href="http://niejason.sinaapp.com/" target="_blank">niejason</a> |
      <a href="http://hutu.me/" target="_blank">小道消息</a> |
      <a href="http://dreamhead.blogbus.com/" target="_blank">梦想风暴</a> |
      <a href="http://www.ruanyifeng.com/blog/" target="_blank">阮一峰的网络日志</a> |
      <a href="http://taosay.net/" target="_blank">道哥的黑板报</a>
    </li>
  </ul>
</section>
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - 赵芝明 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
