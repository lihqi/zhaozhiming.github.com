<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: translation | Hacker and Geeker's Way]]></title>
  <link href="http://zhaozhiming.github.io/blog/categories/translation/atom.xml" rel="self"/>
  <link href="http://zhaozhiming.github.io/"/>
  <updated>2018-05-01T20:12:45+08:00</updated>
  <id>http://zhaozhiming.github.io/</id>
  <author>
    <name><![CDATA[赵芝明]]></name>
    <email><![CDATA[kingzzm1982@sina.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[在 Sharedarraybuffers 中使用 Atomics 来避免竞态条件]]></title>
    <link href="http://zhaozhiming.github.io/blog/2017/06/21/avoiding-race-conditions-in-sharedarraybuffers-with-atomics-zh/"/>
    <updated>2017-06-21T15:53:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2017/06/21/avoiding-race-conditions-in-sharedarraybuffers-with-atomics-zh</id>
    <content type="html"><![CDATA[<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_29.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_29.png</a>" width="400" height="350"></p>

<p>这是 3 篇文章中的第三篇：</p>

<ul>
<li><a href="http://zhaozhiming.github.io/blog/2017/06/20/a-crash-course-in-memory-management-zh/">内存管理速成教程</a></li>
<li><a href="http://zhaozhiming.github.io/blog/2017/06/20/a-cartoon-intro-to-arraybuffers-and-sharedarraybuffers-zh/">通俗漫画介绍 ArrayBuffers 和 SharedArrayBuffers</a></li>
<li>在 Sharedarraybuffers 中使用 Atomics 来避免竞态条件</li>
</ul>


<p>原文链接：<a href="https://hacks.mozilla.org/2017/06/avoiding-race-conditions-in-sharedarraybuffers-with-atomics/">Avoiding race conditions in SharedArrayBuffers with Atomics</a></p>

<!--more-->


<h1>在 Sharedarraybuffers 中使用 Atomics 来避免竞态条件</h1>

<p>在<a href="http://zhaozhiming.github.io/blog/2017/06/20/a-cartoon-intro-to-arraybuffers-and-sharedarraybuffers-zh/">上一篇文章</a> 中，我讲述了使用 SharedArrayBuffers 会导致竞态条件，这让 SharedArrayBuffers 使用困难，我们不希望应用开发人员直接使用 SharedArrayBuffers。</p>

<p>但在其他语言上有多线程开发经验的库开发人员可以使用新的底层 API 来创建高级别的工具，应用开发人员就可以使用这些工具而无需直接接触 SharedArrayBuffers 和 Atomics。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_15.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_15.png</a>" width="400" height="350"></p>

<p>尽管你可能不会直接同 SharedArrayBuffers 和 Atomics 打交道，但我觉得了解它们的工作原理还是比较有意思的，所以在这篇文章中，我将讲解它们会带来哪种类型的竞态条件，然后 Atomics 是如何帮助我们避开它们的。</p>

<p>但首先，什么是竞态条件？</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_13.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_13.png</a>" width="400" height="350"></p>

<h2>竞态条件：一个你之前可能看过的例子</h2>

<p>一个相当简单的竞态条件的例子就是，你在两个线程间共享一个变量。说具体一些，一个线程想要加载一个文件，另外一个线程想检查文件是否存在，它们共享了一个变量叫<code>fileExists</code>，通过它来进行通信。</p>

<p>开始时，<code>fileExists</code>被设置为 false。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_03.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_03.png</a>" width="400" height="350"></p>

<p>只要线程 2 的代码先运行，文件将会被加载。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_04.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_04.png</a>" width="400" height="350"></p>

<p>但如果线程 1 的代码先运行，那么它将给用户一个错误记录，说文件不存在。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_05.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_05.png</a>" width="400" height="350"></p>

<p>但文件是否存在不是问题所在，真正的问题是竞态条件。</p>

<p>即使是在单线程代码中，很多 JavaScript 开发人员也会遇到这类竞态条件。要了解为什么这是竞态，并不需要明白什么是多线程。</p>

<p>尽管如此，有些类型的竞态条件在单线程代码中不会出现，但在你进行共享内存的多线程编程时会出现。</p>

<h2>不同类型的竞态条件和 Atomics 如何辅助</h2>

<p>让我们来探索一些你在多线程代码中会遇到的不同类型的竞态条件，然后 Atomics 如何帮助我们避开它们。这里没有覆盖所有的竞态条件，但告诉了你关于为什么 API 会提供这些方法的一些想法。</p>

<p>在我们开始之前，我想要再次申明：你不应该直接使用 Atomics。编写多线程代码是公认的难题，相反地，你应该在你的多线程代码中使用可靠的库来和共享内存打交道。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_06.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_06.png</a>" width="400" height="350"></p>

<h2>单个操作中的竞态条件</h2>

<p>比方说我们有两个线程来递增相同的变量，你可能会认为不管哪个线程先执行，最终的结果都是一样的。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_07.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_07.png</a>" width="400" height="350"></p>

<p>尽管在源码中，递增一个变量看起来是一个单步操作，但在编译后的代码中，它并不是一个单步操作。</p>

<p>在 CPU 层面，递增变量分为三个指令，那是因为计算机既有长期内存也有短期内存（我在<a href="https://hacks.mozilla.org/2017/02/a-crash-course-in-assembly/">另外一篇文章</a> 讲过它们是如何工作的）。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_08.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_08.png</a>" width="400" height="350"></p>

<p>所有线程都共享长期内存，但线程间不共享短期内存（注册者）。</p>

<p>每个线程需要从内存中取到值并放入到短期内存中，然后在短期内存中执行运算，然后把结果从短期内存写回到长期内存。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_09.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_09.png</a>" width="400" height="350"></p>

<p>如果线程 1 的所有操作都先发生，然后线程 2 的所有操作接着发生，那么我们将得到期望的结果。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_10.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_10.png</a>" width="400" height="350"></p>

<p>但如果它们交叉进行，线程 2 放入它的注册者中的值不是内存中同步运行后的结果，这意味着线程 2 没有考虑线程 1 的计算结果，它放弃了线程 1 将自己的值写入到内存的结果。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_11.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_11.png</a>" width="400" height="350"></p>

<p>原子操作做的就是把这些计算机觉得是多步的操作作为单步操作，并让计算机也把它们看成是单步操作。</p>

<p>这就是为什么它们叫做原子操作，因为它们执行一个操作，通常这个操作会有多个指令（指令可以暂停和恢复），让所有指令看似瞬间发生，就好像它是一条指令，就像一个不可分割的原子。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_12.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_12.png</a>" width="400" height="350"></p>

<p>使用原子操作，递增变量的代码看起来有点不一样。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_13.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_13.png</a>" width="400" height="350"></p>

<p>现在我们使用<code>Atomics.add</code>，递增变量的多个步骤将不会在线程间相互交叉，相反，一个线程在完成它的原子操作前不会让其他线程先开始，等本身线程操作执行完了后再让其他线程执行自己的原子操作。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_14.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_14.png</a>" width="400" height="350"></p>

<p>Atomics 的方法帮助避免这类竞态：</p>

<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/add">Atomics.add</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/sub">Atomics.sub</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/and">Atomics.and</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/or">Atomics.or</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/xor">Atomics.xor</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/exchange">Atomics.exchange</a></li>
</ul>


<p>你会发现这个列表相当有限，甚至没有包括乘除操作，虽然库开发人员可以创建类似的原子操作。</p>

<p>开发人员可以使用<code>Atomics.compareExchange</code>来做到这点，通过这个方法，你可以从 SharedArrayBuffer 中取到一个值，然后执行操作，如果你是第一个检出的，就没有其他线程会更新它，执行完了再把它写回到 SharedArrayBuffer 里面；如果其他线程更新了它，那么你可以获取最新的值，然后再操作一次。</p>

<h2>在多操作中的竞态条件</h2>

<p>Atomic 的操作可以帮助你在“单步操作”中避免竞态条件，但有时候你需要改变一个对象的多个值（通过多操作的方式），同时不希望在同一时刻有其他人来更新这个对象。基本上，这意味着每次对象的改变，对象本身相对其他线程来说是锁定并且不可访问的。</p>

<p>Atomics 对象没有提供工具来直接处理这个问题，但它提供了库开发人员可以用来解决这个问题的工具，库开发人员可以创建一个锁。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_15.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_15.png</a>" width="400" height="350"></p>

<p>如果代码想要锁住数据，它必须要有数据的锁，然后它可以用锁来防住其他线程，只有当锁可以用的时候才可以对数据进行访问和更新。</p>

<p>为了创建一个锁，库开发人员可以使用<code>Atomics.wait</code> 和 <code>Atomics.wake</code>，还有其他的方法比如<code>Atomics.compareExchange</code> 和<code>Atomics.store</code>。如果你想要了解这些方法是如何工作的，可以看一下<a href="https://github.com/lars-t-hansen/js-lock-and-condition">这个基本的锁实现</a>。</p>

<p>在这个例子中，线程 2 会要求数据的锁并把<code>locked</code>的值设为 true，这意味着在线程 2 解锁之前线程 1 不能访问数据。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_16.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_16.png</a>" width="400" height="350"></p>

<p>如果线程 1 想要访问数据，它会尝试获取锁，但因为锁已经被占用了，所以它获取不到，线程会等待（所以会有阻塞）直到锁可用。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_17.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_17.png</a>" width="400" height="350"></p>

<p>一旦线程 2 完成了，它会调用解锁操作，完了锁会通知那些一直在等待锁的线程们：我现在可以用了。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_18.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_18.png</a>" width="400" height="350"></p>

<p>然后线程会取到锁，为它自己能单独使用而将数据锁住。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_19.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_19.png</a>" width="400" height="350"></p>

<p>一个关于锁的库会使用 Atomics 对象多个不同的方法，但在这种情况下最重要的方法是：</p>

<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/wait">Atomics.wait</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/wake">Atomics.wake</a></li>
</ul>


<h2>指令重排序引起的竞态条件</h2>

<p>这是 Atomics 负责的第三种同步问题，这一个会让人惊讶。</p>

<p>你可能没有意识到这一点，但这是一个好机会（让你了解它），你写的代码没有按照你的预期顺序运行，编译器和 CPU 会重新排序代码让其跑得更快。</p>

<p>打个比方，假如说你要写代码来计算总数，你想要在总数计算完成后设置一个标示。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_20.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_20.png</a>" width="400" height="350"></p>

<p>为了编译这些代码，我们需要为每个变量决定使用哪个注册机，然后我们可以将源码翻译成指令给计算机看。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_21.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_21.png</a>" width="400" height="350"></p>

<p>到目前为止，所有事情都按预期进行。</p>

<p>如果你不理解计算机是如何在限制条件下工作的（和如何使用管道来执行代码），那么这看起来会不明显，第二行代码会在它执行之前稍微等一会。</p>

<p>大部分计算机会把执行指令的过程分成多个步骤，这样确保了 CPU 在不同区域都能保持一直忙碌，这样可以充分利用 CPU。</p>

<p>这里是一个指令的过程步骤示例：</p>

<ul>
<li>从内存中获取下个指令</li>
<li>计算出指令告诉我们要做什么（比如解码指令），然后从注册者中取到值</li>
<li>执行指令</li>
<li>把结果写回注册者</li>
</ul>


<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_22.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_22.png</a>" width="400" height="350"></p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_23.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_23.png</a>" width="400" height="350"></p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_24.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_24.png</a>" width="400" height="350"></p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_25.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_25.png</a>" width="400" height="350"></p>

<p>这就是一个指令是经过管道的过程。理想情况下，我们想要紧接着执行第二个命令，一旦我们进入第二步，我们就会去获取下个指令。</p>

<p>问题在于指令#1 和指令#2 之间会有依赖。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_26.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_26.png</a>" width="400" height="350"></p>

<p>我们可以暂停 CPU 直到指令#1 在注册机中更新完<code>subTotal</code>，但这会减慢速度。</p>

<p>为了让事情更有效率，大部分编译器和 CPU 将会重新排序代码，他们会寻找那些没有使用<code>subTotal</code>或<code>total</code>的指令，然后把它们移动到这两行代码中间。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_27.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_27.png</a>" width="400" height="350"></p>

<p>这可以让指令源源不断地移动通过管道。</p>

<p>因为第 3 行没有依赖第 1 或 2 行的值，所以编译器或者 CPU 计算出它重排序是安全的。当你在一个单线程中运行时，没有其他代码会看到这一部分值，直到整个函数执行完成。</p>

<p>但当你在另外一个处理器上有其他的线程在同时运行时，情况就不一样了。其它线程不用等方法完成后再去看这些变化，它可以在回写内存时马上看到它们，所以<code>isDone</code>标示在被告知总数前就被设置好了。</p>

<p>如果你想要用<code>isDone</code>来表示总数已经计算完成并准备用于其他线程，那么这种重排序将产生竞态条件。</p>

<p>Atomics 尝试解决其中的一些缺陷，当你使用一个 Atomic 写操作，就好比在代码的两部分中间放入一个栅栏。</p>

<p>Atomic 没有彼此间的重排序操作，也没有其他操作可以移动它们。实际上，有两个操作经常用于控制顺序：</p>

<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/load">Atomics.load</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/store">Atomics.store</a></li>
</ul>


<p>在同一方法的代码中，所有在<code>Atomics.store</code>上面的变量，它们的更新在其写回内存之前都会在<code>Atomics.store</code>完成之前完成，即使有非原子指令在彼此间重新排序，它们中任何一个指令也不能移动到<code>Atomics.store</code>下面去执行。</p>

<p>在同一方法的代码中，所有在<code>Atomics.load</code>下面的变量，它们的加载都会在<code>Atomics.load</code>完成之后完成，同样地，即使有非原子指令在彼此间重新排序，它们中任何一个指令也不能移动到<code>Atomics.load</code>上面去执行。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_28.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_28.png</a>" width="400" height="350"></p>

<p>注意，我在这里展示的 while 循环叫做自旋锁，它的效率是非常低的。如果它在主线程中，它可能会让你的应用挂起，你肯定不会在真实代码中使用它。</p>

<p>再次申明，在应用代码中不要直接使用这些方法，相反地，库会用它们来创建锁。</p>

<h2>总结</h2>

<p>共享内存的多线程编程是困难的，有很多种不同类型的竞态条件的坑等着你去踩。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_29.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_29.png</a>" width="400" height="350"></p>

<p>这就是为什么不要在你的应用代码中直接用 SharedArrayBuffers 和 Atomics，你应该依赖那些有多线程开发经验的开发者开发出来的库，他们花了很多时间在研究内存模型。</p>

<p>现在离 SharedArrayBuffer 和 Atomics 的到来还有点早，这些库也还没创建出来，但这些新的 API 提供了基础功能来创建它们。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[通俗漫画介绍 ArrayBuffers 和 SharedArrayBuffers]]></title>
    <link href="http://zhaozhiming.github.io/blog/2017/06/20/a-cartoon-intro-to-arraybuffers-and-sharedarraybuffers-zh/"/>
    <updated>2017-06-20T22:44:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2017/06/20/a-cartoon-intro-to-arraybuffers-and-sharedarraybuffers-zh</id>
    <content type="html"><![CDATA[<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_15.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_15.png</a>" width="400" height="350"></p>

<p>这是 3 篇文章中的第二篇：</p>

<ul>
<li><a href="http://zhaozhiming.github.io/blog/2017/06/20/a-crash-course-in-memory-management-zh/">内存管理速成教程</a></li>
<li>通俗漫画介绍 ArrayBuffers 和 SharedArrayBuffers</li>
<li><a href="http://zhaozhiming.github.io/blog/2017/06/21/avoiding-race-conditions-in-sharedarraybuffers-with-atomics-zh/">在 Sharedarraybuffers 中使用 Atomics 来避免竞态条件</a></li>
</ul>


<p>原文链接：<a href="https://hacks.mozilla.org/2017/06/a-cartoon-intro-to-arraybuffers-and-sharedarraybuffers/">A cartoon intro to ArrayBuffers and SharedArrayBuffers</a></p>

<!--more-->


<h1>通俗漫画介绍 ArrayBuffers 和 SharedArrayBuffers</h1>

<p>在<a href="http://zhaozhiming.github.io/blog/2017/06/20/a-crash-course-in-memory-management-zh/">上一篇文章中</a>，我解释了像 JavaScript 这样的内存自动管理语言如何操作内存，我也解释了像 C 语言这样的手动内存管理语言如何工作的。</p>

<p>为什么当我们讨论 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer">ArrayBuffers</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer">SharedArrayBuffers</a> 时这部分内容很重要呢？</p>

<p>这是因为 ArrayBuffers 提供了一种让你可以手动操作数据的方式，即使你是使用像 JavaScript 这种内存自动管理的语言。</p>

<p>为什么你将来会去做这件事（指内存管理）？</p>

<p>正如上一篇文章所说的，这是自动内存管理的一个权衡，它方便开发人员，但增加了开销，某些情况下，这种开销会导致性能问题。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_01.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_01.png</a>" width="400" height="350"></p>

<p>举个例子，当你要在 JS 中创建一个变量，引擎必须猜测这个变量是哪种类型，如何在内存中展示。因为这种猜测，JS 引擎通常会为变量预留比实际占用的更多的空间，依赖于变量，内存槽容量可能比实际需要的要大 2 到 8 倍，这将导致很多内存的浪费。</p>

<p>另外，某些创建和使用 JS 对象的模式可能让垃圾回收难以进行，如果你可以手动管理内存，你就可以在工作中选择一个正确分配和释放内存的策略。</p>

<p>大部分情况下，这不会有什么问题。大部分系统性能不会如此敏感，以致要你使用手动内存管理，而且通常情况下，手动管理内存甚至可能让程序变得更慢。</p>

<p>但有时候你需要处理一些底层的工作来让你的代码运行得尽可能的快，ArrayBuffers 和 SharedArrayBuffers 给你另外一个选择。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_02.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_02.png</a>" width="400" height="350"></p>

<h2>那么 ArrayBuffer 是如何工作的？</h2>

<p>基本上它就像 JavaScript 中的其他数组，但是你不能在里面放任何类型的数据，比如字符串和对象，你只能在里面放二进制字节（可以用来表示数字的那个东西）。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_03.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_03.png</a>" width="400" height="350"></p>

<p>有件事情我必须在这里澄清，实际上你不能直接添加二进制字节到 ArrayBuffer，ArrayBuffer 本身不知道这个字节应该多大，不同类型的数字应该如何转换成字节。</p>

<p>ArrayBuffer 本身只是一个 0 和 1 存放在一行里面的一个集合，ArrayBuffer 不知道第一个和第二个元素在数组中该如何分配。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_04.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_04.png</a>" width="400" height="350"></p>

<p>为了能提供上下文，为了能真正分解数据并放入到盒子中，我们需要将其封装在一个叫做 view 的东西里面。这些在数据上的 view 可以被添加进确定类型的数组，而且我们有很多种确定类型的数据可以使用。</p>

<p>例如，你可以使用一个 Int8 的确定类型数组来分离存放 8 位二进制字节。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_05.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_05.png</a>" width="400" height="350"></p>

<p>或者你可以使用一个无符号的 Int16 数组来分离存放 16 位二进制字节，这样如果是一个无符号的整数也能处理。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_06.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_06.png</a>" width="400" height="350"></p>

<p>你甚至可以在相同基础的 buffer 上使用不同的 view，同样的操作不同的 view 会给你不同的结果。</p>

<p>比如，如果我们在这个 ArrayBuffer 中从 Int8 view 里获取了元素 0 和 1，在 Uint16 view 中元素 0 会返回给我们不同的值，尽管它们包含的是完全相同的二进制字节。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_07.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_07.png</a>" width="400" height="350"></p>

<p>在这种方式中，ArrayBuffer 基本上扮演了一个原生内存的角色，它模拟了像 C 语言才有的那种直接访问内存的方式。</p>

<p>你可能想知道为什么我们不让程序直接访问内存，而是添加了这种抽象层。直接访问内存将导致一些安全漏洞，我会在以后的文章中解释。</p>

<h2>那么什么是 SharedArrayBuffer？</h2>

<p>为了解释 SharedArrayBuffers，我需要解释一点关于并行运行代码和 JavaScript 的知识。</p>

<p>你可以并行运行代码让你的代码跑的更快，或者让其更快地响应用户事件。为了做到这点，你需要分离你的工作。</p>

<p>在一个典型的 app 中，所有工作都在一个单独独立的主线程中被照看着，我以前讲过这个。主线程就像一个全栈开发，它负责 JavaScript，DOM 结构和页面布局。</p>

<p>如果你能减少主线程的工作量，不管是什么事情都对工作负载有帮助，在某些情况下，ArrrayBuffer 可以减少主线程的工作量。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_08.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_08.png</a>" width="400" height="350"></p>

<p>但是有些时候减少主线程的工作负载是不够的，有时候你需要一些援助，你需要分离工作。</p>

<p>在大部分编程语言中，通常分离工作的方式就是使用一种叫做线程的东西，基本上这就像有多个人在做同一个项目。如果你的任务都比较独立，你就可以将任务分配给不同的线程，这样所有线程都可以在相同的时间内独立完成任务。</p>

<p>在 JavaScript 中，你可以使用一个叫做 web worker 的东西来做这件事情，这些 web worker 跟你在其他语言中用到的线程有些许差别，它们默认不共享内存。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_09.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_09.png</a>" width="400" height="350"></p>

<p>这意味着如果你想要共享一些数据给其他线程，你需要复制它们，方法 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage"><code>postMessage</code></a> 可以做到这点。</p>

<p>postMessage 获取你放进去的任何数据，序列化它们，再将其发送给其他 web worker，然后其他 web worker 反序列数据再将其放入到内存。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_10.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_10.png</a>" width="400" height="350"></p>

<p>这是一个非常慢的过程。</p>

<p>某些类型的数据，像 ArrayBuffer，你能做的操作叫做转移内存，这意味着移动指定的内存块让其他 web worker 可以访问数据。<br/>
但第一个 web worker 就不能再访问移动后的数据了。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_11.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_11.png</a>" width="400" height="350"></p>

<p>在某些情况下这可以工作，但大部分情况是你需要高性能的并行方式，你真正需要的是拥有可以共享的内存。</p>

<p>这就是需要 SharedArrayBuffers 的原因。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_12.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_12.png</a>" width="400" height="350"></p>

<p>通过 SharedArrayBuffer，不管是 web worker，还是线程，都可以从相同的内存块中读写数据。</p>

<p>这意味着你不会有使用 postMessage 时的交流开销和延迟。所有 web worker 都可以立即访问数据。</p>

<p>在同一时刻所有线程都访问同一数据会有些危险，可能引起一个叫竞态条件的问题。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_13.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_13.png</a>" width="400" height="350"></p>

<p>我将在<a href="http://zhaozhiming.github.io/blog/2017/06/21/avoiding-race-conditions-in-sharedarraybuffers-with-atomics-zh/">下一篇文章</a> 中解释。</p>

<h2>SharedArrayBuffers 当前的现状是怎样的？</h2>

<p>SharedArrayBuffers 不久将会出现在所有主流浏览器中。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_14.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_14.png</a>" width="400" height="350"></p>

<p>它们已经在 Safari（在 Safari 10.1）里了，Firefox 和 Chrome 将在他们的 7/8 月的发布中引进它们，而且 Edge 也将在秋季的 Windows 更新中引进它们。</p>

<p>不过即使它们在所有主流浏览器中都可用，我们也不希望应用开发人员直接使用它们。实际上，我们推荐不用它们，你应该使用最高级别的抽象封装。</p>

<p>我们希望 JavaScript 库开发人员来创建对应的库来让你更方便和安全地使用 SharedArrayBuffers。</p>

<p>另外，一旦 SharedArrayBuffers 内置到平台中，WebAssembly 就可以使用它们来实现多线程支持。一旦到位，你就可以使用像 Rust 那样的并发抽象技术，Rust 的主要目标之一就是让你无所畏惧地使用并发编程。</p>

<p>在<a href="http://zhaozhiming.github.io/blog/2017/06/21/avoiding-race-conditions-in-sharedarraybuffers-with-atomics-zh/">下一篇文章</a>中，我们将介绍这些库作者使用的工具（Atomics），他们用来构建抽象层同时避免竞态条件。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_15.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_15.png</a>" width="400" height="350"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[内存管理速成教程]]></title>
    <link href="http://zhaozhiming.github.io/blog/2017/06/20/a-crash-course-in-memory-management-zh/"/>
    <updated>2017-06-20T19:29:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2017/06/20/a-crash-course-in-memory-management-zh</id>
    <content type="html"><![CDATA[<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_07.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_07.png</a>" width="400" height="350"></p>

<p>我一直很佩服那些能将复杂原理讲得通俗易懂的人，<a href="http://code-cartoons.com/">Lin Clark 女神</a> 就是其中一个，拜读完她新发布的系列文章“通俗漫画介绍 SharedArrayBuffers”之后，深深为之折服，文章不仅一如既往地通俗易懂，作者亲自画的图更是和文章相得益彰。看完萌生出了翻译该系列文章的想法，不过本人英文能力有限，如果觉得翻译地不好的还请看英文原版，英文版也是很容易理解的。</p>

<p>这是 3 篇文章中的第一篇：</p>

<ul>
<li>内存管理速成教程</li>
<li><a href="http://zhaozhiming.github.io/blog/2017/06/20/a-cartoon-intro-to-arraybuffers-and-sharedarraybuffers-zh/">通俗漫画介绍 ArrayBuffers 和 SharedArrayBuffers</a></li>
<li><a href="http://zhaozhiming.github.io/blog/2017/06/21/avoiding-race-conditions-in-sharedarraybuffers-with-atomics-zh/">在 Sharedarraybuffers 中使用 Atomics 来避免竞态条件</a></li>
</ul>


<p>原文链接：<a href="https://hacks.mozilla.org/2017/06/a-crash-course-in-memory-management/">A crash course in memory management</a></p>

<!--more-->


<h1>内存管理速成教程</h1>

<p>为了搞明白我们为什么把 SharedArrayBuffer 加入到 JavaScript，你首选需要搞懂一点关于内存管理方面的知识。</p>

<p>你可以把机器中的内存想象成一堆盒子，我觉得这个有点像你工作中的办公邮箱，或者学校学生的储物柜。</p>

<p>如果你想给学生们留一些东西，你可以把东西放到盒子里面。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_01.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_01.png</a>" width="400" height="350"></p>

<p>在每个盒子旁边都有一个数字，这就是内存地址，这用来让你告诉别人留给他们的东西在哪个位置。</p>

<p>每个盒子都有相同的大小，能容纳一定量的信息。盒子的容量指定给了机器，这个容量就叫字长。字长一般是 32 位或者 64 位，但为了让它容易演示，我会使用 8 位的字长。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_02.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_02.png</a>" width="400" height="350"></p>

<p>如果我们想要把数字 2 放到其中的一个盒子里，我们可以很容易地做到，因为数字很容易<a href="https://www.khanacademy.org/math/algebra-home/alg-intro-to-algebra/algebra-alternate-number-bases/v/decimal-to-binary">表现成二进制</a>。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_03.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_03.png</a>" width="400" height="350"></p>

<p>如果我们想要放一个不是数字的东西呢？比如字母 H ？</p>

<p>我们需要一个方法将其展示成数字，为了做到这一点，我们需要编码格式，比如 <a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8</a>，然后我们需要一个东西将其转换成数字。比如一个编码环，这样我们就可以存储它了。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_04.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_04.png</a>" width="400" height="350"></p>

<p>当我们想要从盒子中取出它时，我们需要一个解码器将其转换回字符 H 。</p>

<h2>自动内存管理</h2>

<p>当你使用 JavaScript 时，实际上你不需要过多考虑内存的事情，它是远离你的一个抽象概念，这意味着你不会直接和内存打交道。</p>

<p>JS 引擎作为一个中间人的角色来代替你打交道，它替你管理着内存。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_05.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_05.png</a>" width="400" height="350"></p>

<p>让我们写一些 JS 代码，比如 React，需要创建一个变量。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_06.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_06.png</a>" width="400" height="350"></p>

<p>JS 引擎做的事情就是运行通过编码器转换成二进制表示的值。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_07.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_07.png</a>" width="400" height="350"></p>

<p>然后它找到可以存放二进制表示值的空间，这个过程叫做分配内存。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_08.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_08.png</a>" width="400" height="350"></p>

<p>然后，引擎会跟踪这个变量是否仍然在程序中被引用，如果变量不在被使用，内存将被回收，这样 JS 引擎就可以存放新的值了。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_09.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_09.png</a>" width="400" height="350"></p>

<p>观察内存中的变量（包括字符串，对象和其他类型的值），当它们不再有用的时候清除它们的过程，叫做垃圾回收。</p>

<p>像 JavaScript 这种不用直接处理内存的语言，叫做内存自动管理语言。</p>

<p>内存自动管理可以让开发人员开发程序更加简单，但也增加了程序的开销，这些开销有时候会让性能变得不可预测。</p>

<h2>手动管理内存</h2>

<p>手动管理内存的语言不一样。举个例子，让我们看一下如果用 C 语言来写 React 的话（现在可以使用 WebAssembly 做到这一点），将如何处理内存。</p>

<p>C 语言没有像 JavaScript 那样有一个抽象层来管理内存，相反，你可以直接操作内存，你可以从内存中加载数据，你也可以直接在内存中存储数据。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_10.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_10.png</a>" width="400" height="350"></p>

<p>当你编译 C 或者其他语言成 WebAssembly 时，你使用的工具会添加一些辅助代码到你的 WebAssembly，例如添加编码和解码二进制字节的代码。这个代码叫做运行时环境。运行时代码会做一些像 JS 引擎在 JS 中做的事情。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_11.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_11.png</a>" width="400" height="350"></p>

<p>但对于一个手动管理内存语言来说，运行期不包括垃圾回收。</p>

<p>这并不意味着你什么事情都要自己做，即使是在手动管理内存语言里，你也会常受到语言运行期的帮助，拿 C 语言来说，运行期会跟踪自由列表中打开的内存地址。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_12.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/01_12.png</a>" width="400" height="350"></p>

<p>你可以使用<code>malloc</code>方法（内存分配）来让运行期找到哪些内存地址可以来存放你的数据，这将从自由列表中取出这些地址，当你处理完这些数据，你必须使用<code>free</code>方法来释放内存，然后这些地址将重新回到自由列表中。</p>

<p>你必须计算出什么时候来调用这些方法，这就是为什么我们叫它做手动内存管理了，你要自己来管理内存。</p>

<p>对于一个开发人员来说，计算出什么时候该释放哪个区域的内存是很难的，如果你的计算时间出错了，那么将可能引发缺陷甚至会导致一个安全漏洞，如果你不释放内存，那么内存终将会耗尽。</p>

<p>这就是为什么很多现代语言会使用自动内存管理，为了避免人为的错误，但这也带来了性能上的开销，我会在<a href="http://zhaozhiming.github.io/blog/2017/06/20/a-cartoon-intro-to-arraybuffers-and-sharedarraybuffers-zh/">下一篇文章</a> 讲更多这方面的内容。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[开发人员的业余项目]]></title>
    <link href="http://zhaozhiming.github.io/blog/2016/12/11/develpers-side-project-zh-cn/"/>
    <updated>2016-12-11T23:07:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2016/12/11/develpers-side-project-zh-cn</id>
    <content type="html"><![CDATA[<p><img src="/images/post/2016/12/side-project.png" width="400" height="350"></p>

<p>看到Joel大神最近的一篇不错的博文，忍不住翻译了一下，水平有限翻译不好的地方请大家见谅。</p>

<p>看完博文想到了美剧《硅谷》里面的一个情节：男主角因为业余项目被原来的老板控告，结果虽然是老板因为一些低级错误而败诉了，但就业余项目这个事情上男主角是败诉了的（因为用了一次公司的电脑……）。所以在业余项目上作为员工其实并不占优势，但也不应该放弃写业余项目，我想如果是开明的公司，只要不和公司的利益有冲突，都会鼓励员工做业余项目的。</p>

<p>原文地址见这里：<a href="https://www.joelonsoftware.com/2016/12/09/developers-side-projects/">Developer&rsquo;s side project</a>。</p>

<!--more-->


<p></p>

<h2>开发人员的业余项目</h2>

<p>几乎100%的开发人员在为其他人工作时最终都会签署一种类似叫“专利发明协议”的东西，但几乎所有的开发人员都不太明白这份协议有什么作用。大部分开发人员认为在工作时间所作的工作属于他们的雇主，但其他时间在家里做的东西应该属于他们自己。这个想法错了，而且错的有点危险。</p>

<p>所以让我们思考一下这个问题：如果你是一家软件公司工作的开发人员，公司拥有你在业余时间做的东西吗？</p>

<p>在我开始讲之前我先说一下，在网上查询和获取法律咨询之前要小心，因为我看到的错误信息多得足以让你惹上麻烦。非美国的读者也应该注意自己国家的法律和法律事务可能与此完全不同。</p>

<p>这里有三段信息你需要先了解，然后才能回答这个问题：</p>

<p>1、你在哪个州（或国家）被雇佣？<br/>
州法律在州与州之间是不同的，可能会覆盖特定的合同。</p>

<p>2、你的雇主和合同怎么说？<br/>
在美国，一般来讲，法院对让人们签署任何他们想要的合同都会非常宽容，但有时候州法律会明确地说“即使你签署了这样和那样的一份合同，法律还是有权利覆盖它”。</p>

<p>3、你是一个合同工还是一个雇员？在美国这是两种不同的雇佣方式，法律对这两种情况也会有所区分。</p>

<p>但在我开始解释这些问题之前，我们先将其分解一下。</p>

<p>想象一下你创建了一个软件公司，你需要一个开发人员，所以你从街对面雇了Sarah并以每小时20美元的薪水和她达成了协议，然后她将为你的软件产品写代码。她写代码，你付给她20美元一个小时，事情很顺利，对吧？</p>

<p>顺利……可能吧，在美国，如果你以合同工的方式雇佣Sarah，她仍然拥有工作的版权。这有点奇怪，因为你可能会说，“好吧，我已经付薪水给她了”。虽然听起来很奇怪，但这是版权工作的默认方式。实际上，如果你请了一个摄影师为你的婚礼拍照片，你可以拿到照片和照片的所有备份，但摄影师仍然拥有照片的版权并且可以合法地复制更多照片的备份。是不是很惊喜？代码也是一样的。</p>

<p>每个软件公司都想拥有雇员编写的代码的版权，所以没有一家软件公司可以接收法律的“默认”方式。这就是为什么所有管理比较好的软件公司都会要求所有开发人员至少要签署这样一份协议：</p>

<ul>
<li>以接受薪水作为交换</li>
<li>开发人员同意将版权“赋予”（给）公司</li>
</ul>


<p>这份协议会出现在雇佣合同或单独的一份“发明专利协议”合同里面。这种方式经常理解为使用法律形式让雇佣生效，意味着“我们决定版权属于公司而不是员工”。</p>

<p>现在，我们仍然没有讲任何关于空闲时间工作的事情。假设你现在有一家小游戏公司，不是开发软件，而是你需要每几个月制作三到四个好玩的游戏作为公司的拳头产品。你自己不会制作游戏，所以你出去找了一个游戏设计师来制作游戏。你将付给游戏设计师一个月6000美元来制作新游戏。那些游戏是聪明和新奇的，并且它们可以申请专利，公司拥有游戏的专利这点非常重要。</p>

<p>你的游戏设计师工作了一年并制作了7款游戏，在年末的时候她起诉了你，声明她拥有全部游戏中的4个，因为那些特定的游戏是她在下午5点到上午9点的时间开发的，这段时间不是上班时间。</p>

<p>糟糕，这不是你想要的，你想要支付她所有发明的游戏，然后你意识到需要支付的实际发明过程可能发生在任何时间：节假日，周末，在公司，在卧室，在家，在洗澡，在假期攀岩。</p>

<p>所以在你雇佣开发人员之前，你要达成协议，“嘿听着，我知道任何时候都可以制作游戏，而且不可能证明你坐在卧室椅子上开发的东西就是我需要支持的，我不只是想要购买你在9:00-5:00间的发明，我想要全部，并且我将付给你一个让你满意的薪资来得到全部”，然后她同意了，所以现在你想要签署一些关于她在雇佣期间所有发明都属于公司的协议。</p>

<p>这就是默认方式，这是开发人员、发明者，研究人员的标准雇佣合同。</p>

<p>即使一个公司决定，“天哪，我们不想拥有5:00-9:00间的发明”，他们不久也会陷入困境。为什么呢？因为他们可能需要引入一些投资，然后投资人会说，“请给我证明一下你们不会被一些有怨念的前雇员起诉，说在你卖的东西里面他们有发明权”。这个公司可能会拿出一份包括当前和之前的雇员名单，指出每一份说明了将发明授权给公司的合同。这个预计会成为每一次高新技术融资，合并和收购尽职调查的一部分，所以软件公司如果在取得授权这方面不小心的话，将无法得到融资，或合并，或被收购。从1998年开始，一个人以前没有签署协议然后现在又想签署协议将被认为是一个真正的混蛋，因为他知道他个人持有350000000美元的收购，所以他可以在签字时要求很多钱。</p>

<p>所以，每个软件公司都尝试拥有它所有员工做的东西（他们不会强制拥有不相关的业务项目，但通过纸质协议他们可以要求这些）。</p>

<p>作为软件开发人员听到这个消息会比较沮丧，他们一直想象他们可以晚上在自己的房间里在自己电脑上写自己的代码，然后拥有这些东西的版权和专利。所以在州立委会，在某些州（比如加州）但不包括其他州（比如不包括纽约），这些州立委会一般会通过以下这些法律：</p>

<p><blockquote><p>任何在你的时间, 通过你的设备做的事情，这个事情跟你老板的工作无关，那这个东西是属于你自己的，即使你签署了相关的合同也没有关系。<br/></p></blockquote></p>

<p>因为这是加州的法律，这个特殊条款被写入了标准的免责合同和加州律师事务所给他们的软件公司客户的大部分标准合同中，所以全国各地的程序员可以很好地在自己的合同中拥有他们，即使所在州没有要求这个东西。</p>

<p>让我们逐条分析一下。</p>

<p><strong>在你自己的时间里</strong>，我猜很容易理解。</p>

<p><strong>通过你自己的设备</strong>，这一条也不难理解。</p>

<p><strong>这个事情跟你老板的工作无关</strong>，额……等一下，无关的定义是什么？如果我的雇主是Google，他们什么都做，他们以前还搞了一个在该死的热气球上放网络路由器的事情，那么热气球是相关的吗？明显的，搜索引擎，邮件，网络应用和广告都和Google的工作相关，嗯……</p>

<p>好吧，如果我的雇主是一家给法律行业写软件的小公司，那么为会计行业写软件是“相关”的吗？</p>

<p>我不知道，这里的二义性大到你可以在中间开辆大卡车，这可能只有看法官或陪审团怎么决定了。</p>

<p>法官（或陪审团）对贫穷的雇员可能会比对大坏蛋Google更加友善，但你不能把赌注都压在这个上面。</p>

<p>二义性意味着在员工他们可以做任何事情的业余时间上产生了足够大的震慑效果，并且达到了老板想要的目的：员工不会被某天可以商业化的业余项目所打扰，然后老板可以看到每个员工早上漂亮、精神抖擞地来上班，即使员工昨天晚上看了一晚上的电视。</p>

<p>所以……来回答这个问题，在美国各个公司当程序员或适用的法律其实不大可能有特别大的差异，他们都需要握紧你的版权和专利而无需证明那是否在“上班时间”产生的，所以所有公司都会尝试做这个（译注：指签署协议），除非这家公司疏忽大意没有在适当的地方准备好合适的合同，这种情况下，这家公司可能缺乏管理并且这是一个不值得去那上班的理由。</p>

<p>唯一的不同是在管理的态度上，公司会对合同上的权利保持多强硬的态度，这可以有很多种不同：</p>

<ul>
<li>我们喜欢业余项目，玩得开心！</li>
<li>我们不是真正的喜欢业余项目，你应该为我们想想。</li>
<li>我们喜欢业余项目，我们太爱它们以致我们想拥有和出售它们！</li>
<li>我们其实不太关心，但如果你让我们不好受，我们会有很多方法让你更痛苦。如果你离开并开了一个和我们竞争的公司，或者是一个和我们半竞争的公司，我们将使用合同让你掉眼泪。但是，如果你没有让我们不好受，并且很忠诚地为我们服务，我们会在你的IPhone应用达到每月盈利40000美金时寻找一种合适的方式。</li>
</ul>


<p>这些都可能会变化，取决于跟你谈话的人，这个人在任何特定时间内都有强大的权利，或者取决于你是否跟你老板睡过觉。你能够获得独立的唯一方法就是自己独立。作为一个做智能产品的高技术公司员工，意味着你已经决定要出售自己的智力输出，这可能是好的，也可能是不好的，但这是一个自由的选择。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[前端学习之道]]></title>
    <link href="http://zhaozhiming.github.io/blog/2015/12/06/how-to-learn-front-end/"/>
    <updated>2015-12-06T15:29:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2015/12/06/how-to-learn-front-end</id>
    <content type="html"><![CDATA[<p><img src="/images/post/2015-12/front-end-learn.png" width="400" height="350"></p>

<p>最近一直在学习前端，今天看到一篇关于前端学习的文章，文中的观点深以为然，于是简单翻译了一下，文章是根据自己理解翻译的，不是直译，在翻译过程中会穿插介绍一些相关的学习资料。<br/>
原文地址见这里：<a href="https://medium.com/@djsmith42/what-web-framework-should-i-learn-a9285925ca1f#.g49ru17as">我应该学习什么web框架</a>。</p>

<!--more-->


<p></p>

<h2>我应该学习什么web框架</h2>

<p>很多人问我这个问题，以前我会反问你问这个问题的动机是什么，是想提高你收割offer的能力，还是对个人学习比较感兴趣？现在我已不再相信这些问题的答案了，因为我已经有了这个问题的“通用”答案。</p>

<p>在即将迈进2016年的今天，明显感觉web开发的技术更新步伐越来越快，现在已经没有一种“框架”可以终身使用，事实上现在已经没有任何一种“东西”（包括语言，工具等）可以使用终身。比如在今年我在工作中就使用了3种构建工具，3种web框架，3种编程语言（译者注：作者经历跟我有点相似，我今年web开发框架用了3种，前端框架用了2种，编程语言用了3种，构建工具用了3种）。</p>

<p><strong> 所以我觉得值得持续做的事情就是不断学习。</strong></p>

<p>新技术不断涌现，推陈出新的速度越来越快，特别是在前端开发这个生态体系里面。我不认为未来会长期依赖某一项技术，即使这门技术现在看来非常热门，甚至是现在火遍全球的<code>React</code>我也觉得不会。</p>

<p>如果你想学习一样以后可以长期使用的技能，那只有一样：提高你学习的能力。那么问题来了，你怎么学习如何学习？</p>

<p>因为我们讨论的是前端开发，所以我推荐最开始的时候应该学习JavaScript这门语言的基础知识，这方面的知识学习得越多越好，不管是书籍，博客，视频，练习还是其他，找到一种适合你的学习方式，然后<strong>深入学习</strong>（译者注：这里我推荐<a href="http://book.douban.com/subject/1232061/">《JavaScript权威指南》</a>和<a href="http://book.douban.com/subject/10546125/">《JavaScript高级程序设计》</a>）。这可能是一个长期的过程，但我推荐你花一个月的时间来专注学习它，这可能是你将来成功的基石。我的意思并不是说让你完全不管工作和家庭中的事情，而是说将除了工作和家庭之外用来学习的时间，全部花在学习JavaScript上。如果你已经是一个JavaScript大师的话可能用不到一个月的时间，但还是值得花些时间来学习，因为有时候你不知道有哪些知识是你不知道的（译者注：所谓‘温故而知新’嘛）。</p>

<p>下一个阶段就是学习前端的另外一样基础知识——<code>DOM</code>了，同样地持续学习直到你觉得自己能熟练地掌握它（译者注：推荐<a href="http://book.douban.com/subject/6038371/">JavaScript DOM编程艺术</a>）。</p>

<p>当你在这方面打好坚实的地基以后，你可能会了解到更多的框架，关于这一点我推荐尽可能地学习更多的框架和工具。我的意思不是说要把所有新框架都用到你的生产环境上，但你应该通过开发一个小应用来学会如何使用它。在学习这些框架的过程中你会发现你的学习速度越来越快，以前可能需要几天，现在只要几个小时就学会了。</p>

<p>这段时间的学习目的不是为了掌握所有你学过的框架，而是为了锻炼你<strong>快速掌握</strong>一种新技术的能力。我并不是说你不能专门研究某一个框架，你可以选择一两个框架来专门研究，然后在你的工作中使用它们，或者是在未来的工作中使用它们（除非它过时了，当然每个框架都会过时的）。这个阶段的练习是为了实践如何学习，持续地学习。</p>

<p>大部分人没办法在工作中保持这种学习，因为这需要占用工作之外的时间。可能在未来的某一天，我们的企业会完善到可以在工作中提供我们学习的时间，因为这种学习最终会让企业受益，但在今天，大部分公司还做不到。所以你只能通过自己的时间来学习，我推荐你通过一个好玩的小项目来学习，比如<a href="https://www.youtube.com/watch?v=m3jMWnrbUZA">watering your lawn</a>，你可以一遍又一遍的使用这个项目来学习新的框架和工具。</p>

<p>如果你把这些都做好了，你不仅仅是一个牛逼的前端工程师，而且你会得到快速进入其他领域的能力。想要进入移动端？没有问题！想要进入后端开发？没有问题！想要进入嵌入式设备？没有问题！你已经很擅长学习新知识了。</p>

<p>总的来说，在你的学习能力上面进行投资比对某一个框架，编程语言或者技术投资更为重要，在持续学习过程中学会如何学习。</p>
]]></content>
  </entry>
  
</feed>
