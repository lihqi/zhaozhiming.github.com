<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: test | Hacker and Geeker's Way]]></title>
  <link href="http://zhaozhiming.github.io/blog/categories/test/atom.xml" rel="self"/>
  <link href="http://zhaozhiming.github.io/"/>
  <updated>2016-12-13T11:25:35+08:00</updated>
  <id>http://zhaozhiming.github.io/</id>
  <author>
    <name><![CDATA[赵芝明]]></name>
    <email><![CDATA[kingzzm1982@sina.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用AVA和Enzyme测试React组件（三）]]></title>
    <link href="http://zhaozhiming.github.io/blog/2016/03/29/use-ava-and-enzyme-to-test-react-component-part3/"/>
    <updated>2016-03-29T20:42:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2016/03/29/use-ava-and-enzyme-to-test-react-component-part3</id>
    <content type="html"><![CDATA[<p>{% img /images/post/2016/03/react.png %}</p>

<p><strong>React组件的测试要点</strong>：React组件要怎么测试，有哪些需要注意的地方，今天我们通过一些例子来说明。</p>

<!--more-->


<p></p>

<h2>render逻辑的测试</h2>

<p>React中存在逻辑的地方有一部分是在render方法中，React通过props或state的值可以render出不同的页面，所以我们可以通过设置不同的props值来测试是否能render出我们期望的页面。比如有下面这样的一个组件：</p>

<p>{% codeblock lang:js %}
class Footer extends Component {
  renderFooterButtons(completedCount, clearCompleted) {</p>

<pre><code>// 测试点1
if (completedCount &gt; 0) {
  return (
    &lt;button className="clear-completed" onClick={ () =&gt; clearCompleted() }&gt;Clear completed&lt;/button&gt;
  );
}
</code></pre>

<p>  }</p>

<p>  render() {</p>

<pre><code>const { todos, actions, onShow } = this.props;
const { clearCompleted } = actions;
const activeCount = todos.reduce((count, todo) =&gt; todo.completed ? count : count + 1, 0);
const completedCount = todos.length - activeCount;
return (
  &lt;footer className="footer"&gt;
    &lt;span className="todo-count"&gt;&lt;strong&gt;{activeCount}&lt;/strong&gt; item left&lt;/span&gt;
    &lt;ul className="filters"&gt;
      // 测试点2
      {[SHOW_ALL, SHOW_ACTIVE, SHOW_COMPLETED].map(filter =&gt;
        &lt;li key={filter}&gt;
          &lt;a className={classnames({ selected: filter === this.props.filter })}
            style={{ cursor: 'pointer' }}
            onClick={ () =&gt; onShow(filter) }&gt;{FILTER_TITLES[filter]}&lt;/a&gt;
        &lt;/li&gt;
      )}
    &lt;/ul&gt;
    {this.renderFooterButtons(completedCount, clearCompleted)}
  &lt;/footer&gt;
);
</code></pre>

<p>  }
}
{% endcodeblock %}</p>

<p>可以看到这个组件其实是比较简单的，在一个<code>footer</code>标签里面有个<code>span</code>和一个<code>ul</code>，<code>ul</code>里面有一些<code>li</code>，最下面是个<code>button</code>。</p>

<ul>
<li>在最上面有一个render button的方法，这个方法存在逻辑判断，如果completedCount大于0，则render一个button出来，否则不render button，这里是我们第一个测试点。测试代码如下，分别测试render和不render的情况：</li>
</ul>


<p>{% codeblock lang:js %}
const props = {
  todos: [], // 空的数组
  actions: {</p>

<pre><code>clearCompleted: sinon.spy(), // mock方法
</code></pre>

<p>  },
  onShow: sinon.spy(), // mock方法
  filter: &lsquo;SHOW_ALL&rsquo;,
};</p>

<p>test(&lsquo;do not render button&rsquo;, t => {
  const wrapper = shallow(<Footer {...props} />);
  t.is(wrapper.find(&lsquo;button&rsquo;).length, 0);
});</p>

<p>test(&lsquo;render button correctly&rsquo;, t => {
  const wrapper = shallow(<Footer {...props} />);
  wrapper.setProps({ todos: [{ completed: true }] });
  t.is(wrapper.find(&lsquo;button&rsquo;).length, 1);
});
{% endcodeblock %}</p>

<p>要让completedCount不大于0，只要给个空的todos集合就可以了，如果要大于0的话，则需要在todos里面添加一个<code>completed</code>为true的对象，这里需要搞清楚completedCount的声明逻辑。</p>

<ul>
<li>第二个测试点是map方法里面的逻辑，因为是从一个有3个元素的数组里面做map，所以可以校验是否确实render出来3个<code>li</code>，以及其中某个<code>li</code>链接的class和文本内容。</li>
</ul>


<p>{% codeblock lang:js %}
test(&lsquo;render 3 li correctly&rsquo;, t => {
  const wrapper = shallow(<Footer {...props} />);
  wrapper.setProps({ todos: [{ completed: true }] });
  t.is(wrapper.find(&lsquo;li&rsquo;).length, 3);
  t.is(wrapper.find(&lsquo;a.selected&rsquo;).length, 1);
  t.is(wrapper.find(&lsquo;a.selected&rsquo;).text(), &lsquo;All&rsquo;);
});
{% endcodeblock %}</p>

<p>可以看到通过enzyme的text方法可以很方便地得到<code>a</code>标签的文本内容。</p>

<p>这个组件其实还继续做测试，比如<code>span</code>里面的render逻辑等，但这里就不详细举例了。</p>

<h2>组件的事件逻辑</h2>

<p>除了在render方法中有逻辑以外，在组件的事件中也会存在逻辑，要测试这部分代码，我们需要模拟触发组件的事件。请看下面这个组件：</p>

<p>{% codeblock lang:js %}
class TodoInput extends Component {
  constructor(props, context) {</p>

<pre><code>super(props, context);
this.state = {
  text: this.props.text || '',
};
</code></pre>

<p>  }</p>

<p>  handleChange(e) {</p>

<pre><code>this.setState({ text: e.target.value });
</code></pre>

<p>  }</p>

<p>  handleBlur(e) {</p>

<pre><code>if (!this.props.newTodo) {
  this.props.onSave(e.target.value.trim());
}
</code></pre>

<p>  }</p>

<p>  render() {</p>

<pre><code>return (
  &lt;input className={
    classnames({
      edit: this.props.editing,
      'new-todo': this.props.newTodo,
    })}
    type="text"
    placeholder={this.props.placeholder}
    autoFocus="true"
    value={this.state.text}
    onBlur={this.handleBlur.bind(this)}
    onChange={this.handleChange.bind(this)}
  /&gt;
);
</code></pre>

<p>  }
}
{% endcodeblock %}</p>

<p>可以看到这个组件的render方法里面没有什么逻辑，只有一个<code>input</code>标签，但是在标签中存在了<code>change</code>和<code>blur</code>事件，组件的逻辑隐藏在对应的事件方法中。</p>

<ul>
<li>首先是对<code>change</code>事件的测试，我们可以看到<code>handleChange</code>方法其实是修改state里面text的值，所以测试代码可以这样写：</li>
</ul>


<p>{% codeblock lang:js %}
const props = {
  text: &lsquo;foo&rsquo;,
  placeholder: &lsquo;foo placeholder&rsquo;,
  editing: false,
  newTodo: false,
  onSave: sinon.spy(),
};</p>

<p>test(&lsquo;input change value correctly&rsquo;, t => {
  const wrapper = shallow(<TodoInput {...props} />);
  wrapper.find(&lsquo;input&rsquo;).simulate(&lsquo;change&rsquo;, { target: { value: &lsquo;bar&rsquo; } });
  t.is(wrapper.state(&lsquo;text&rsquo;), &lsquo;bar&rsquo;);
});
{% endcodeblock %}</p>

<p>通过调用<code>simulate</code>方法对<code>change</code>事件进行模拟，然后调用<code>state</code>方法对组件的state进行校验。</p>

<ul>
<li>接着我们测试<code>blur</code>事件，<code>handleBlur</code>方法先做判断，如果为真则调用props中的<code>onSave</code>方法，我们可以用sinon来mock onSave方法，校验其调用次数。</li>
</ul>


<p>{% codeblock lang:js %}
test(&lsquo;input blur correctly&rsquo;, t => {
  const wrapper = shallow(<TodoInput {...props} />);
  wrapper.find(&lsquo;input&rsquo;).simulate(&lsquo;blur&rsquo;, { target: { value: &lsquo;bar&rsquo; } });
  t.is(props.onSave.callCount, 1);
{% endcodeblock %}</p>

<p>模拟事件触发的方法差不多，都是传入事件名和所需的方法对象就可以了，这里校验<code>onSave</code>是否被调用了1次。</p>

<p>在写单元测试的时候，有一点要注意的是要避免过度测试，因为测试代码也是需要维护的，如果测试过多过细，那一旦生产代码有所改变，就可能会修改很多测试代码，需要开发人员需要在质量和开发效率上面做好均衡。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用AVA和Enzyme测试React组件（二）]]></title>
    <link href="http://zhaozhiming.github.io/blog/2016/03/29/use-ava-and-enzyme-to-test-react-component-part2/"/>
    <updated>2016-03-29T20:42:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2016/03/29/use-ava-and-enzyme-to-test-react-component-part2</id>
    <content type="html"><![CDATA[<p>{% img /images/post/2016/03/airbnb.png 400 300 %}</p>

<p>Enzyme是<a href="http://www.airbnb.com/">Airbnb</a>公司推出的一个针对React组件的测试工具。Airbnb我觉得是国外继Google和Facebook之后技术实力十分强大的一家科技公司，有很多开源项目获得广大开发人员的认可，Enzyme就是其中的一个。</p>

<!--more-->


<p></p>

<h2>React的测试方式</h2>

<p>Facebook在推出React的时候也推出一个测试套件，可以使用shallow render（浅渲染）和renderIntoDocument（完整渲染）的方式对React组件进行渲染，然后通过查找DOM来做测试结果校验。两者的主要区别是shallow render只渲染出组件的第一层DOM，其嵌套的DOM不会渲染出来，这样渲染的效率更高，单元测试的速度更快，在做单元测试的时候建议使用shallow render的方式。</p>

<p>Enzyme对Facebook的测试套件做了封装，并提供了一套API来让开发者做React单元测试的时候更加方便，下面的例子可以对比使用了Enzyme前后的区别。</p>

<p>使用Enzyme前：<br/>
{% codeblock lang:js %}
const output = setup({&hellip;props});
const ul = output.props.children;
const li = ul.props.children;
const a = li.props.children;
express(a.size).to.be.equal(1);
{% endcodeblock %}</p>

<p>使用Enzyme后：<br/>
{% codeblock lang:js %}
const wrapper = shallow(<Foo {...props} />);
express(wrapper.find(&lsquo;a&rsquo;).length).to.be.equal(1);
{% endcodeblock %}</p>

<p>最明显的变化是测试代码变少了，原来需要逐层查找DOM，现在只需要一个<code>find()</code>方法就可以搞定。</p>

<h2>Shallow Rendering &amp; Full DOM Rendering</h2>

<p>Enzyme针对这两种渲染方式都提供了各自一套API方法，但其实这2套API的方法差不多相同，只有个别方法不一样。</p>

<p>{% codeblock lang:js %}
.find(selector) => ShallowWrapper
.children() => ShallowWrapper
.parent() => ShallowWrapper
.closest(selector) => ShallowWrapper
.unmount() => ShallowWrapper
.text() => String
.state([key]) => Any
.simulate(event[, data]) => ShallowWrapper
.setState(nextState) => ShallowWrapper
.setProps(nextProps) => ShallowWrapper
.debug() => String
{% endcodeblock %}</p>

<p>这里只列出了一小部分API，不但可以通过find方法查找DOM元素，还可以模拟DOM的事件，比如Click，Change等。</p>

<h2>常用的方法</h2>

<ul>
<li>find方法</li>
</ul>


<p>find方法可以让你方便的查找到DOM元素，支持通过class名称查找，html标签查找，id查找，甚至是自定义组件的查找等。</p>

<p>{% codeblock lang:js %}
const wrapper = shallow(<MyComponent />);
expect(wrapper.find(&lsquo;.foo&rsquo;)).to.have.length(1);
// compound selector
expect(wrapper.find(&lsquo;div.some-class&rsquo;)).to.have.length(3);
// CSS id selector
expect(wrapper.find(&lsquo;#foo&rsquo;)).to.have.length(1);
// Component
expect(wrapper.find(Foo)).to.have.length(1);
{% endcodeblock %}</p>

<ul>
<li>simulate方法</li>
</ul>


<p>simulate方法让你可以模拟DOM元素的事件，传入参数是事件名和事件参数。</p>

<p>{% codeblock lang:js %}
const wrapper = shallow(<MyComponent />);
wrapper.find(&lsquo;a&rsquo;).simulate(&lsquo;click&rsquo;);
wrapper.find(&lsquo;a&rsquo;).simulate(&lsquo;change&rsquo;, { target: { value: &lsquo;foo&rsquo; } });
{% endcodeblock %}</p>

<ul>
<li>debug方法</li>
</ul>


<p>debug方法可以让你打印出组件的DOM信息，方便测试遇到问题进行调试。</p>

<p>{% codeblock lang:js %}
const wrapper = shallow(<Book title="Huckleberry Finn" />);
console.log(wrapper.debug());</p>

<p>Outputs to console:</p>

<div>
 <h1 className="title">Huckleberry Finn</h1>
</div>


<p>{% endcodeblock %}</p>

<ul>
<li>props和state等方法</li>
</ul>


<p>对应React组件的props和state，Enzyme也有一些方法可以让你set和get其中的值，对于重置React组件的状态非常有用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用AVA和Enzyme测试React组件（一）]]></title>
    <link href="http://zhaozhiming.github.io/blog/2016/03/28/use-ava-and-enzyme-to-test-react-component-part1/"/>
    <updated>2016-03-28T20:20:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2016/03/28/use-ava-and-enzyme-to-test-react-component-part1</id>
    <content type="html"><![CDATA[<p>{% img /images/post/2016/03/ava.png 400 300 %}</p>

<p>React的出现让页面的测试发生了变化，原来一些耗时耗性能的自动化测试可以转化成快速的单元测试，今天介绍一下如何做React的单元测试，以及AVA和Enzyme的使用。</p>

<!--more-->


<p></p>

<h2><a href="https://github.com/sindresorhus/ava">AVA</a>是什么</h2>

<p>AVA是一个JS的单元测试框架，与其他测试框架相比最大的特点是可以并发运行测试，并行地执行每个测试文件，让CPU的利用率达到最大化。有个项目使用AVA让单元测试的执行时间从31秒（原来是用Mocha）下降到11秒。另外AVA的团队也是几个开源社区的大神，为首的<a href="https://github.com/sindresorhus">sindresorhus</a>是github上获得星星最多的人。</p>

<h2>为什么选择AVA</h2>

<p>前端也有很多不错的测试框架，比如<a href="https://github.com/mochajs/mocha">Mocha</a>、<a href="https://testanything.org/">Tap</a>和<a href="https://github.com/substack/tape">Tape</a>等，但AVA这个后起之秀是青出于蓝而胜于蓝，除了上面说的并发测试这个优点外，还有配置简单，多种报告，环境隔离等优点。Mocha的作者<a href="https://github.com/tj">TJ</a>也是个牛人，他对AVA推崇有加，说如果让他来重新开发Mocha的话他也会按照AVA这种思路来做。</p>

<h2>AVA的语法</h2>

<p>{% codeblock lang:js %}
import test from &lsquo;ava&rsquo;;</p>

<p>test(&lsquo;my first test&rsquo;, t => {
  t.same([1, 2], [1, 2]);
});
{% endcodeblock %}</p>

<p>test方法可以带一个字符串的标题和一个回调函数，这个回调函数就是你的测试代码，使用过其他测试框架的开发人员可以很快熟悉它的API并写出自己的测试。</p>

<h2>AVA的配置</h2>

<p>AVA的配置也十分简单，虽然Mocha的配置也不复杂，但相对于后者AVA的配置特点是灵活和集中，你可以用多种方式来配置AVA，就拿配置Babel来说，你可以将Babel配置一起写在<code>package.json</code>里面，也可以将Babel配置写在原来的Babel配置文件中，而在<code>package.json</code>文件里面写上<code>babel: inherit</code>的配置就可以了。</p>

<p>{% codeblock lang:json %}
{
  &ldquo;babel&rdquo;: {</p>

<pre><code>"presets": [
  "es2015",
  "stage-0",
  "react"
]
</code></pre>

<p>  },
  &ldquo;ava&rdquo;: {</p>

<pre><code>"babel": "inherit",
</code></pre>

<p>  },
}
{% endcodeblock %}</p>

<h2>AVA的断言</h2>

<p>AVA内置了断言库，几个常用的断言方法已经可以满足大部分的断言需求，无需再用其他的断言库。</p>

<p>{% codeblock lang:js %}
.pass([message])
.fail([message])
.ok(value, [message])
.notOk(value, [message])
.true(value, [message])
.false(value, [message])
.is(value, expected, [message])
.not(value, expected, [message])
.same(value, expected, [message])
.notSame(value, expected, [message])
.throws(function|promise, [error, [message]])
.notThrows(function|promise, [message])
.regex(contents, regex, [message])
.ifError(error, [message])
{% endcodeblock %}</p>

<p>当然你也可以集成其他的第三方断言库，比如<a href="http://chaijs.com/">chai</a>，但这样的话你可能就使用不到测试方法中<code>t</code>这个测试对象了。</p>

<p>{% codeblock lang:js %}
import { exppect } from &lsquo;chai&rsquo;;
import test from &lsquo;ava&rsquo;;</p>

<p>test(&lsquo;my first test&rsquo;, t => {
  expect([1, 2]).to.deep.equal([1, 2]);
});
{% endcodeblock %}</p>

<h2>AVA的多种支持</h2>

<ul>
<li>支持Promise</li>
</ul>


<p>{% codeblock lang:js %}
test(t => {
  return somePromise().then(result => {</p>

<pre><code>t.is(result, 'unicorn');
</code></pre>

<p>  });
});
{% endcodeblock %}</p>

<ul>
<li>支持Async</li>
</ul>


<p>{% codeblock lang:js %}
test(async t => {
  const value = await promiseFn();
  t.true(value);
});
{% endcodeblock %}</p>

<ul>
<li>支持Callback</li>
</ul>


<p>{% codeblock lang:js %}
test.cb(t => {
  fs.readFile(&lsquo;data.txt&rsquo;, t.end);
});
{% endcodeblock %}</p>

<p>现在有了async和promise一般不推荐再使用callback，AVA的callback支持是为了方便测试使用了callback的遗留代码。<br/>
<strong>注意，测试callback需要调用<code>t.end</code>方法来结束测试。</strong></p>

<h2>隔离环境</h2>

<p>AVA会为每个测试环境单独启动一个进程来跑测试，这样的好处就保证了每个测试文件的环境不会受到其他测试文件的影响，也要求你写测试的时候更注重原子性，要求测试不依赖其他测试的运行结果或者测试数据，让测试具有独立性。</p>

<p>但并发测试也会带来一些测试方法上的改变，比如说以前串行测试要测试文件的IO操作，可能会临时创建一个文件来进行读写，串行测试时由于每个测试都是顺序进行的，所以只需要一个文件就可以满足需求。但如果是并发测试，一个临时文件可能会被多个测试同时进行读写，这样就会导致冲突，最好的做法是为每个测试都单独创建一个临时文件来做测试。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Mocha + chai + sinon 测试React + Redux的web应用]]></title>
    <link href="http://zhaozhiming.github.io/blog/2015/12/19/use-mocha-and-chai-and-sinon-to-test-react-and-redux-webapp/"/>
    <updated>2015-12-19T19:29:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2015/12/19/use-mocha-and-chai-and-sinon-to-test-react-and-redux-webapp</id>
    <content type="html"><![CDATA[<p>{% img /images/post/2015-12/front_end_test.png %}</p>

<p>今天来介绍一下如何使用Mocha + Chai + Sinon测试基于Redux + React的web应用，以及介绍一些在使用过程中遇到的问题和解决方法。</p>

<!--more-->


<p></p>

<h2>Mocha</h2>

<p><a href="https://mochajs.org">Mocha</a>是一个JS的测试框架，类似于Java中的Junit、Python中的nose。Mocha的使用非常简单，使用<code>describe</code>和<code>it</code>就可以写单元测试，下面是代码示例。</p>

<p>{% codeblock lang:js %}
import {expect} from &lsquo;chai&rsquo;;</p>

<p>describe(&lsquo;Array&rsquo;, function() {
  describe(&lsquo;#indexOf()&rsquo;, function () {</p>

<pre><code>it('should return -1 when the value is not present', function () {
  expect([1,2,3].indexOf(5)).to.be.equal(-1);
  expect([1,2,3].indexOf(0)).to.be.equal(-1);
});
</code></pre>

<p>  });
});
{% endcodeblock %}</p>

<h2>Chai</h2>

<p><a href="http://chaijs.com">Chai</a>是一个单元测试的验证框架，它有3种不同形式的校验：expect、should和assert。expect和should的方式让写出来的测试代码更像自然语言，让业务人员也可以看懂，而assert方式是传统单元测试断言的方式，如果以前习惯写Java的单元测试会对这种方式比较熟悉。</p>

<p>{% img /images/post/2015-12/chai.png %}</p>

<h2>Sinon</h2>

<p><a href="http://sinonjs.org/">Sinon</a>是一个mock框架，类似Java的mockito。它可以对任何对象进行mock，更重要的是它提供了一些对mock对象的校验方法。</p>

<p>{% codeblock lang:js %}
// 创建mock对象
const callback = sinon.spy();
// 调用测试方法
const proxy = once(callback);</p>

<p>// 校验mock对象是否被调用;
assert(callback.called);
// 校验被调用了多少次
assert(callback.calledOnce);
assert.equals(callback.callCount, 1);
// 校验被哪个对象调用
 assert(callback.calledOn(obj));
// 校验被调用时传入了哪些参数
assert(callback.calledWith(1, 2, 3));
{% endcodeblock %}</p>

<h2>Redux + React</h2>

<p>React不用介绍了，今年最火的一个前端框架，而<a href="https://github.com/rackt/redux">Redux</a>是一个传递、处理state数据的JS框架，配合React可以很方便的处理staet数据，从而达到通过state控制渲染页面的目的。作者<code>Dan Abramov</code>自己拍了一个Redux的教学视频，里面通过一个个demo演示了如何写react和redux，视频可以见<a href="https://egghead.io/series/getting-started-with-redux">这里</a>。</p>

<p>对于Redux和React的应用，最主要的代码有3个部分，分别是actions，reducers，components。actions是发送一个状态到reducers，reducers根据状态返回修改后的state，components接收到state后刷新页面，所以我们的测试主要针对这3个部分。</p>

<h3>actons测试</h3>

<p>action的代码可能是这样的，接收从component传过来的一个参数，返回一个带有type属性的一个对象。</p>

<p>{% codeblock lang:js %}
export function addTodo(text) {
  return {type: ADD_TODO, text};
}
{% endcodeblock %}</p>

<p>actions的测试比较简单，就是返回一个对象，测试代码可以这样写：</p>

<p>{% codeblock lang:js %}
import {expect} from &lsquo;chai&rsquo;;
import * as actions from &lsquo;actions/todos&rsquo;;</p>

<p>describe(&lsquo;todo actions&rsquo;, () => {
  it(&lsquo;add todo should create ADD_TODO action&rsquo;, () => {</p>

<pre><code>expect(actions.addTodo('Use Redux')).to.deep.equal({
  type: 'add_todo',
  text: 'Use Redux',
});
</code></pre>

<p>  });
});
{% endcodeblock %}</p>

<p>这里使用了chai的expect校验方式，传入一个字符串，验证是否返回正确的对象，这里使用了<code>to.deep.equal</code>这个校验方法，可以校验对象的属性是否相等，而对于number、bool等基本类型的校验可以使用<code>to.be.equal</code>这个校验方法。</p>

<h3>reducers测试</h3>

<p>reducers代码如下，在原来的state基础上加上一个新的todo对象。</p>

<p>{% codeblock lang:js %}
export default function todos(state = initState, action) {
  switch (action.type) {
  case ADD_TODO:</p>

<pre><code>return [
  ...state,
  {
    text: action.text,
    completed: false,
    id: new Date().getTime(),
  },
];
</code></pre>

<p>  }
}
{% endcodeblock %}</p>

<p>测试代码可以这样写：</p>

<p>{% codeblock lang:js %}
describe(&lsquo;reducers&rsquo;, () => {
  describe(&lsquo;todos&rsquo;, () => {</p>

<pre><code>it('should add todo correctly', () =&gt; {
  const state = todos({}, {type: ADD_TODO, text: 'foo'});
  expect(state.length).to.be.equal(1);
  expect(state[0].text).to.be.equal('foo');
  expect(state[0].completed).to.be.equal(false);
});
</code></pre>

<p>  });
});
{% endcodeblock %}</p>

<p>测试时传入一个空的state对象和一个action对象，验证返回的state是否增加了一个todo对象。</p>

<h3>components测试</h3>

<p>components的测试比较复杂，除了测试render后的页面，还需要测试一些component的DOM方法，比如click，change，doubleclick等。下面是一个Header组件，它有<code>h1</code>和另外一个自定义组件<code>TodoInput</code>，其中还有一个<code>handleSave</code>的自定义方法，所以我们要测试的就主要是render和这个方法。</p>

<p>{% codeblock lang:js %}
import React, { PropTypes, Component } from &lsquo;react&rsquo;;
import TodoInput from &lsquo;./TodoInput&rsquo;;
class Header extends Component {
  handleSave(text) {</p>

<pre><code>if (text &amp;&amp; text.length !== 0) {
  this.props.actions.addTodo(text);
}
</code></pre>

<p>  }
  render() {</p>

<pre><code>return (
  &lt;header className="header"&gt;
    &lt;h1&gt;Todo List&lt;/h1&gt;
    &lt;TodoInput newTodo placeholder="请录入..." onSave={(text) =&gt; this.handleSave(text)}/&gt;
  &lt;/header&gt;
);
</code></pre>

<p>  }
}
Header.propTypes = {
  actions: PropTypes.object.isRequired,
};
export default Header;
{% endcodeblock %}</p>

<p>测试React的component，需要用到react的一个测试组件<a href="https://facebook.github.io/react/docs/test-utils.html">Test Utils</a>，在写测试代码之前，需要先构造组件render的页面，渲染页面的props参数和render页面的对象，这些在后面的测试中非常有用。</p>

<p>{% codeblock lang:js %}
import sinon from &lsquo;sinon&rsquo;;
import {expect} from &lsquo;chai&rsquo;;
import React from &lsquo;react&rsquo;;
import TestUtils from &lsquo;react-addons-test-utils&rsquo;;
import Header from &lsquo;components/Header&rsquo;;
import TodoInput from &lsquo;components/TodoInput&rsquo;;
function setup() {
  const actions = {addTodo: sinon.spy()};
  const props = {actions: actions};
  const renderer = TestUtils.createRenderer();
  renderer.render(<Header {...props} />);
  const output = renderer.getRenderOutput();
  return {props, output, renderer};
}
{% endcodeblock %}</p>

<p>构造完这些对象后，我们先对render方法进行测试。</p>

<p>{% codeblock lang:js %}
describe(&lsquo;Header&rsquo;, () => {
   it(&lsquo;should render correctly&rsquo;, () => {</p>

<pre><code> const { output } = setup();

 expect(output.type).to.be.equal('header');
 expect(output.props.className).to.be.equal('header');

 const [ h1, input ] = output.props.children;

 expect(h1.type).to.be.equal('h1');
 expect(h1.props.children).to.be.equal('Todo List');

 expect(input.type).to.be.equal(TodoInput);
 expect(input.props.newTodo).to.be.equal(true);
 expect(input.props.placeholder).to.be.equal('请录入...');
</code></pre>

<p>   });
});
{% endcodeblock %}</p>

<p>首先测试component的第一层——header，验证其type和className，然后通过children获取其下层组件<code>h1</code>和<code>TodoInput</code>，再对这2个组件进行校验。</p>

<p>接着测试TodoInput的onSave方法，它实际调用的是<code>handleSave</code>方法，方法会判断参数text的长度是否为0来决定是否调用actions的addTodo方法。</p>

<p>{% codeblock lang:js %}
it(&lsquo;should call addTodo if length of text is greater than 0&rsquo;, () => {
  const { output, props } = setup();
  const input = output.props.children[1];
  input.props.onSave(&lsquo;&rsquo;);
  expect(props.actions.addTodo.callCount).to.be.equal(0);
  input.props.onSave(&lsquo;Use Redux&rsquo;);
  expect(props.actions.addTodo.callCount).to.be.equal(1);
});
{% endcodeblock %}</p>

<p>这里使用sinon把action的addTodo方法mock掉了，然后再验证该方法是否有调用。</p>

<h2>React组件使用了CSS文件</h2>

<p>在写React的components时可能会加上自己定义的一些css文件（或者是less和sass等），这在mocha运行测试时会报错，报无法解析css语法的错误。我们可以通过编写自定义的mocha css编译器来解决这个问题。</p>

<p>{% codeblock css-null-compiler.js lang:js %}
function noop() {
  return null;
}</p>

<p>require.extensions[&lsquo;.styl&rsquo;] = noop;
// you can add whatever you wanna handle
require.extensions[&lsquo;.scss&rsquo;] = noop;
require.extensions[&lsquo;.css&rsquo;] = noop;
// ..etc
{% endcodeblock %}</p>

<p>然后在运行mocha时加上刚写的编译器：<code>mocha /your/test.spec.js --compilers css:css-null-compiler.js</code>。</p>

<h2>webpack使用了alias</h2>

<p>在使用webpack时我们会通过别名（alias）的方法来简化我们import其他文件时的路径，比如原来import时需要这样写：</p>

<p>{% codeblock css-null-compiler.js lang:js %}
import Header from &lsquo;../../src/components/Header&rsquo;;
{% endcodeblock %}</p>

<p>使用了alias之后可以这样：</p>

<p>{% codeblock css-null-compiler.js lang:js %}
import Header from &lsquo;src/components/Header&rsquo;;
{% endcodeblock %}</p>

<p>但是这种路径在测试的时候就会报找不到文件路径的错误，因为直接使用Mocha运行测试时并没有设置路径别名。</p>

<p>因此我们需要使用几个工具来解决这个问题，分别是<a href="https://www.npmjs.com/package/mock-require">mock-require</a>和<a href="https://www.npmjs.com/package/proxyquire">proxyquire</a>。</p>

<p>首先在mocha的before方法中通过mock-require来替换别名路径，然后在mocha的beforeEach中用proxyquire来调用被测试的module，具体代码如下：</p>

<p>{% codeblock css-null-compiler.js lang:js %}
import proxyquire from &lsquo;proxyquire&rsquo;;
import mockrequire from &lsquo;mock-require&rsquo;;</p>

<p>before(() => {
  // mock the alias path, point to the actual path
  mockrequire(&lsquo;actions/youractions&rsquo;, &lsquo;your/actual/action/path/from/your/test/file&rsquo;);
  // or mock with a function
  mockrequire(&lsquo;actions/youractions&rsquo;, {actionMethod: () => {&hellip;}));</p>

<p>let app;
beforeEach(() => {
  app = proxyquire(&lsquo;./app&rsquo;, {});
});</p>

<p>//test code
describe(&lsquo;xxx&rsquo;, () => {
  it(&lsquo;xxxx&rsquo;, () => {</p>

<pre><code>...
</code></pre>

<p>  });
});
{% endcodeblock %}</p>

<h2>React的组件中使用了DOM变量</h2>

<p>在做components测试时还会遇到一个问题，比如在某些组件中使用了DOM的一些全局变量，比如<code>window</code>，<code>document</code>等，这些只有在浏览器中才会有，而mocha测试我们是在命令行中执行的，并没有浏览器的这些变量。</p>

<p>要解决这个问题有2种方法，一种是使用<a href="http://karma-runner.github.io/0.13/index.html">Karma</a>来做单元测试。Karma是一个测试运行器，它会启动一个浏览器来运行测试，比较适合端到端的页面测试。但单元测试要使用浏览器来运行就显得有点浪费了，而且会影响测试的速度。</p>

<p>所以我们使用第二种方法，使用<a href="https://github.com/tmpvar/jsdom">jsdom</a>来模拟DOM结构，首先我们要创建一个js文件来模拟DOM。</p>

<p>{% codeblock dom.js lang:js %}
import jsdom from &lsquo;jsdom&rsquo;;
import mockrequire from &lsquo;mock-require&rsquo;;
// setup the simplest document possible
const doc = jsdom.jsdom(&lsquo;&lt;!doctype html><html><body></body></html>&rsquo;);
// get the window object out of the document
const win = doc.defaultView;
// set globals for mocha that make access to document and window feel
// natural in the test environment
global.document = doc;
global.window = win;
// from mocha-jsdom <a href="https://github.com/rstacruz/mocha-jsdom/blob/master/index.js#L80">https://github.com/rstacruz/mocha-jsdom/blob/master/index.js#L80</a>
function propagateToGlobal(window) {
  for (const key in window) {</p>

<pre><code>if (!window.hasOwnProperty(key)) continue;
if (key in global) continue;
global[key] = window[key];
</code></pre>

<p>  }
  window.matchMedia = window.matchMedia || function matchMedia() {</p>

<pre><code>return {
  matches: false,
  addListener: () =&gt; {},
  removeListener: () =&gt; {},
};
</code></pre>

<p>  };
}</p>

<p>propagateToGlobal(win);</p>

<p>{% endcodeblock %}</p>

<p>然后在<code>mocha.opts</code>文件中加入对这个文件的引用，<code>mocha.opts</code>文件是mocha的配置文件，一般放在test目录下面，通过配置该文件可以在调用mocha命令时少写一些参数。</p>

<p>{% codeblock dom.js lang:js %}
&mdash;require test/dom.js
&mdash;reporter dot
&mdash;ui bdd
{% endcodeblock %}</p>

<p>这样以后在运行mocha时就会自动加载<code>dom.js</code>文件了。</p>
]]></content>
  </entry>
  
</feed>
