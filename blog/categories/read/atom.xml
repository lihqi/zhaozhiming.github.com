<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: read | Hacker and Geeker's Way]]></title>
  <link href="http://zhaozhiming.github.io/blog/categories/read/atom.xml" rel="self"/>
  <link href="http://zhaozhiming.github.io/"/>
  <updated>2013-09-12T07:43:21+08:00</updated>
  <id>http://zhaozhiming.github.io/</id>
  <author>
    <name><![CDATA[赵芝明]]></name>
    <email><![CDATA[kingzzm1982@sina.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[facebook的工程师文化——《打造facebook》读后感]]></title>
    <link href="http://zhaozhiming.github.io/blog/2013/06/04/facebook-engineer-culture/"/>
    <updated>2013-06-04T07:36:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2013/06/04/facebook-engineer-culture</id>
    <content type="html"><![CDATA[<p>在今年北京的QCon大会上听了facebook早期中国籍工程师王淮的演讲，受益匪浅，主题是如何打造高效能团队，主要介绍他在facebook的一些经历和管理上的经验分享。现在的他是一名天使投资人，投资的领域有移动互联，支付，云应用等。他还写了《打造facebook》一书，讲了facebook的公司文化和他在其中的开发管理等经历。</p>

<h3>工具文化</h3>

<p>这本书给我印象最深的一点是facebook的"工具文化"。为帮助工程师更好的进行产品开发，facebook对内部工具Tools是非常关注的。facebook极力强调，要将最好的工程师放到工具开发这一块，因为工具做好了，可以达到事半功倍的效果，所有人的效率都可以提高，而不仅仅是工程师。还有通过工具来解决流程上面的问题，比如公司在推广一些规范性的规则，传统的方法是反复强调，另一种是开发出好用的工具，将这些东西固定在工具里面，借助工具进行强制性推广。不断的更新和完善公司自己的工具，并将公司的企业文化也融入到工具之中，有时候比找到一个伟大的创意更重要。</p>

<p>facebook研发的工具有很多，比如新人刚加入facebook时，需要分配自己的开发服务器，facebook就有一个工具来管理公司的开发机器。在这个工具上，你可以看到所有机器的详细信息，包括分配给什么人，什么时间分配的，机器的配置信息等。在还未申请的机器上面，只需要点击一个按钮就会帮你安装好开发服务器，非常方便和简单。对于我们开发人员来说工作主要是写代码，facebook针对代码管理业开发了很多工具。比如有一款工具是在开发人员提交代码之前对代码进行检查，如果代码不符合代码规范或者没有写测试案例，工具会发出警告并交给开发人员修改。还有一款code review的工具叫Phabricator，开发人员可以在上面针对每一行代码进行讨论，如果代码有问题，代码审查者可以提问题，或者让代码提交者修改等，只有代码明确接受后，才可以提交到服务器的代码库中。这些工具的理念是将重复性的劳动交给电脑来执行，以"Don&rsquo;t Make Me Think"的方式来推广好习惯。</p>

<h3>黑客文化</h3>

<p>facebook一直强调公司的黑客文化，总部基地建有"黑客广场"，公司内部随处可见的黑客标志，facebook还会定期举行黑客马拉松(Hackathon)。像Google 允许员工用工作时间的20%来做自己喜欢的东西一样，Hackathon也是facebook让员工保持创造力，避免工作枯燥而失去工作激情的一种方式，在这个过程中，也催生了很多伟大的作品，比如timeline(时间轴)，全屏照片视图等。参加Hackathon虽然是自愿的，但facebook强烈建议每个员工都去参加Hackahton，甚至有的工程师因为要安排产品上线而无法参加Hackathon，公司会调整产品的上线时间来让工程师去参加Hackathon。</p>

<p>facebook的CEO 扎克伯格本身就是一个黑客，看过《社交网络》的朋友都会记得电影开始的那一段场景，扎克伯格做了一个哈佛版美女评选网站（Facemash），为了得到更多女同学的照片，他黑进了当时学生宿舍里面每个学生的电脑去获取他们同学的照片。扎克伯格想打造独一无二的企业文化和管理方式，他将公司的这种文化称之为"黑客之道"(Hacker Wiay)，他诠释说，黑客文化是一种持续改进的做事方法，黑客迅速发布小规模的更新，然后从中获取到经验，在下一次更新中更好的改进，直到产品完成（有点敏捷开发的意思）。Done is better than prefect（完成胜于完美），这是facebook对这种黑客精神的诠释。</p>

<p>facebook的黑客文化还包括一种亲身实践，积极进取的精神。Code Wins Arguments（代码胜于雄辩），在facebook的产品开发过程中，经常会有一个工程师站出来说，给我2天的时间我做个demo出来，证明我的想法是可行的。facebook不会有那种长达几天的马拉松会议，工程师们会开发出产品原型来证明是否行得通，在facebook每个工程师都是顶尖的人才，他们具有这样一种快速开发的能力。</p>

<p>书中除了谈到上面所讲的这些点外，还谈到了作者在facebook中的项目管理经验，适合做项目管理的同学参考借鉴，最后希望大家也喜欢facebook的黑客文化。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[持续交付——发布可靠软件的系统方法]]></title>
    <link href="http://zhaozhiming.github.io/blog/2013/03/05/continuous-delivery/"/>
    <updated>2013-03-05T15:53:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2013/03/05/continuous-delivery</id>
    <content type="html"><![CDATA[<p>断断续续看完了《持续交付——发布可靠软件的系统方法》一书，中间有几次由于事情太忙而中断，直到今天才把书读完。书的内容很精彩，大致分持续集成，测试和部署三大块，还有介绍包括软件开发、项目管理等其他内容。我下面介绍几个我印象比较深刻的内容。</p>

<h3>预测试提交（pretested commit）</h3>

<p>简单来说，预测试提交就是在将代码提交到代码库之前，先在本地跑一遍持续集成上的操作，比如编译，单元测试等，保证提交的代码不会破坏基本的构建，然后再将代码提交到代码库。有一些持续集成的框架已经提供了这样的功能，可以在开发人员提交代码之后先执行基本构建，如果有问题，则通知开发人员且不会提交代码到代码库；如果没问题再提交代码到代码库，在CI上跑真正的构建。如下图所示：</p>

<p><img src="/images/04143846-935bd06aa7d74c8cba067610a4f2143a.gif">
<img src="/images/04143855-576fc9a7738e410d8de01ee7a9212723.gif"></p>

<p>这样的好处是，如果有人的提交了破坏构建的代码（比如编译不通过，单元测试失败等），没有预测试提交的话，只能等到破坏构建的人修复了代码后，其他人才能继续提交代码；而使用了预测试提交，破坏构建的提交根本不会提交到CI服务器上去，所以也就省去了等待其他人修复的时间了。</p>

<p>但是预测试提交只是做简单的本地构建，其他比较复杂的比如UAT测试，性能测试等，可能不会放到预测试提交中执行，因为如果要执行这些操作的话，开发人员在本地提交要等待的时间就会比较长，从而影响开发效率。</p>

<h3>部署流水线：一键部署，一键回退</h3>

<p>所谓的部署流水线，就是从提交代码开始，CI服务器进行代码编译、单元测试、验收测试，然后自动化部署，接着执行集成测试，UAT测试，性能（容量）测试等操作，一般是由多个CI任务来执行，每个CI任务都有上下游关系。比如，任务A执行代码编译，单元测试操作，任务B执行自动化部署操作，任务C执行集成测试，UAT测试等操作，这3个任务间的关系是：先执行任务A，执行完了再执行任务B，最后执行任务C，像生产流水线一样，组成了这样的一个部署流水线。最后产生的结果可能是一个完成了完整测试的一个产品交付物，或是将交付物部署到了生产环境上。</p>

<p>一般的持续集成只是在开发环境使用（像我目前所在的公司），而书中提到的部署流水线还包括了测试环境和类生产环境的部署。测试环境和类生产环境的部署不是由CI服务器自动触发的，而是有相关的操作人员（比如部署人员或者运营人员）通过点击相应的按钮来完成自动部署的操作，即一键化操作。这里的自动部署还可以选择产品交付物（ear、war或jar包）的某一个版本来进行部署，而不是简单的部署最新版本。</p>

<p>除了一键部署，还有一键回退。如果自动部署过程中有异常问题，或者是部署到指定环境后验证出现问题，操作人员可以通过点击相应按钮进行版本回退的操作，即一键回退。同样的，回退也可以选择相应要回退的交付物版本来进行回退，而不是简单的回退到上一个版本。</p>

<p>目前有一些CI工具已经支持了这些操作，比如ThoughtWorks的Go系统等。</p>

<h3>蓝绿发布，无停机发布</h3>

<p>无停机发布版本有很多种方法，这里只介绍蓝绿发布的方法。所谓的蓝绿发布，指的是系统的两个版本，蓝色的表示已经在生产上运行的版本，绿色表示即将发布的新版本。首先将两套版本的系统都启动起来，现有的用户请求连接的还是旧的蓝色版本，而新的绿色版本启动起来后，观察有没有启动的异常，或者其他一些异常，如果没有问题的话，再将现有的用户请求连接到新的绿色版本。对于用户来说，版本的切换是透明的，系统在发布过程中没有中断过。这样就达到了无停机发布的目的。</p>

<p>如果切换到新的绿色版本后，发现有故障或者异常，可以随时切换到旧的蓝色版本，这样同样可以达到无停机回滚的目的。但是要注意的是，在使用新的绿色版本过程中发现异常需要回滚，这时用户已经使用系统而产生了一些数据，这时候需要在回滚的同时，将数据同步到旧的蓝色版本环境中，或者根据判断是否放弃这些数据。也可以在绿色版本发布后，先用小众的用户做一些操作，如果发现没有问题，再将所有用户请求切换到绿色版本中来。</p>

<h3>坚持主干修改，不推荐分支操作</h3>

<p>在日常的开发中，经常会遇到这样一种情况。系统的一个版本即将发布生产，这个时候只能做一些测试工作和严重Bug的修复，而新的功能需求又需要继续开发，如果在现有的代码中继续修改的话，可能会影响新版本的发布。通常在这种情况下，很多开发团队会选择在版本控制管理器上拉一个分支出来，在新的分支上做新需求的开发，而在老的分支上做系统测试和bug修复，老的分支最终会发布到生产上。</p>

<p>首先说下这种做法有什么问题。新拉出来的分支最终是要合并到老的主干分支上去的，如果合并的间隔时间很长，到了合并代码的时候就会出现很多问题，甚至有些功能可能需要在老的分支上重新实现。第二个问题，新分支如何确保没有问题？如果已经有持续集成环境的话，对于新的分支就需要重新再搭建一套持续集成环境来跑每天提交的代码，增加了人力和资源的消耗。最终分支被合并到主干后，分支是要被废弃掉的，所以可以说分支的代码是一种开发上的浪费，即使它最终被合并到主干上。总的来说，分支操作跟持续集成是对立的，如果是只有一套持续集成环境，就必须频繁地合并分支代码到主干才不会有问题，但一般合并的时间都会比较长，因为要发布的主干代码要等到发布后才允许合并；如果有多套持续集成环境，又需要增加相关的人力去维护，等分支被合并到主干后，新增的持续集成环境也不需要了，这又是一种资源的浪费。</p>

<p>所以推荐的做法是坚持在主干上做修改，而不是拉分支。如何在主干上做大动作的修改，而又能确保不会破坏即将发布的功能，书上介绍了很多方法，包括“提取抽象层”、将大的修改分解成多而小的修改等，后者可以让每一次提交的小修改都可以通过持续集成上面的各种测试，从而保证主干上的功能不被破坏。这样做的好处是，你始终只需要维护一套代码，不需要做额外的合并工作，不会产生合并代码后的问题，而在持续集成上始终对主干代码进行构建，一旦有问题可以马上发现，缺陷发现的越早修复的成本也就越低。</p>

<h3>小结</h3>

<p>此书是TW公司的人出的，是很多战斗在一线的开发人员的经验总结，也是获得 jolt 大奖的书籍。有些内容比较深，需要有多年开发经验才好理解，正在实施敏捷或者持续集成的同学可以找来看看，一定会对你的工作有所帮助的，谢谢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[读《丰田生产方式》——联系敏捷开发的思考]]></title>
    <link href="http://zhaozhiming.github.io/blog/2012/08/06/read-toyota-product-method/"/>
    <updated>2012-08-06T10:16:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2012/08/06/read-toyota-product-method</id>
    <content type="html"><![CDATA[<p>平时工作和同事讨论敏捷，曾多次听到丰田的精益思想，说是很多敏捷的想法都是从丰田的精益思想中得来的，后来在Kent Beck的《解析极限编程》里看到有这样一本书是讲丰田的精益思想的，找来看了一下，发现书中讲的一些思想或者实践和敏捷开发很相似，下面我就讲讲我对于丰田生产方式和敏捷开发的一些联系。</p>

<h2>一、逆向思维，由生产的最后一道工序为起点，从后往前推进。</h2>

<p>丰田生产方式的两大支柱是准时化和自动化。准时化（Just In Time）是指通过流水作业装配一辆汽车的过程中，所需零部件在需要的时刻，以需要的数量，不多不少的送到生产线的旁边。如何达到这种不多不少的状态呢？丰田的做法是由生产的最后一道工序为起点，从后往前推进。这样以最后要生产的汽车数量，就可以推测所需的零部件各是多少，从而达到降低浪费的目的。</p>

<p>在敏捷开发中，我们如何做到准时化？从相关的敏捷实践来看，测试驱动开发（TDD）就是达到这一目的的过程。先从原始需求上面得到一个个的Story，Story规定了需求的入口和出口，然后再驱动出测试案例，最后由测试案例驱动出产品代码，这样就能保证产品代码的功能是包括了原始需求所要求的功能，但又避免产生过渡设计。这个也是减少浪费的一种过程。</p>

<h2>二、每个工人都有一根警报线，在生产过程中发现产品有问题，随时拉线让整个生产线停止，等待解决问题后再恢复生产。</h2>

<p>丰田生产方式的另外一个支柱是自动化。丰田使用了很多自动化机器，但自动化的标准不是简单的去使用机器，而是实现人的自动化。丰田几乎所有的机器设备都装有自动停止装置，平时机器自动运转的时候用不到人，如果生产过程中发现问题，人会去停止机器，然后修复问题，重新启动机器。如果在生产过程中发现问题没有及时停止生产，那就可能生产出大量的残次品，这些残次品无法装配到汽车上，是一种很大的浪费。</p>

<p>在敏捷开发中，持续集成体现的就是这种自动化思想。在持续集成的过程中，一旦发现问题（比如单元测试跑失败了），服务器就会马上停止构建，并通知相关的开发人员进行问题修复，等问题修复完成后，再重新进行构建。这样每当问题出现，我们就可以以最小的代价找到问题的根源，然后修复它。如果等问题遗留到后面的测试阶段或者生产阶段，再去找问题的根源，所需的代价就要大的多得多。</p>

<p>光有持续集成的服务器还不行，服务器不会自己去编译、测试、部署，所有这些行为都需要人去开发出相应的脚本，然后在服务器上运行，这就是所谓的“人的自动化”。开发人员应该将所有可以自动化的东西都做成自动化，让单元测试自动化，集成测试自动化，部署自动化，总之一个目的，减少浪费，这也是丰田生产一直追求的目标之一。</p>

<h2>三、看板</h2>

<p>看板在丰田生产中是一种工具，在生产中起到一个传递情报和指令的作用。</p>

<p>敏捷开发很好的运用了看板。有过敏捷开发经验的同学应该知道，敏捷中的看板就是整天摆在你跟前的那块白板，白板上将开发过程分成好几个阶段，每个阶段上面贴着该阶段下的开发任务，通过白板可以随时了解项目的进展。</p>

<h2>其他思想和实践</h2>

<p>除了和敏捷开发有这些联系外，丰田生产方式还有一些思想和实践适合软件开发。</p>

<h4>一人掌握多种技能，每个人都是多面手。</h4>

<p>由于历史和文化的原因，美国的的制度是，车工始终是车工，焊工永远是焊工；日本的制度是，工人既能操作车床，也能开钻床，而且能焊接，能够学会和掌握多种技能。</p>

<p>两种制度孰优孰劣很难确定，但个人认为，在软件开发高速发展的今天，开发人员应该要有更高的要求。开发人员所掌握的技能不仅仅是会编写产品代码，还要会写单元测试，会部署，会搭建环境等等。比如在缺少测试人员的情况下，开发人员可以自己测试，依靠开发的编程技能可以写出更好的测试代码。要能够快速学会和掌握多种技能。</p>

<h4>反复问5个为什么</h4>

<p>比如一台机器不转动了，你就要问：</p>

<ol>
<li>为什么机器停了？——“因为超负荷，保险丝断了。”</li>
<li>“为什么超负荷了呢？”——“因为轴承部分的润滑不够。"</li>
<li>&ldquo;为什么润滑不够？”——“因为润滑泵吸不上油来。”</li>
<li>“为什么吸不上油来呢？”——“因为油泵轴磨损，松动了。”</li>
<li>“为什么磨损了呢？”——因为没有安装过滤器，混进了铁屑。”</li>
</ol>


<p>通过问5个为什么就可以知道需要安装过滤器了。如果问题问的不彻底，可能是加上润滑油，或者换上油泵轴了事，这样等过了一段时间后问题还是会出现。丰田生产方式可以说是丰田人反复问5个为什么才创造出来的。</p>

<h4>拥抱小团队，不要大块头</h4>

<p>团队合作高于一切，由于合作或其他种种原因，人少的团队反而容易取胜。小船容易转舵，大船步履阑珊，小团队的灵活性更强，这也符合敏捷开发的原则——要做到简洁。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《Agile Web Development with Rails》读后感--rails基于web设计的best practices]]></title>
    <link href="http://zhaozhiming.github.io/blog/2012/08/05/best-practices-in-rails-with-web-app-design/"/>
    <updated>2012-08-05T18:18:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2012/08/05/best-practices-in-rails-with-web-app-design</id>
    <content type="html"><![CDATA[<p>最近看完《Agile Web Development with Rails》一书，受益匪浅。书中先是用一个简单的web应用带你进入Rails的世界，然后在你大致熟悉之后，再带你了解Rails的一些细节，比如ActiveRecord，ActiveController等。最让我觉得Rails美的是其中的一些best practices，这些都可以很好地借鉴到平时的开发中去。下面我简单举几个在Rails中我认为比较好的一些best practies。</p>

<h3>数据库迁移</h3>

<p>在Rails中，SQL脚本可以通过命令来生成，生成的脚本以时间戳加意图命名，比如创建表的SQL脚本文件可能是“20120529151027_create_products.rb"，加时间戳可以让人一眼就知道脚本的执行顺序，实际上Rails在也是根据时间戳来执行脚本的。创建完脚本后只要简单的执行"rake db:migrate"命令即可完成脚本的执行，在Rails中会有脚本执行的记录，已经执行过的脚本不会重复执行。另外，在每个SQL脚本中，不仅有执行的操作，还有回滚的操作。比如：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>demo.rb </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">AddPriceToLineItem</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="ss">ActiveRecord</span><span class="p">:</span><span class="ss">:Migration</span><span class="o">&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;pre&gt;&lt;code&gt;def self.up</span>
</span><span class='line'><span class="sr">　　add_column :line_items, :price, :decimal, :precision =&amp;gt; 8, :scale =&amp;gt; 2, :default =&amp;gt; 0</span>
</span><span class='line'>
</span><span class='line'><span class="sr">　　say_with_time &quot;Updating prices...&quot; do</span>
</span><span class='line'><span class="sr">  　　LineItem.find(:all).each do |lineitem|</span>
</span><span class='line'><span class="sr">    　　lineitem.update_attribute :price, lineitem.product.price</span>
</span><span class='line'><span class="sr">     end</span>
</span><span class='line'><span class="sr">　　end</span>
</span><span class='line'><span class="sr">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;</span><span class="sr">/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;  　end&lt;/</span><span class="nb">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">down</span>
</span><span class='line'><span class="err">　　</span><span class="n">remove_column</span> <span class="ss">:line_items</span><span class="p">,</span> <span class="ss">:price</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="o">&lt;</span><span class="sr">/code&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nb">p</span><span class="o">&gt;</span><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>这里的up方法是正常执行时的操作，down方法则是回滚时所做的操作。如果发现执行的脚本有问题，简单地执行“rake db:rollback"即可回退到脚本执行前的状态。</p>

<h3>Convention over Configuration</h3>

<p>在上面创建的脚本中可以看到，Rails的表名都是复数形式，因为Rails认为每张表都会存放很多个同一类型的数据，因此是复数，这种清晰的命名规范不仅体现在数据库，还有其他很多地方。比如，model的文件名都是单数形式存在，controller都是以复数形式存在。Rails将MVC各模块连接起来就是通过COC约定，举个简单例子，product的model文件是product.rb，controller文件是products_controller.rb，而view文件则是放在对应的product文件夹里面，每个view文件名以action方法名开头，这样在写代码的时候就可以不用具体指定要发送给哪个controller，给哪个model存储数据，让哪个页面显示数据，只要你遵守了COC约定，Rails会帮你跳转到最合适的地方。</p>

<h3>分层的页面布局</h3>

<p>在书中的例子，作者会建议你将页面分成一个个小的局部文件。实际上Rails也是推荐你这么做的，局部文件只需以下划线开头，Rails就会帮你识别出来。小的页面文件结构简单，容易维护，比如有显示列标题的页面，其中嵌套显示具体行内容的页面，其中再嵌套分页页面文件。对比平时在工作里遇到的一个个硕大无比的jsp文件，rails的页面文件让人有了进入世外桃源的感觉。</p>

<p>Rails还有其他很多的best practices，这里只是简单的介绍。Rails框架集中了很多开发中遇到的常见问题的解决方案，而且是一些最佳的解决方案，像集中了很多经验丰富的大师智慧一样，使用Rails并学习其中的best practices，能让你在web开发上少走很多弯路。</p>
]]></content>
  </entry>
  
</feed>
