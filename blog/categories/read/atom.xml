<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: read | Hacker and Geeker's Way]]></title>
  <link href="http://zhaozhiming.github.io/blog/categories/read/atom.xml" rel="self"/>
  <link href="http://zhaozhiming.github.io/"/>
  <updated>2017-01-10T20:58:43+08:00</updated>
  <id>http://zhaozhiming.github.io/</id>
  <author>
    <name><![CDATA[赵芝明]]></name>
    <email><![CDATA[kingzzm1982@sina.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[读书笔记——沸腾十五年，看板方法，精益创业]]></title>
    <link href="http://zhaozhiming.github.io/blog/2014/05/09/read-book-note-2014-4/"/>
    <updated>2014-05-09T06:43:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2014/05/09/read-book-note-2014-4</id>
    <content type="html"><![CDATA[<p><img src="/images/post/2014-5/april_book.jpg"></p>

<!--more-->


<p></p>

<h2>沸腾十五年</h2>

<p><img class="right" src="/images/post/2014-5/china-15-year.jpg"></p>

<p>沸腾十五年这本书介绍了中国互联网1995～2010这15年间，中国互联网公司从无到有，从小到大，各种兴衰成败的故事。</p>

<p>里面有一个比较好玩的段子，讲的是联众（大家应该都知道，就是以前做休闲游戏平台的，后来被腾讯无情超越）刚开始把游戏平台做出来的时候，用户非常少，经常找不到人可以开一桌麻将或者斗地主，用户等着等着不耐烦就走了。联众的几位创始开发看到这种情况急得不得了，本来上线的人就少，经过招呼亲朋好友卖广告什么的好不容易来了点人吧，还经常因为凑不到一桌游戏而让人给跑了。后来他们想了个办法，看到有上线的用户凑不到一桌开不了游戏的，就几个开发人员一起点进去陪用户玩，这样来把用户留住，甚至有的开发一人开了好几个账号同时陪用户玩游戏。靠着这种打不死的精神，后来联众就慢慢做大了。</p>

<p>看完书会让人热血沸腾，恨不得马上投身互联网浪潮，但仔细一想书中介绍的都是成功的互联网企业，在这些光彩夺目的互联网公司的光芒照耀下，让人看不到那些同期出生但又失败的互联网公司，这些公司的数量应该是成功者的N倍。我们要时刻充满激情来对待工作和生活，但在这个浮躁的社会也需要时刻保持一颗冷静的心。</p>

<h2>看板方法</h2>

<p><img class="right" src="/images/post/2014-5/kanban.jpg"></p>

<p>有幸参加了David Anderson关于看板方法的培训，回来后把看板方法的书认真研读了一遍，对其中的观点很是赞同。</p>

<h3>缩短范围</h3>

<p><code>在项目过程中需要舍弃一些东西进行权衡时，传统的项目经理会选择延期交付、增加资源投入、缩短范围或三者不同程度兼而有之;敏捷项目的明确共识是缩短范围，保障交付时间。</code><br/>
在有些东西要权衡时，为什么敏捷项目只选择缩短范围呢？<br/>
* 首先看如果选择延期交付会造成什么后果。由于你无法兑现之前的交付承诺，导致了与业务之间的不信任关系，业务无法相信你下次是否还能按时完成交付。<br/>
* 再看增加资源投入。在软件开发中，增加资源投入就意味着加人，但在《人月神话》里面已经说过了，<code>在一个已经延迟的项目里面增加人手，只会导致这个项目更加延迟</code>。<br/>
* 最后是缩短范围。缩小范围不是将业务的需求全部去掉，而是保留其中业务认为最主要的一部分，缩减业务认为优先级不是特别高的一部分，这样也可以让业务对需求有更清晰的认识。</p>

<p>项目的三要素：时间、金钱和质量，我觉得是三者是一个能量守恒的关系，如果提高其中的两项，那另外一项是要降低的，不可能三者同时提高。业务经常要求功能要多（金钱），上线时间要早（时间），传统项目迫于业务的压力，经常会选择降低质量（质量）来达到业务的前面两个要求，而敏捷项目首先会保持质量这一高标准，然后在保证按时交付的前提下，和业务PK交付的需求。</p>

<h3>降低变异性</h3>

<p>变异性是导致任务堆积，项目不能按时交付等的风险因素。降低变异性有如下好处：
* 降低变异性可以减少WIP，使得平均前置时间下降。
* 降低变异性能够减少对富余时间的需要（富余时间我理解就是预估工作量的buffer）。
* 降低变异性有利于实现资源平衡，潜在地降低对人数的需求。
什么地方可以体现变异性？<br/>
比如手工测试就存在变异性，手工测试会因为某些人为因素而认为测试是失败的，但实际上测试是成功的，结果就造成了开发过程中的浪费，乃至阻碍。可以通过自动化测试消除手工测试的变异性，自动化测试稳定而且准确。<br/>
还有比如在编写story的时候，如果story使用不同的方式来描述也会存在变异性，会让开发需要经常切换不同的思维或者角度去理解需求，出错率较高。可以通过编写一套团队认为合适的story模板来消除这种变异性。</p>

<h3>其他</h3>

<ul>
<li>敏捷开发中有很多对业务没有实际价值的成本，有这么几种：事务成本（搭建环境），协调成本（各种会议），破坏负载（软件缺陷）。敏捷中的会议是协调成本，以精益的角度来将要消除这种浪费。</li>
<li>虽然看板中强调前置时间少，交付速率高，但也不能以牺牲可预测性来换取这些指标。可预测在敏捷中很关键，可预测的交付会与用户建立信任关系，牺牲可预测性来提高短期的前置时间和交付速率是不可取的。</li>
</ul>


<h2>精益创业</h2>

<p><img class="right" src="/images/post/2014-5/lean.jpg"></p>

<h3>MVP(最小化可行产品)</h3>

<p>MVP是指一个最小化的可以获得用户反馈的产品，可以帮助创业者尽早开启学习认知的历程，它不一定是实实在在的产品，它是用最快的方式，以最少的精力完成'开发-测量-认知'的反馈循环。比如Dropbox在他们还未开发出产品之前，把一段幽默风趣的产品介绍视频作为他们的MVP放到网上，从而吸引了大量公测用户，为他们指明产品的正确方向。</p>

<h2>低质量</h2>

<p>质量低下的产品可能会造成重新返工、交付延期、用户的流失，每个做产品的人，包括设计、开发、测试，每个人都会以高质量为标准，在敏捷开发中更是要求产品质量必须是高标准，但坚持高质量的前提是我们已经知道产品的哪些功能是用户需要的，如果在用户需要的功能上偷工减料势必会造成用户流失。<br/>
但在创业的时候，很多东西都是未知的，用户不知道自己想要什么，创业者可能连哪些人是用户都不知道，在不知道产品有哪些功能的情况下，坚持产品质量的高标准就没有什么必要了。<br/>
创业阶段更需要是快速推出一个MVP产品，获得用户反馈，即使质量低下也未必不受用户欢迎。</p>

<h3>其他</h3>

<p>精益创业的常规工作是对比测试、持续部署和顾客测试，精益创业的技巧包括快速迭代/基于数据制定决策，以及早期顾客介入。</p>

<p>自己写的读书笔记不咋的，这里看到了另外一篇关于《精益创业》的读书笔记，非常完整地概括了这本书的观点，是前JavaEye的创始人范凯写的，点击<a href="http://robbinfan.com/blog/27/lean-startup">这里</a>查看。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[读书笔记——乔布斯，做最好的自己，共创式教练]]></title>
    <link href="http://zhaozhiming.github.io/blog/2014/03/13/read-book-note-2014-3/"/>
    <updated>2014-03-13T21:39:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2014/03/13/read-book-note-2014-3</id>
    <content type="html"><![CDATA[<p><img src="/images/post/2014-3/read_books.jpg"></p>

<p>这段时间出差比较频繁，出差无聊，就把之前想看的书看了，这里记一下读书笔记。</p>

<!--more-->


<p></p>

<h2>《乔布斯传》</h2>

<p><img class="right" src="/images/post/2014-3/Jobs.jpg"></p>

<p>《乔布斯传》这本书应该很多人都看过，这本书记录了乔布斯创奇的一生。苹果的两位创始人——乔布斯和技术天才史蒂芬.沃茨，我在之前听到的更多的是关于沃茨的声音，因为沃茨一直是开发人员眼中大师级的代表，身兼超强软件硬件开发能力于一身的神一般的人物。我之前一直以为乔帮主是沾了沃茨的光才成功的。但实际上是，如果没有乔布斯，沃茨开发的苹果电脑可能永远也不会被那么多人所知道。沃茨和乔布斯是完全的两类人，一个是技术天才，一个是设计天才。但乔布斯的对伟大产品的追求，让他更加成功。</p>

<p>前几天在网上看到对三星和苹果高管的专访，三星的高管们谈的大多是什么市场份额、市场占有率，而现苹果几位高管谈的却是产品设计，比如这个东西的边框为什么要设计成这样，这个角度为什么要设计成圆弧等等。因为乔布斯一直就是这样给公司灌输理念的——做伟大的产品，做出改变世界的伟大产品。书里面有个有趣的故事，在乔布斯得癌症住院期间，他看到医生拿给他戴的氧气罩，觉得设计非常丑陋，用他的话来说就是“一坨屎”，坚决要求医生拿出多款氧气罩让他选择，最后还给氧气罩的设计提出了自己的建议，完全不顾自己是一个身患绝症的病人。</p>

<p>从乔布斯传里面还学到“专注”。乔布斯每年都会带领一班人去到一个与世隔绝的地方，在那里大家展开头脑风暴，对公司明年的发展提出各种观点，大家从里面选出十个最好的点子，写到白板上，然后乔布斯拿起笔划掉后面七个，说明年我们只做这三件事情。乔布斯回归苹果后，立即着手砍掉公司一些不赚钱的业务，让公司专注在开发新的Mac电脑上，使得苹果公司起死回生，慢慢走向了世界顶级企业之路。一个人的精力是有限的，如果什么都想学，什么都想做，那势必什么都学不精，什么都做不好。</p>

<p>乔布斯的伟大之处还在于其创造了“封闭一体化”的产品设计。与软件开发者崇尚的开源思想截然相反的一种设计理念，但是在乔布斯的掌控下却产生了一个又一个伟大的产品。这与乔布斯强大的控制欲有关，为了得到完美的用户体验，对端到端的控制是一个有效的办法。用户不需要知道产品里面的结构和原理，因为产品已经设计得足够简单，让你一上手就会使用。这种“封闭一体化”的设计也渐渐被业界青睐，Google等企业最近也在纷纷效仿。但乔布斯一辈子的对手——比尔盖茨说，这种封闭一体化设计，只有乔布斯可以成功。</p>

<h2>《做最好的自己》</h2>

<p><img class="right" src="/images/post/2014-3/be_best_yourself.jpg"></p>

<p>李开复老师的一本激励人心的书，为广大中国大学生的未来之路提供了宝贵的建议。开复老师在书中讲了很多做人做事的方法和建议，并引用自己亲身经历的事迹来论证自己的观点，让人在学到这些道理的同时又对开复老师的人生经历多了一些了解。</p>

<p>开复老师也是一名技术很牛的开发人员，他自创了通过统计学进行语音识别技术的开发，使得识别率达到了96%，这是一个后人难以企及的高度，这也让他得到了苹果公司的青睐。在苹果公司工作的期间，他的建议让公司走向了数字媒体的发展方向，可惜在他任职期间，刚好是乔布斯离开苹果的那段时间，后来乔布斯极力想邀请他重回苹果，但开复老师的心已经放在中国大学生上面，从而没有答应请求。后来开复老师到了微软，一手创建了微软中国研究院，培养了一大批高素质的技术人才。”follow my heart"，是开复老师离开微软加入Google时说的话，Google当时面对中国对手——百度强有力的竞争，需要一位深谙东西方文化，德高望重的人物做中国区总裁，他是当时Google的最佳人选。加入Google后，由于受微软诉讼的限制，开复老师只能负责招聘方面的工作，但这正是他心中的理想工作，他又为Google输送和培养了大批优质的毕业生，这些人才的培养可能会使Google中国短时间内落后百度的研发速度，但对于Google的长期发展是非常有利的。</p>

<p>我最喜欢书中讲的一个故事，分享一下。
<blockquote><p>年轻人问智者：智慧从哪里来？<br/>智者：正确的判断。<br/>年轻人问：正确的判断从哪里来？<br/>智者：经验。<br/>年轻人问：从哪里来？<br/>智者：错误的判断。</p></blockquote></p>

<p>最后祝开复老师早日康复。</p>

<h2>《共创式教练》</h2>

<p><img class="right" src="/images/post/2014-3/Coach.jpg"></p>

<p>《共创式教练》指导如何成为一个既能帮助客户解决问题，帮助客户成长，又能和客户共同一起成长的教练，也是最近出差学习的内容之一。</p>

<p>共创式教练相信每个人都是可以自己解决问题的，每个人都是有资源的，教练不是给客户解决方案，而是通过各种技能技巧让用户知道如何自己解决问题，并在解决问题的过程中得到成长，同时教练和客户一起成长。</p>

<p>共创式教练的三大原则：自我实现，自觉选择，活在当下。这些原则的目的就是帮助客户提高潜能自己解决问题。另外还有各种比较有用的技巧，比如“强有力的问题”，“好奇心”，“聆听”，“直觉”等。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《黑客》读书笔记]]></title>
    <link href="http://zhaozhiming.github.io/blog/2014/02/10/make-harker-booke-note/"/>
    <updated>2014-02-10T21:41:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2014/02/10/make-harker-booke-note</id>
    <content type="html"><![CDATA[<p><img src="/images/post/hacker.jpg"></p>

<h2>简介</h2>

<p>《黑客》这本书介绍的是上世纪50～80年代的一段计算机历史，介绍第一代黑客的起源，第二代硬件黑客对世界的影响，第三代游戏黑客如何让电脑融入大众生活，类似“魔戒三部曲”一样宏伟的一部计算机编年史。</p>

<!--more-->


<p></p>

<h2>黑客的起源</h2>

<p>MIT AI实验室第九大楼是黑客的发源地，"hack"一词大概最早就是由MIT的学生提出的，原来是用来形容本校学生的一些精心策划的恶作剧，但AI实验室的黑客们对"hack"却有着极大的尊敬。一般一项技艺能称为"hack"，它必须有创新，有风格，有技术含量，AI实验室里面效率最高的人就非常骄傲的称自己为"hacker"。</p>

<h2>黑客马拉松</h2>

<p>熟悉Facebook的人对黑客马拉松都会有所了解，Facebook每年都会举办几场黑客马拉松编程比赛，在这些比赛中也诞生了很多伟大的产品，在《黑客》这本书里面讲到这一活动的早期雏形。在上个世纪50年代，个人电脑还没有普及，在MIT学校里面接触电脑的那一帮最早的黑客只能通过大型机编程。但是大型机就那么几台，所以喜欢编程的黑客们的上机时间非常有限，一般是一个人刚上完机，另外一个人就迫不及待地顶替他的位置编写自己的代码，甚至有些黑客觉得白天上机的时间不够，会晚上偷偷溜进实验室继续编程。虽然现在个人电脑已经很普遍了，但黑客们还是很喜欢这种长时间编程活动。</p>

<h2>黑客道德与敏捷开发</h2>

<p>敏捷开发中有什么？有快速迭代，代码所有制，团队自组织，了解敏捷开发的同学对此都比较清楚，而黑客道德里面也有一些很相似的共同点，我因此觉得黑客道德是敏捷开发的原型。</p>

<h4>信息应该免费</h4>

<p>黑客普遍认为信息应该免费共享（为什么说普遍？因为比尔盖茨不是这样认为的，他认为软件也是脑力劳动的成果，所有人应该尊重劳动成果，所以他写了那一封很著名的信——<a href="http://en.wikipedia.org/wiki/Open_Letter_to_Hobbyists">给电脑爱好者的公开信</a>），他们认为计算机（包括软件和硬件）应该公开其中的黑盒，让所有人参与到其中的开发并对其进行完善，这样计算机才能取得更大的进步。敏捷开发中的代码所有制与此观点相同，认为团队中的代码不应该为个人所有，应该所有人都有权对代码进行修改。</p>

<h4>快速开发产品原型</h4>

<p>在Facebook崇尚的黑客之道中，就有<code>Done is better than Perfect</code>的说法，就是说一开始不要追求产品的完美，先做出产品的原型得到市场的反馈，再慢慢根据反馈来完善产品。黑客们一直以来也是这样做的，遇到感兴趣的问题不会想太多，做了再说，快速把核心功能开发出来验证自己的想法，很多伟大的产品都源自于此。敏捷开发中的快速迭代也是类似的原理，甚至最近比较火的精益创业也是此种观点。</p>

<h4>对权威挑战</h4>

<p>黑客希望信息共享，能快速开发产品，对开发的效率要求是十分严格，他们对工具的追求像对完美艺术追求一样。但大部分权威机构的产品都不能满足黑客们的要求，它们笨重、不开放、设计保守。黑客们更倾向于自己开发工具，自给自足，然后开放给其他黑客一起使用，大家一起完善。这是一种对权威的挑战、蔑视，黑客与生俱来的叛逆精神。</p>

<h4>优雅简洁的代码</h4>

<p>在还是大型机的时代，电脑的内存和容量非常小，黑客在编程的时候需要让自己的代码尽可能的少，这样才能“塞进”机器里面运行。比如实现某个功能，如果某人只是按部就班的实现这个功能，大家可能会觉得他只是靠蛮力解决了问题，勉强算是一个程序员，但如果他使用了一种奇妙的算法，让代码量大大减少了，那么大家会觉得他是一个黑客，是一位追求完美的艺术家，比如比尔盖茨编写的4KB大小的BASIC程序就经常为黑客们所津津乐道。敏捷开发中对代码的重构推崇有加，介绍重构的资料最经典的是Martin.Flower<a href="http://book.douban.com/subject/1229923/">重构</a>一书，技术背后的思想我觉得跟这些早期黑客是一致的，要像艺术家一样对待自己的代码，追求优雅和完美，是一种对自我的超越。有个说法是，如果你看自己以前的代码觉得很烂，证明你已经进步了，看自己代码的时间间隔越短，证明你进步的越快，比如上午写完的代码，下午review时觉得太糟糕了，那恭喜你，你已经进步了。</p>

<h2>防御性编程</h2>

<p>最后说一下防御性编程，比较有意思。以前有一位外号叫“嘎吱船长”的黑客约翰.德拉浦，他是位天才的技术家，他喜欢的编程风格就是“防御式编程”。大部分人在修复bug时，一般都会找到出错的代码，然后改正它，而船长的改法比较特别，不修改出错的代码，而是加上另外一段代码来让程序自己发现问题后自己修复。比如下面的一段有错误的代码：<br/>
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">def</span> <span class="nf">method_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>    <span class="n">x</span> <span class="o">=</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">2</span>
</span><span class='line'>    <span class="nb">sum</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</span><span class='line'>    <span class="k">if</span> <span class="nb">sum</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
</span><span class='line'>        <span class="c"># do something</span>
</span><span class='line'>        <span class="o">...</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div><br/>
正常人会这样改：
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">def</span> <span class="nf">method_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>    <span class="n">x</span> <span class="o">=</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">2</span>
</span><span class='line'>    <span class="nb">sum</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</span><span class='line'>    <span class="k">if</span> <span class="nb">sum</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span> <span class="c">#一般会改这里</span>
</span><span class='line'>        <span class="c"># do something</span>
</span><span class='line'>        <span class="o">...</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div><br/>
但是船长是这样来修复：
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">def</span> <span class="nf">method_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>    <span class="n">x</span> <span class="o">=</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">2</span>
</span><span class='line'>    <span class="nb">sum</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</span><span class='line'>
</span><span class='line'>    <span class="c">#在这里加代码...  </span>
</span><span class='line'>    <span class="k">if</span> <span class="nb">sum</span> <span class="o">!=</span> <span class="mi">5</span><span class="p">:</span>
</span><span class='line'>        <span class="nb">sum</span> <span class="o">=</span> <span class="mi">5</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="nb">sum</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
</span><span class='line'>        <span class="c"># do something</span>
</span><span class='line'>        <span class="o">...</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div><br/>
让程序完成自我救赎~~~^_^</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[facebook的工程师文化——《打造facebook》读后感]]></title>
    <link href="http://zhaozhiming.github.io/blog/2013/06/04/facebook-engineer-culture/"/>
    <updated>2013-06-04T07:36:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2013/06/04/facebook-engineer-culture</id>
    <content type="html"><![CDATA[<p>在今年北京的QCon大会上听了facebook早期中国籍工程师王淮的演讲，受益匪浅，主题是如何打造高效能团队，主要介绍他在facebook的一些经历和管理上的经验分享。现在的他是一名天使投资人，投资的领域有移动互联，支付，云应用等。他还写了《打造facebook》一书，讲了facebook的公司文化和他在其中的开发管理等经历。</p>

<!--more-->


<p></p>

<h3>工具文化</h3>

<p>这本书给我印象最深的一点是facebook的"工具文化"。为帮助工程师更好的进行产品开发，facebook对内部工具Tools是非常关注的。facebook极力强调，要将最好的工程师放到工具开发这一块，因为工具做好了，可以达到事半功倍的效果，所有人的效率都可以提高，而不仅仅是工程师。还有通过工具来解决流程上面的问题，比如公司在推广一些规范性的规则，传统的方法是反复强调，另一种是开发出好用的工具，将这些东西固定在工具里面，借助工具进行强制性推广。不断的更新和完善公司自己的工具，并将公司的企业文化也融入到工具之中，有时候比找到一个伟大的创意更重要。</p>

<p>facebook研发的工具有很多，比如新人刚加入facebook时，需要分配自己的开发服务器，facebook就有一个工具来管理公司的开发机器。在这个工具上，你可以看到所有机器的详细信息，包括分配给什么人，什么时间分配的，机器的配置信息等。在还未申请的机器上面，只需要点击一个按钮就会帮你安装好开发服务器，非常方便和简单。对于我们开发人员来说工作主要是写代码，facebook针对代码管理业开发了很多工具。比如有一款工具是在开发人员提交代码之前对代码进行检查，如果代码不符合代码规范或者没有写测试案例，工具会发出警告并交给开发人员修改。还有一款code review的工具叫Phabricator，开发人员可以在上面针对每一行代码进行讨论，如果代码有问题，代码审查者可以提问题，或者让代码提交者修改等，只有代码明确接受后，才可以提交到服务器的代码库中。这些工具的理念是将重复性的劳动交给电脑来执行，以"Don&rsquo;t Make Me Think"的方式来推广好习惯。</p>

<h3>黑客文化</h3>

<p>facebook一直强调公司的黑客文化，总部基地建有"黑客广场"，公司内部随处可见的黑客标志，facebook还会定期举行黑客马拉松(Hackathon)。像Google 允许员工用工作时间的20%来做自己喜欢的东西一样，Hackathon也是facebook让员工保持创造力，避免工作枯燥而失去工作激情的一种方式，在这个过程中，也催生了很多伟大的作品，比如timeline(时间轴)，全屏照片视图等。参加Hackathon虽然是自愿的，但facebook强烈建议每个员工都去参加Hackahton，甚至有的工程师因为要安排产品上线而无法参加Hackathon，公司会调整产品的上线时间来让工程师去参加Hackathon。</p>

<p>facebook的CEO 扎克伯格本身就是一个黑客，看过《社交网络》的朋友都会记得电影开始的那一段场景，扎克伯格做了一个哈佛版美女评选网站（Facemash），为了得到更多女同学的照片，他黑进了当时学生宿舍里面每个学生的电脑去获取他们同学的照片。扎克伯格想打造独一无二的企业文化和管理方式，他将公司的这种文化称之为"黑客之道"(Hacker Wiay)，他诠释说，黑客文化是一种持续改进的做事方法，黑客迅速发布小规模的更新，然后从中获取到经验，在下一次更新中更好的改进，直到产品完成（有点敏捷开发的意思）。Done is better than prefect（完成胜于完美），这是facebook对这种黑客精神的诠释。</p>

<p>facebook的黑客文化还包括一种亲身实践，积极进取的精神。Code Wins Arguments（代码胜于雄辩），在facebook的产品开发过程中，经常会有一个工程师站出来说，给我2天的时间我做个demo出来，证明我的想法是可行的。facebook不会有那种长达几天的马拉松会议，工程师们会开发出产品原型来证明是否行得通，在facebook每个工程师都是顶尖的人才，他们具有这样一种快速开发的能力。</p>

<p>书中除了谈到上面所讲的这些点外，还谈到了作者在facebook中的项目管理经验，适合做项目管理的同学参考借鉴，最后希望大家也喜欢facebook的黑客文化。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[持续交付——发布可靠软件的系统方法]]></title>
    <link href="http://zhaozhiming.github.io/blog/2013/03/05/continuous-delivery/"/>
    <updated>2013-03-05T15:53:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2013/03/05/continuous-delivery</id>
    <content type="html"><![CDATA[<p>断断续续看完了《持续交付——发布可靠软件的系统方法》一书，中间有几次由于事情太忙而中断，直到今天才把书读完。书的内容很精彩，大致分持续集成，测试和部署三大块，还有介绍包括软件开发、项目管理等其他内容。我下面介绍几个我印象比较深刻的内容。</p>

<!--more-->


<p></p>

<h3>预测试提交（pretested commit）</h3>

<p>简单来说，预测试提交就是在将代码提交到代码库之前，先在本地跑一遍持续集成上的操作，比如编译，单元测试等，保证提交的代码不会破坏基本的构建，然后再将代码提交到代码库。有一些持续集成的框架已经提供了这样的功能，可以在开发人员提交代码之后先执行基本构建，如果有问题，则通知开发人员且不会提交代码到代码库；如果没问题再提交代码到代码库，在CI上跑真正的构建。如下图所示：</p>

<p><img src="/images/post/04143846-935bd06aa7d74c8cba067610a4f2143a.gif">
<img src="/images/post/04143855-576fc9a7738e410d8de01ee7a9212723.gif"></p>

<p>这样的好处是，如果有人的提交了破坏构建的代码（比如编译不通过，单元测试失败等），没有预测试提交的话，只能等到破坏构建的人修复了代码后，其他人才能继续提交代码；而使用了预测试提交，破坏构建的提交根本不会提交到CI服务器上去，所以也就省去了等待其他人修复的时间了。</p>

<p>但是预测试提交只是做简单的本地构建，其他比较复杂的比如UAT测试，性能测试等，可能不会放到预测试提交中执行，因为如果要执行这些操作的话，开发人员在本地提交要等待的时间就会比较长，从而影响开发效率。</p>

<h3>部署流水线：一键部署，一键回退</h3>

<p>所谓的部署流水线，就是从提交代码开始，CI服务器进行代码编译、单元测试、验收测试，然后自动化部署，接着执行集成测试，UAT测试，性能（容量）测试等操作，一般是由多个CI任务来执行，每个CI任务都有上下游关系。比如，任务A执行代码编译，单元测试操作，任务B执行自动化部署操作，任务C执行集成测试，UAT测试等操作，这3个任务间的关系是：先执行任务A，执行完了再执行任务B，最后执行任务C，像生产流水线一样，组成了这样的一个部署流水线。最后产生的结果可能是一个完成了完整测试的一个产品交付物，或是将交付物部署到了生产环境上。</p>

<p>一般的持续集成只是在开发环境使用（像我目前所在的公司），而书中提到的部署流水线还包括了测试环境和类生产环境的部署。测试环境和类生产环境的部署不是由CI服务器自动触发的，而是有相关的操作人员（比如部署人员或者运营人员）通过点击相应的按钮来完成自动部署的操作，即一键化操作。这里的自动部署还可以选择产品交付物（ear、war或jar包）的某一个版本来进行部署，而不是简单的部署最新版本。</p>

<p>除了一键部署，还有一键回退。如果自动部署过程中有异常问题，或者是部署到指定环境后验证出现问题，操作人员可以通过点击相应按钮进行版本回退的操作，即一键回退。同样的，回退也可以选择相应要回退的交付物版本来进行回退，而不是简单的回退到上一个版本。</p>

<p>目前有一些CI工具已经支持了这些操作，比如ThoughtWorks的Go系统等。</p>

<h3>蓝绿发布，无停机发布</h3>

<p>无停机发布版本有很多种方法，这里只介绍蓝绿发布的方法。所谓的蓝绿发布，指的是系统的两个版本，蓝色的表示已经在生产上运行的版本，绿色表示即将发布的新版本。首先将两套版本的系统都启动起来，现有的用户请求连接的还是旧的蓝色版本，而新的绿色版本启动起来后，观察有没有启动的异常，或者其他一些异常，如果没有问题的话，再将现有的用户请求连接到新的绿色版本。对于用户来说，版本的切换是透明的，系统在发布过程中没有中断过。这样就达到了无停机发布的目的。</p>

<p>如果切换到新的绿色版本后，发现有故障或者异常，可以随时切换到旧的蓝色版本，这样同样可以达到无停机回滚的目的。但是要注意的是，在使用新的绿色版本过程中发现异常需要回滚，这时用户已经使用系统而产生了一些数据，这时候需要在回滚的同时，将数据同步到旧的蓝色版本环境中，或者根据判断是否放弃这些数据。也可以在绿色版本发布后，先用小众的用户做一些操作，如果发现没有问题，再将所有用户请求切换到绿色版本中来。</p>

<h3>坚持主干修改，不推荐分支操作</h3>

<p>在日常的开发中，经常会遇到这样一种情况。系统的一个版本即将发布生产，这个时候只能做一些测试工作和严重Bug的修复，而新的功能需求又需要继续开发，如果在现有的代码中继续修改的话，可能会影响新版本的发布。通常在这种情况下，很多开发团队会选择在版本控制管理器上拉一个分支出来，在新的分支上做新需求的开发，而在老的分支上做系统测试和bug修复，老的分支最终会发布到生产上。</p>

<p>首先说下这种做法有什么问题。新拉出来的分支最终是要合并到老的主干分支上去的，如果合并的间隔时间很长，到了合并代码的时候就会出现很多问题，甚至有些功能可能需要在老的分支上重新实现。第二个问题，新分支如何确保没有问题？如果已经有持续集成环境的话，对于新的分支就需要重新再搭建一套持续集成环境来跑每天提交的代码，增加了人力和资源的消耗。最终分支被合并到主干后，分支是要被废弃掉的，所以可以说分支的代码是一种开发上的浪费，即使它最终被合并到主干上。总的来说，分支操作跟持续集成是对立的，如果是只有一套持续集成环境，就必须频繁地合并分支代码到主干才不会有问题，但一般合并的时间都会比较长，因为要发布的主干代码要等到发布后才允许合并；如果有多套持续集成环境，又需要增加相关的人力去维护，等分支被合并到主干后，新增的持续集成环境也不需要了，这又是一种资源的浪费。</p>

<p>所以推荐的做法是坚持在主干上做修改，而不是拉分支。如何在主干上做大动作的修改，而又能确保不会破坏即将发布的功能，书上介绍了很多方法，包括“提取抽象层”、将大的修改分解成多而小的修改等，后者可以让每一次提交的小修改都可以通过持续集成上面的各种测试，从而保证主干上的功能不被破坏。这样做的好处是，你始终只需要维护一套代码，不需要做额外的合并工作，不会产生合并代码后的问题，而在持续集成上始终对主干代码进行构建，一旦有问题可以马上发现，缺陷发现的越早修复的成本也就越低。</p>

<h3>小结</h3>

<p>此书是TW公司的人出的，是很多战斗在一线的开发人员的经验总结，也是获得 jolt 大奖的书籍。有些内容比较深，需要有多年开发经验才好理解，正在实施敏捷或者持续集成的同学可以找来看看，一定会对你的工作有所帮助的，谢谢。</p>
]]></content>
  </entry>
  
</feed>
