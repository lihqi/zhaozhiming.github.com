<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: code | Hacker and Geeker's Way]]></title>
  <link href="http://zhaozhiming.github.io/blog/categories/code/atom.xml" rel="self"/>
  <link href="http://zhaozhiming.github.io/"/>
  <updated>2017-10-10T21:05:43+08:00</updated>
  <id>http://zhaozhiming.github.io/</id>
  <author>
    <name><![CDATA[赵芝明]]></name>
    <email><![CDATA[kingzzm1982@sina.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[研发人员面试指南（二）]]></title>
    <link href="http://zhaozhiming.github.io/blog/2017/09/23/some-tips-of-employers-interview-part2/"/>
    <updated>2017-09-23T19:33:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2017/09/23/some-tips-of-employers-interview-part2</id>
    <content type="html"><![CDATA[<p><img src="/images/post/2017/09/interview2.png" width="400" height="300"></p>

<p>除了面试流程，研发面试环节最关键的还是技术面试环节，这个环节要确认面试者的技术基本功是否扎实，以及技术的深度和广度，与公司部门的技术栈是否匹配等等。</p>

<!--more-->


<p></p>

<h2>技能考察</h2>

<p>面试过程中除了通过项目了解应聘者外，还需要通过一些技术问题来了解应聘者的真实能力。</p>

<h3>技术基础</h3>

<p>这里以前端岗位为例，技术基础就是JS、CSS和HTML。这方面的问题网上都有很多人做过总结，所以尽量不要问一些烂大街的问题，可以结合平时工作遇到的问题来进行提问，或者内部团队专门设计一些巧妙的面试问题来考验应聘者。</p>

<p>技术问题可以结合公司的技术栈提问，比如公司用的<code>React</code>和<code>Nodejs</code>，就可以问一些这方面相关的问题。</p>

<h3>手写代码</h3>

<p>很多人讨厌 Google 公司的“白板面试”环节，我觉得讨厌的原因主要是要让应聘者手写二叉树查询算法这种太过困难的任务，在很多实际项目开发中很少涉及到复杂算法，更不要说手写了。<br/>
但是我觉得考察应聘者手写代码的能力还是有必要的，特别是没有笔试环节的情况下。可以出一道简单的编程题目，让应聘者通过编写实际代码或者伪代码来解答，主要考察的是编程思路，代码编写规范等。<br/>
有些应聘者在自己的项目上说的头头是道，但是一旦要实际写代码却困难重重，这个时候就要质疑应聘者的实际能力了，如果是天天和代码打交道的人是不会写不出代码的。</p>

<h3>项目管理（可选）</h3>

<p>如果面试的岗位需要带团队做项目，就可以提问一些项目管理相关的问题。可以从以下方面了解：</p>

<ul>
<li>如何把控项目进度</li>
<li>如何保证项目质量</li>
<li>如何汇报项目进展</li>
<li>如何让新人快速融入团队</li>
<li>等等</li>
</ul>


<h3>代码质量</h3>

<p>优秀的研发人员对代码是有要求甚至是有洁癖的，可以从以下方面了解：</p>

<ul>
<li>有没有做过code review？有的话是怎么做的？一般会对哪些代码提出建议？</li>
<li>最不能忍受的代码是什么样的？</li>
<li>项目中有没有做自动化代码检查？（比如前端的话是否有用Lint类的工具）</li>
<li>有没有写过单元测试？平时单元测试用的框架是什么？好的单元测试一般是什么样的？</li>
<li>等等</li>
</ul>


<h3>过程控制</h3>

<p>效率高的研发人员会对软件开发的流程有一定的了解和关注，并且有自己的一套方法方式，可以从以下方面了解：</p>

<ul>
<li>什么是持续集成和持续部署？平时在项目开发中是怎么做的？</li>
<li>平时项目中的持续集成一般会做一些什么事情？</li>
<li>对敏捷开发是否了解？平时的开发流程是怎么样的？</li>
<li>拿到开发任务后有没有对任务进行拆解？有的话是如何拆分任务的？</li>
<li>等等</li>
</ul>


<h3>学习和分享</h3>

<p>爱分享的研发人员一般能力不会差，可以从以下方面了解：</p>

<ul>
<li>最近了解到的最新技术是哪些？</li>
<li>平时是通过什么渠道了解技术资讯的？</li>
<li>是否经常写博客？</li>
<li>是否参与开源项目？</li>
<li>等等</li>
</ul>


<h3>其他方面</h3>

<p>最后可以从其他方面了解应聘者的综合能力，可以从以下方面了解：</p>

<ul>
<li>感兴趣的技术方向（看是否与公司部门的技术方向匹配）</li>
<li>文档能力（具备良好的文档编写能力绝对是加分项）</li>
<li>沟通能力（是主动沟通还是被动沟通）</li>
<li>抗压能力（面对压力时如何应对）</li>
<li>等等</li>
</ul>


<h2>总结</h2>

<p>仅凭一次面试就想真正了解一个人是很难的，但通过以上方面可以把握一些正确的选人方向，后面再继续讨论面试过程应该注意的一些事项，以及如何提高面试的效率，敬请期待。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[研发人员面试指南（一）]]></title>
    <link href="http://zhaozhiming.github.io/blog/2017/09/23/some-tips-of-employers-interview-part1/"/>
    <updated>2017-09-23T19:33:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2017/09/23/some-tips-of-employers-interview-part1</id>
    <content type="html"><![CDATA[<p><img src="/images/post/2017/09/interview.jpg" width="400" height="300"></p>

<p>面试研发人员，如果面试过程处理地不好，不仅招不到合适的人，而且会给应聘者带来不好的体验，从而影响公司的整体形象。最近整理了一些面试官的经验，写出来和大家分享一下。</p>

<!--more-->


<h1>面试流程</h1>

<p>如果把面试比作软件开发，那面试流程就是系统架构，只有把架构设计好了，你才知道面试过程中的每一步要怎么走，才能更好地把握面试的节奏。</p>

<h2>自我介绍</h2>

<p>这里的自我介绍是指双方的自我介绍。</p>

<h3>面试官</h3>

<p>首先作为面试官，出于礼貌应该先介绍自己，可以介绍自己的<code>名字</code>和<code>职务</code>，并说明这次的面试是流程中的哪个环节（初试、复试或其他），这也是一个礼貌且友好的开场。</p>

<h3>简要问题</h3>

<p>介绍完自己后可以简单地问下应聘者的重要信息，这些信息可以帮助你快速判断这个人是否值得招聘，还可以了解到招募的可能性和招聘所需的代价等信息。</p>

<p>对于社招岗位，可以了解以下方面：</p>

<ul>
<li>是否在职？</li>
<li>在职的话要找工作的原因是什么？</li>
<li>离职的话离职原因是什么？</li>
</ul>


<p>对于实习岗位，可以了解以下方面：</p>

<ul>
<li>是大学 / 研究生几年级？</li>
<li>一周可以实习几天？</li>
<li>学习开发（前端）多长时间？</li>
</ul>


<h3>应聘者</h3>

<p>接着请应聘者开始做自我介绍，同时保持倾听。<br/>
注意这时候不要光顾看简历而不听应聘者讲话，提前了解简历内容是面试前就应该做的事情，而且一般应聘者讲的内容都会比简历上写的更详细。</p>

<h2>项目介绍</h2>

<p>应聘者在做完自我介绍后，如果对他的某个项目感兴趣，可以让他再详细讲下这个项目，比如：</p>

<ul>
<li>项目团队有多少人？</li>
<li>他在这个项目中主要负责什么工作？</li>
<li>在项目期间遇到过什么印象比较深刻的问题？</li>
<li>这些问题是如何解决的？</li>
<li>等等</li>
</ul>


<p>如果没有感兴趣的项目，也可以让应聘者挑一个他自己觉得印象深刻的项目来讲。</p>

<h2>让应聘者提问</h2>

<p>在流程的最后，在这个时候面试官已经问了一堆问题了，对应聘者也有一定了解，但应聘者对招聘方还不够了解，这时候需要给应聘者一个机会来进行了解，就是让应聘者提问问题，面试官进行解答。</p>

<p>如果是技术面试，而应聘者问道了薪酬或者福利相关的问题你又不方便回答，可以礼貌地回应说<code>这方面的信息后面 HR 会和你聊</code>。</p>

<p>这一环节结束后，就可以根据面试情况，看是安排应聘者进行复试呢，还是让应聘者先行回去。如果让应聘者先回去，需要告之多久时间（一般是一个星期）内会回复他。</p>

<p>最后把面试结果告诉 HR，整个面试过程结束。</p>

<p>上面介绍的是面试的一个通用流程，在下一篇文章会介绍面试的关键环节——技术考察，敬请期待。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何安全地使用 React 的 context]]></title>
    <link href="http://zhaozhiming.github.io/blog/2017/02/19/how-to-safely-use-react-context-zh-cn/"/>
    <updated>2017-02-19T19:38:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2017/02/19/how-to-safely-use-react-context-zh-cn</id>
    <content type="html"><![CDATA[<p><img src="/images/post/2017/02/react-context.jpeg"></p>

<p>在自己的 React 项目中使用了大量的 context，虽然知道这是一个不推荐使用的特性，但还是用了很多，想看看别人是怎么使用 context，所以翻译了下面这篇文章，注意文章中引用了嵌套的twitter内容，所以访问时最好是翻墙访问，以免影响阅读。</p>

<!--more-->


<h2>如何安全地使用 React 的 context</h2>

<p>Context 是 React 里面一个有着很多免费声明的、非常强大的特性，就像乐园里面的禁果一样。</p>

<p><img class="<a" src="href="https://cdn-images-1.medium.com/max/1600/1*rbUZNOyFC64KmJaRhF2Kww.png">https://cdn-images-1.medium.com/max/1600/1*rbUZNOyFC64KmJaRhF2Kww.png</a>"></p>

<p>这应该可以让你远离 context 了对吧？当然不是，它虽然是一个被禁用的 React 特性，但它的存在是一个不争的事实！context 可以把数据传递给组件树底层的组件，无需中间组件的参与。context 的经典用法是定制主题，本地化和路由这些方面。</p>

<p><a href="https://medium.com/@dan_abramov">Dan Abramov</a> 设计了一些明智的规则让你知道什么时候不该使用 context：</p>

<p><img class="<a" src="href="https://cdn-images-1.medium.com/max/1600/1*b6Ev2SZ8SBlqhKVrOGDZaA.jpeg">https://cdn-images-1.medium.com/max/1600/1*b6Ev2SZ8SBlqhKVrOGDZaA.jpeg</a>"></p>

<p>现在你可能已经按照这个明智的建议来做，但同时，使用一些使用了 context 的库，比如 <a href="https://github.com/ReactTraining/react-router">react-router</a>，当它和其他库像 <a href="https://github.com/reactjs/react-redux">react-redux</a> 或 <a href="https://github.com/mobxjs/mobx-react">mbox-react</a>组合时，甚至是和你自己的 shouldeComponentUpdate，又或者是由 React.PureComponent 提供的这个方法组合时，都仍然可能让你有陷入困境。长期存在的<a href="https://github.com/facebook/react/issues/2517">问题</a> 可以在 React 或 React 相关的第三方库的问题跟踪列中找到。</p>

<blockquote class="twitter-tweet" data-lang="zh-cn"><p lang="en" dir="ltr">Redux implements sCU, making setState + context break, forces &quot;subscribe&quot; on everybody else. Seems like React needs a generic solution.</p>&mdash; Ryan Florence (@ryanflorence) <a href="https://twitter.com/ryanflorence/status/779320581678174208">2016 年 9 月 23 日</a></blockquote>


<script async src="http://zhaozhiming.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>所以，为什么这篇博客跟你有关？这是因为：</p>

<ul>
<li>你是一个库的作者</li>
<li>你使用的库使用了 context，或者你自己使用 context，然后你想安全地使用 shouldComponentUpdate (SCU)，或者一些基于此的已有实现（比如 PureComponent, Redux 的 connect, 或者 MobX 的 observer）。</li>
</ul>


<h3>为什么 Context + ShouldComponentUpdate 有问题？</h3>

<p>Context 用来和嵌套很深的组件交流，例如，一个根组件定义了一个主题，然后这个组件树中的任何组件可能（也可能不）对这个信息感兴趣，就像<a href="https://facebook.github.io/react/docs/context.html#passing-info-automatically-through-a-tree">官方的 context 示例</a>。</p>

<p>shouldComponentUpdate (SCU) 另一方面在重新渲染组件树（包括子组件）的一部分中起到短路作用，例如如果 props 或者组件的 state 没有被明确的修改，组件就不会重新渲染，但这可能意外中断 context 的传播。</p>

<blockquote class="twitter-tweet" data-lang="zh-cn"><p lang="en" dir="ltr"><a href="https://twitter.com/dan_abramov">@dan_abramov</a> <a href="https://twitter.com/iammerrick">@iammerrick</a> <a href="https://twitter.com/ryanflorence">@ryanflorence</a> specifically, anything that uses context will break. Seems unfair to the rest of us :(</p>&mdash; MICHAEL JACKSON (@mjackson) <a href="https://twitter.com/mjackson/status/779329979741904896">2016 年 9 月 23 日</a></blockquote>


<p></p>

<script async src="http://zhaozhiming.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p></p>

<blockquote class="twitter-tweet" data-lang="zh-cn"><p lang="en" dir="ltr"><a href="https://twitter.com/mjackson">@mjackson</a> <a href="https://twitter.com/iammerrick">@iammerrick</a> <a href="https://twitter.com/ryanflorence">@ryanflorence</a> The thing here is that React Redux doesn’t rely on context updating correctly. It knows React is broken.</p>&mdash; Dan Abramov (@dan_abramov) <a href="https://twitter.com/dan_abramov/status/779335426377183232">2016 年 9 月 23 日</a></blockquote>


<script async src="http://zhaozhiming.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>让我们通过一个简单的 app 来模拟这个有冲突的问题：</p>

<script async src="http://zhaozhiming.github.io//jsfiddle.net/mweststrate/3ay25feh/embed/"></script>


<p>在 context 和 SCU 中产生问题的地方显而易见，当你按了“Red please!”按钮（在“Result”栏上面）时，按钮本身的颜色刷新了，但待办列表没有被更新。原因很简单，我们的 TodoList 组件是智能的，它知道当它没有接收到新的待办子项它就不需要重新渲染（最聪明的地方是继承了 PureCompnent，其重新实现了 shouldComponentUpdate方法）。</p>

<p>尽管如此，正因为这个最智能的地方（指继承了 PureCompnent，这个在大型应用是非常有必要的，因为它可以提供更好的性能），让 TodoList 中的 ThemedText 组件没有接收到更新了颜色的新 context！因为不管是 TodoList 或它的后代更新了，SCU 都返回 false。</p>

<p><img class="<a" src="href="https://cdn-images-1.medium.com/max/1600/1*pnkWX7uEzCeY-7r5Ii_Y-A.png">https://cdn-images-1.medium.com/max/1600/1*pnkWX7uEzCeY-7r5Ii_Y-A.png</a>"></p>

<p>更糟的是，我们不能在 TodoList 中手工修改 SCU，因为它是固定了的一个方法。因为 SCU 不能接收相关的 context 数据（颜色），它不能（也不该）被订阅到指定的context数据中，毕竟它本身不是一个theme-aware的组件。</p>

<p>总的来说，shouldComponentUpdate 返回 false 导致任何 context 更新不再传播到子组件中去，非常糟不是吗？我们可以修复这个问题吗？</p>

<h3>ShouldComponentUpdate 和 Context 可以一起工作！</h3>

<p>你注意到了问题只发生在我们更新 context 的时候吗？这个是解决问题的关键所在，只要确保你一直不更新 context就可以了，换句话说：</p>

<ul>
<li>Context 不应该改变，它应该不可变</li>
<li>组件应该在其构造时只接收 context 一次</li>
</ul>


<p><blockquote><p>或者，为了使其不同，我们不应该直接把 state 保存到 context 中，取而代之，我们应该像依赖注入系统一样使用 conext。</p></blockquote></p>

<p>这意味着 SCU 不再干涉 context 需要传什么，因为不再需要传递新的 context 给子组件。棒极了！这解决了我们所有问题！</p>

<h3>通过基于 context 的依赖注入来和变更进行交流</h3>

<p>如果我们想要改变主题颜色，很简单，我们在适当的地方有一个依赖注入系统（DI），所以我们可以向下传递一个仓库来管理我们的主题并订阅它，我们绝不会传递一个新的仓库，但要确保仓库本身是有状态的，并且可以观察到组件的变化：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">// Theme 组件存储当前的主题状态，并允许组件订阅将来变化（的数据）</span>
</span><span class='line'><span class="kr">class</span> <span class="nx">Theme</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">constructor</span><span class="p">(</span><span class="nx">color</span><span class="p">)</span> <span class="p">{</span><span class="o">&lt;</span><span class="err">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">pre</span><span class="o">&gt;&lt;</span><span class="nx">code</span><span class="o">&gt;</span><span class="k">this</span><span class="p">.</span><span class="nx">color</span> <span class="o">=</span> <span class="nx">color</span>
</span><span class='line'><span class="k">this</span><span class="p">.</span><span class="nx">subscriptions</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class='line'><span class="o">&lt;</span><span class="err">/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span>  <span class="p">}</span><span class="o">&lt;</span><span class="err">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span>  <span class="nx">setColor</span><span class="p">(</span><span class="nx">color</span><span class="p">)</span> <span class="p">{</span><span class="o">&lt;</span><span class="err">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">pre</span><span class="o">&gt;&lt;</span><span class="nx">code</span><span class="o">&gt;</span><span class="k">this</span><span class="p">.</span><span class="nx">color</span> <span class="o">=</span> <span class="nx">color</span>
</span><span class='line'><span class="k">this</span><span class="p">.</span><span class="nx">subscriptions</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">f</span> <span class="o">=&amp;</span><span class="nx">gt</span><span class="p">;</span> <span class="nx">f</span><span class="p">())</span>
</span><span class='line'><span class="o">&lt;</span><span class="err">/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span>  <span class="p">}</span><span class="o">&lt;</span><span class="err">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span>  <span class="nx">subscribe</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span><span class="o">&lt;</span><span class="err">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">pre</span><span class="o">&gt;&lt;</span><span class="nx">code</span><span class="o">&gt;</span><span class="k">this</span><span class="p">.</span><span class="nx">subscriptions</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
</span><span class='line'><span class="o">&lt;</span><span class="err">/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;</span><span class="err">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="kr">class</span> <span class="nx">ThemeProvider</span> <span class="kr">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">constructor</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span> <span class="p">{</span><span class="o">&lt;</span><span class="err">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">pre</span><span class="o">&gt;&lt;</span><span class="nx">code</span><span class="o">&gt;</span><span class="kr">super</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
</span><span class='line'><span class="c1">// 主题提供者在它的整个生命周期中使用同样的主题对象</span>
</span><span class='line'><span class="k">this</span><span class="p">.</span><span class="nx">theme</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Theme</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">color</span><span class="p">)</span>
</span><span class='line'><span class="o">&lt;</span><span class="err">/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span>  <span class="p">}</span><span class="o">&lt;</span><span class="err">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span>  <span class="c1">// 必要时更新主题，更新的内容会传播给订阅的主键</span>
</span><span class='line'>  <span class="nx">componentWillReceiveProps</span><span class="p">(</span><span class="nx">next</span><span class="p">)</span> <span class="p">{</span><span class="o">&lt;</span><span class="err">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">pre</span><span class="o">&gt;&lt;</span><span class="nx">code</span><span class="o">&gt;</span><span class="k">this</span><span class="p">.</span><span class="nx">theme</span><span class="p">.</span><span class="nx">setColor</span><span class="p">(</span><span class="nx">next</span><span class="p">.</span><span class="nx">color</span><span class="p">)</span>
</span><span class='line'><span class="o">&lt;</span><span class="err">/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span>  <span class="p">}</span><span class="o">&lt;</span><span class="err">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span>  <span class="nx">getChildContext</span><span class="p">()</span> <span class="p">{</span><span class="o">&lt;</span><span class="err">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">pre</span><span class="o">&gt;&lt;</span><span class="nx">code</span><span class="o">&gt;</span><span class="k">return</span> <span class="p">{</span><span class="nx">theme</span><span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">theme</span><span class="p">}</span>
</span><span class='line'><span class="o">&lt;</span><span class="err">/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span>  <span class="p">}</span><span class="o">&lt;</span><span class="err">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span>  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span><span class="o">&lt;</span><span class="err">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">pre</span><span class="o">&gt;&lt;</span><span class="nx">code</span><span class="o">&gt;</span><span class="k">return</span> <span class="o">&amp;</span><span class="nx">lt</span><span class="p">;</span><span class="nx">div</span><span class="o">&amp;</span><span class="nx">gt</span><span class="p">;{</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">children</span><span class="p">}</span><span class="o">&amp;</span><span class="nx">lt</span><span class="p">;</span><span class="err">/div&amp;gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="err">/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nx">ThemeProvider</span><span class="p">.</span><span class="nx">childContextTypes</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">theme</span><span class="o">:</span> <span class="nx">React</span><span class="p">.</span><span class="nx">PropTypes</span><span class="p">.</span><span class="nx">object</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;</span><span class="err">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="kr">class</span> <span class="nx">ThemedText</span> <span class="kr">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">componentDidMount</span><span class="p">()</span> <span class="p">{</span><span class="o">&lt;</span><span class="err">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">pre</span><span class="o">&gt;&lt;</span><span class="nx">code</span><span class="o">&gt;</span><span class="c1">// 订阅未来改变的主题</span>
</span><span class='line'><span class="k">this</span><span class="p">.</span><span class="nx">context</span><span class="p">.</span><span class="nx">theme</span><span class="p">.</span><span class="nx">subscribe</span><span class="p">(()</span> <span class="o">=&amp;</span><span class="nx">gt</span><span class="p">;</span> <span class="k">this</span><span class="p">.</span><span class="nx">forceUpdate</span><span class="p">())</span>
</span><span class='line'><span class="o">&lt;</span><span class="err">/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span>  <span class="p">}</span>
</span><span class='line'>  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span><span class="o">&lt;</span><span class="err">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">pre</span><span class="o">&gt;&lt;</span><span class="nx">code</span><span class="o">&gt;</span><span class="k">return</span> <span class="o">&amp;</span><span class="nx">lt</span><span class="p">;</span><span class="nx">div</span> <span class="nx">style</span><span class="o">=&amp;</span><span class="nx">gt</span><span class="p">;</span>
</span><span class='line'>  <span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">children</span><span class="p">}</span>
</span><span class='line'><span class="o">&amp;</span><span class="nx">lt</span><span class="p">;</span><span class="err">/div&amp;gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="err">/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nx">ThemedText</span><span class="p">.</span><span class="nx">contextTypes</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">theme</span><span class="o">:</span> <span class="nx">React</span><span class="p">.</span><span class="nx">PropTypes</span><span class="p">.</span><span class="nx">object</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>完整的可运行列表：</p>

<script async src="http://zhaozhiming.github.io//jsfiddle.net/mweststrate/pc327358/embed/"></script>


<p>注意到在这个示例里面颜色的改变已经正确了，但它仍然使用 PureComponent，而且重要组件 TodoList 和 ThemedText 的 API 并没有改变。</p>

<p>虽然我们的 ThemeProvider 的实现变得更复杂了，它创建了一个Theme 对象来保持了我们主题的状态，Theme对象同时也是一个事件发射器，这可以让像 ThemeText 一样的组件来订阅未来的变化，Theme 对象通过 ThemeProvider 在组件树中传递。context 仍然是用来做这个的，但只有刚开始的时候传递了 context，后面的更新都通过 Theme 自己来传播，并没有重新创建一个 context。</p>

<p><img class="<a" src="href="https://cdn-images-1.medium.com/max/1600/1*ul_3UcymigXysL-JzgF8dQ.png">https://cdn-images-1.medium.com/max/1600/1*ul_3UcymigXysL-JzgF8dQ.png</a>"></p>

<p>这个实现有点过于简单，更好的实现方式是需要在 componentWillUnmount 中清理事件监听器，并且应该使用 setState 来代替 forceUpdate，但好消息是你关注的内容已经有第三方库在开发了，它不会影响库的使用者，以后中间组件意外的 shouldComponentUpdate 实现将不再破坏库的行为。</p>

<h3>总结</h3>

<p>通过依赖注入系统而不是状态的容器来限制使用 context，我们可以同时构造基于 context 的库和正确行为的 shouldComponentUpdate，而不会被干涉和破坏消费者的 API，还有非常重要的一点是，在当前受限的 React context 系统中可以正常工作，只要你遵守这条简单的规则：</p>

<p><blockquote><p>Context 在每个组件中应该只被接收一次。</p></blockquote></p>

<blockquote class="twitter-tweet" data-lang="zh-cn"><p lang="en" dir="ltr"><a href="https://twitter.com/ryanflorence">@ryanflorence</a> <a href="https://twitter.com/mweststrate">@mweststrate</a> <a href="https://twitter.com/dan_abramov">@dan_abramov</a> <a href="https://twitter.com/sebmarkbage">@sebmarkbage</a> huh. i never thought of context as a &quot;dependency&quot; before. i guess it is.</p>&mdash; MICHAEL JACKSON (@mjackson) <a href="https://twitter.com/mjackson/status/779375007579287552">2016 年 9 月 23 日</a></blockquote>


<script async src="http://zhaozhiming.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>最后的提醒：context 仍然是实验性的特性，你应该避免直接使用 context（看上面 Dan Abramov 的规则），作为代替使用抽象过的 context 库（看下面的一些例子），但如果你是一个库的作者，或者如果你在写一些很好的高阶组件来处理 context，坚持上面的解决方案将避免一些令人讨厌的意外。</p>

<p><strong>更新于 2016-9-29：</strong> <a href="https://medium.com/@ryanflorence">Ryan Florence</a> 刚发布了一个通用包，包含了上面讲的这个模式，所以你可以不用自己写这些代码了 <a href="https://github.com/ReactTraining/react-context-emission">react-context-emission</a>。</p>

<h3>奖励：使用 MobX observables 作为 context 来简化事情</h3>

<p>（如果你在使用或对 MobX 感兴趣那你对这一章也会感兴趣）</p>

<p>如果你使用 MobX，你完全可以跳过整个事件触发器这个东西，并且作为替代在 context 中使用仓库 observables，并通过使用 observer decorator 或高阶组件来订阅他们，这使得你不必自己管理数据的订阅。</p>

<script async src="http://zhaozhiming.github.io//jsfiddle.net/mweststrate/xpw6a5Ld/embed/"></script>


<p>实际上，更简单的方法是使用 MobX 中的 <a href="https://github.com/mobxjs/mobx-react#provider-and-inject">Provider / inject</a> 的机制，它是对 React conext 机制的一个抽象化后的结果。它移除了 contextTypes 声明和类似其他东西的代码，注意这个类似的概念可以在一些库比如 <a href="https://github.com/acdlite/recompose/blob/master/docs/API.md#withcontext">recompose</a> 或 <a href="https://github.com/gnoff/react-tunnel">react-tunnel</a> 中找到。</p>

<script async src="http://zhaozhiming.github.io//jsfiddle.net/mweststrate/b537yvcj/embed/"></script>


<p>它是很值得尝试的，注意看，虽然我们初始基于依赖注入解决方案的代码量是原始代码的 1.5 倍，但最终的解决方案的代码和原来有问题的实现方案代码一样多。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[让你的 SQL 脚本自动升级]]></title>
    <link href="http://zhaozhiming.github.io/blog/2016/07/17/make-your-sql-script-auto-upgrade/"/>
    <updated>2016-07-17T17:12:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2016/07/17/make-your-sql-script-auto-upgrade</id>
    <content type="html"><![CDATA[<p><img src="/images/post/2016/07/sql_upgrade.png" width="400" height="300"></p>

<p>以前的公司在部署 SQL 脚本的时候比较麻烦，需要写一份部署文档，上面写了这次部署需要执行的 SQL 脚本，然后由部署人员人工来执行这些脚本。现在发现一种比较简便的方法，可以让系统自己检查要执行哪些 SQL 脚本然后执行，减少了人力成本并提高了效率。</p>

<!--more-->


<h2>背景</h2>

<p>项目使用 <a href="https://www.sqlite.org/">sqlite</a> 来存储数据，因为还没上生产环境，开发人员在升级数据表结构时都是删掉数据库文件然后重新生成，这种方法一旦在生产环境执行的话就会将生产数据全部清除，所以需要使用增量升级数据库的方法来维护数据库。</p>

<h2>设计</h2>

<p>因为程序员都比较懒，加上又没有专职的部署人员，所以我们决定写个程序来让我们的数据库自动增量更新。大概的思路是这样的：</p>

<p><strong>在数据库中和系统文件中各记录一个版本号，系统启动时对比这 2 个版本号，如果数据库版本号小于等于系统文件版本号，则循环执行<code>数据库版本号 + 1</code>的脚本，每循环一次数据库版本号递增 1，直到数据库版本号大于系统文件版本号</strong></p>

<h2>步骤</h2>

<p>上面是概要设计，下面是具体的步骤：</p>

<ul>
<li>在数据库中记录一个版本号，然后在系统文件（比如<code>package.json</code>）也记录一个版本号</li>
<li>数据库版本号初始值为 0，系统文件版本号为部署 SQL 脚本的次数，比如还没执行过任何 SQL 脚本值为 0，执行了 1 次值为 1</li>
<li>系统启动时对比这 2 个版本号，如果数据库版本号小于等于系统文件版本号，则开始循环执行 SQL 脚本</li>
<li>每一次循环根据不同的版本号执行不同的 SQL 脚本，然后将数据库版本号值加 1</li>
<li>当数据库版本号大于系统文件版本号时，退出循环</li>
</ul>


<h2>流程</h2>

<p><img src="/images/post/2016/07/flow_chart.png"></p>

<h2>结论</h2>

<p>这样实现后，以后如果有新的 SQL 脚本改动，只需要修改相应循环里面代码，增加新版本的 SQL 脚本的 if 分支，然后把系统文件版本加 1 即可，系统启动就会自动执行了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[开发团队里是否需要测试人员？]]></title>
    <link href="http://zhaozhiming.github.io/blog/2016/06/12/do-we-need-tester-in-our-team/"/>
    <updated>2016-06-12T20:06:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2016/06/12/do-we-need-tester-in-our-team</id>
    <content type="html"><![CDATA[<p><img src="/images/post/2016/06/qa.png" width="400" height="300"></p>

<p>最近在看“<a href="https://book.douban.com/subject/4163938">软件随想录</a>”，里面有个非常有名的“<a href="http://www.joelonsoftware.com/articles/fog0000000043.html">乔尔测试</a>”，其中有一个问题是“你的团队里面是否有测试人员”，如果有的话就加分，表明团队对产品质量比较重视。</p>

<p>但是在现在的软件开发团队中是否真的需要测试人员呢？</p>

<!--more-->


<p></p>

<h2>如何替代测试人员的工作</h2>

<p>我们先来看一下测试人员的工作是什么？测试人员的工作是尽可能的找出bug，然后提交给开发人员进行修复。如果团队里面没有测试人员，开发人员要如何找bug呢？</p>

<p>首先我们来看测试人员做的最多的测试——功能测试，对于功能测试我们有什么办法可以来替代呢？</p>

<h4>单元测试</h4>

<p>单元测试是开发人员找出代码中潜在bug的自我救赎行为，相比手工测试功能，开发人员一般更倾向于写代码来测试功能代码，即所谓的单元测试。只要能想到相应的测试案例，就能写出单元测试，可以测试包括正常，异常，分支，边界等情况下的问题。</p>

<h4>集成测试</h4>

<p>单元测试虽然可以找到一些bug，但还不能完全替代测试人员的工作，单元测试只能测试细粒度级别的功能，比如某个方法的功能，如果需要对几个功能点一起测试的话，单元测试就满足不了了。但没有关系，开发同样可以用代码来写测试，这种粒度稍大的测试就是集成测试，比如测试一个后端的api，验证输入参数和输出结果，这个api的真正功能可能是后端调用数据库等一系列的操作，你一个测试方法就可以把这个api的各个功能点串起来一起验证。</p>

<h4>UI测试</h4>

<p>还有粒度更大的测试，一个页面上的按钮的点击可以看成是UI测试，相对于集成测试，这个测试的范围涉及了前端和后端，测试包括验证前端的页面是否正确，到点击按钮后触发的后端功能是否正确。现在市面上有很多端到端的测试框架，涵盖各种语言和浏览器。</p>

<h4>性能测试</h4>

<p>除了功能测试，测试人员还会做一些性能测试，同样地，开发可以通过代码或者脚本来调用性能测试工具来对系统进行性能测试。</p>

<h4>持续集成</h4>

<p>如果不想像测试人员一样每天做重复性的劳动，就可以将以上那些测试代码放到持续集成上面，让机器帮你运行，想象一下，几百上千个测试，如果手工跑的话可能要花不止一天的时间，而通过持续集成，可能在一天就能跑完好几轮所有测试。</p>

<h2>不能替代的测试工作</h2>

<p>如果我们做到了以上这些，是否就可以完全代替测试人员了呢？其实有些测试是机器无法测试的，比如网页的样式，机器只能判断是否有显示，但无法判断显示的是否好看。还有一些交互效果，也只有通过人工才能识别效果是否正确，还有其他各个领域的测试，目前是不能通过代码或者机器来替代的。</p>

<h2>高级测试工程师</h2>

<p>可能有人会说上面提到的用代码来执行测试的工作，高级测试工程师也能做。其实我觉得软件开发和软件测试到了越高的位置，技能重合的领域就越大，两者都同时会写代码，做测试，可能还会部署，会运维，这个时候我觉得不如就叫高级工程师好了，或者全栈工程师。</p>

<h2>结论</h2>

<p>说了这么多，所以结论是什么呢？</p>

<p>具体情况要具体分析，不能一概而论说完全不需要测试人员，团队不需要测试人员的条件是：</p>

<ul>
<li>团队的开发人员可以写的单元测试，集成测试和UI测试</li>
<li>没有太多需要人工测试的功能，比如团队开发的是常规的web系统或者纯后端应用等</li>
</ul>

]]></content>
  </entry>
  
</feed>
