<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: code | Hacker and Geeker's Way]]></title>
  <link href="http://zhaozhiming.github.io/blog/categories/code/atom.xml" rel="self"/>
  <link href="http://zhaozhiming.github.io/"/>
  <updated>2015-12-20T21:02:37+08:00</updated>
  <id>http://zhaozhiming.github.io/</id>
  <author>
    <name><![CDATA[赵芝明]]></name>
    <email><![CDATA[kingzzm1982@sina.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[开发人员神秘的工具箱]]></title>
    <link href="http://zhaozhiming.github.io/blog/2015/09/21/the-mysterious-tools-of-developer/"/>
    <updated>2015-09-21T10:06:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2015/09/21/the-mysterious-tools-of-developer</id>
    <content type="html"><![CDATA[<p>{% img /images/post/2015-9/toolbox.jpeg 400 300 %}</p>

<p>需求、时间和质量是项目管理的三个平衡点，如果需求多、开发时间短必将会导致项目质量下降，那开发人员有什么办法在短时间内交付大量的需求（虽然质量低）呢？其实每个开发人员都有一套“神秘”的工具箱，在万不得已的时候就会开始使用它（这部分内容是以前参加<a href="https://www.linkedin.com/in/dteng">Daniel</a>的CSM课程的时候听到的，觉得很有意思，想和大家分享一下）。</p>

<!--more-->


<p></p>

<p>{% blockquote 火云邪神 %}
天下武功，唯快不破
{% endblockquote %}</p>

<h2>复制粘贴</h2>

<p>最常见的就是复制粘贴了，天下文章一大抄，何况代码了，把以前可以工作的代码拷贝过来，改改就可以用了，甚至改都不改一下就直接上线也是可以的。别人敲了半天的代码我按2次按键就搞定了，这就是效率！</p>

<p>别跟我说神马重复代码导致改一处地方要变成改多处地方，修改还容易遗漏这些balbal，我们听多了，Who care，明天的事情明天再说，现在最要紧的是赶紧把功能做出来上线，不然奖金泡汤你负责啊？</p>

<h2>在网上搜索代码然后拷过来直接用</h2>

<p>每当我没有灵感的时候，我都会上网搜一下有没有实现我想要的功能的代码，发现了的话就拷贝粘贴到我的代码里面，呵呵我的工作就算完成了。</p>

<p>你说什么？！不弄清楚代码原理直接用危险大？别人的代码不一定适用于我的工程？拜托，我弄清楚那些代码原理的时间，我都可以自己写一个实现了好吗？跟你说了现在最要紧的是上线，别跟我扯这些没用的！另外我用百度搜代码，那速度杠杠的，谁用谁知道啊，现在谁还费那么大劲翻墙访问google啊？！</p>

<h2>功能变成Bug</h2>

<p>上面2招都不好使了肿么办，系统明天就要上线了，功能完不成老板又要找我麻烦了。。。机智的我还是想到了办法，我轻轻地在键盘上敲下了实现该功能的方法名，然后。。。就完了，我已经把功能实现了，可以上线了。</p>

<p>什么？上线后发现啥功能都没有？额。。。我看看。。。哦，这里有个<strong>BUG</strong>，等下个版本一起修复吧！懂了吗？现在这里不是一个未完成的功能，而是一个<strong>BUG</strong>了，呵呵这种办法还不是一般人能想的出来的。</p>

<h2>没有测试</h2>

<p>测试？现在连睡觉的时间都没有，还要我做测试？Are you kidding me？这些东西交给用户不就可以了吗？用户是什么，不就是我们的小白鼠嘛呵呵。</p>

<p>单元测试是什么鬼？用代码来测试代码？我看你吃撑了吧？我写了一堆的代码实现了功能，然后还要写同样多的一堆代码来测试我原来那堆代码，但老板并没有给我双倍工资来做这个事情啊，所以还是省省吧！</p>

<h2>没有代码评审</h2>

<p>让一大群人围观我的代码，还要在上面鸡蛋里挑骨头，想想我也是醉了，我的代码我做主，不想那么多人来judge我的代码。</p>

<p>我知道代码评审是保证质量的有利手段，也有知识传递、宣传团队规则的好处，但为了快速上线，这些活动能砍就砍掉吧。</p>

<h2>没有重构</h2>

<p>重构我有时候也是会做的，像以前我的变量名称都是拼音首字母来命名的，后来我把我系统里面的变量名称重构了一遍，在每个变量名加上了我的名字缩写前缀，像这样：<code>sb_xxx</code>，是不是很机智呢呵呵。</p>

<p>但是为了让项目赶紧上线，我还是别浪费太多时间在重构上面了，等以后有时间再来做吧，或者都后面维护的兄弟来重构吧，前提是他能看懂我的代码：）</p>

<h2>硬编码</h2>

<p>为了更快的提高我编码速度，遇到一些可以直接硬编码我一般都不定义变量，这样可以保证我的思路不被起变量名这种麻烦事情打断，反正这些以后都是改的，到时候再来修改代码就好了。</p>

<p>你看隔壁那个老王又写测试又重构的，还说什么这样以后方便维护，可以快速定位问题，但尼玛搞了2天才完成，而我才花了2个小时，这才是效率啊！什么？后面我花了2个月才修复1个Bug，你是怎么知道的？</p>

<h2>加班</h2>

<p>加班是我能力的重要证明啊，加班让我多了一倍时间来做项目，还怕完不成么？！</p>

<p>加班除了聊天吃饭打游戏外，最重要的是让BOSS知道我在加班，凌晨半夜发个邮件到整个公司邮箱是必须的，下班走的时候在朋友圈晒张"加班的夜晚真美"之类的照片也是极好的。让BOSS知道我就算没有功劳也有苦劳，到时候项目完不成也不要怪我，因为我已经加班了。</p>

<p>{% img /images/post/2015-9/sb1.jpeg 300 300 %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[通过TDD聊软件开发]]></title>
    <link href="http://zhaozhiming.github.io/blog/2015/09/15/say-something-about-develop-by-tdd/"/>
    <updated>2015-09-15T14:35:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2015/09/15/say-something-about-develop-by-tdd</id>
    <content type="html"><![CDATA[<p>{% img /images/post/2015-9/tdd.png 400 300 %}</p>

<p>TDD是由<a href="https://en.wikipedia.org/wiki/Extreme_programming">极限编程</a>提出的一个编程实践，与通常的编程行为相反，TDD是先编写测试案例，然后再编写功能代码，重复这样的一个过程直到功能实现完成为止。</p>

<!--more-->


<p></p>

<h2>TDD</h2>

<p>大家可能听过“六顶思考帽子”，说的是一种思维训练方式或者是一个全面思考问题的模型，我们借鉴思考帽子来说明TDD，可以看到最上面的那个图，三顶帽子分别表示TDD的三个步骤。</p>

<ul>
<li>红帽子: 编写一个测试案例，然后运行它，得到失败的测试结果</li>
<li>绿帽子: 编写功能代码，让失败的测试案例跑通过</li>
<li>蓝帽子: 对功能代码和测试代码进行重构</li>
</ul>


<p>为什么红代表失败，绿代表通过呢？可以想象成交通灯，红灯停绿灯行，在最早的时候是<a href="https://en.wikipedia.org/wiki/Kent_Beck">Kent Beck</a>开发的Junit，用它来跑单元测试的时候，失败会出现一个红色的进度条，成功会变成绿色的，所以红代表失败，绿代表成功。</p>

<p>需要注意的几点:</p>

<ul>
<li>在完成绿帽子的过程中，只需要添加让失败测试案例跑通过的功能代码，不要过渡设计。把整个功能代码都写完了，再来补单元测试，这种不是TDD。</li>
<li>在蓝帽子阶段，不仅要对功能代码进行重构，对测试代码也要进行重构，因为测试代码也是以后维护工作的一部分，如果你不认真对待它，它以后也不会好好对待你，烂测试比没有测试更恼火。</li>
</ul>


<p>一直重复这3个步骤，直到你的功能开发完成，这就是TDD。</p>

<h2>软件质量</h2>

<p>先抛开TDD，我们来聊一下项目管理。项目管理三要素:功能，时间，质量，这3者遵守着质量守恒定律。想象一个面积不变的三角形，如果把其中任意2个点往中心点外面拉伸，那第三个点肯定会往中心点靠近。</p>

<p>在传统的项目管理中，功能和时间往往是不可妥协的，比如领导要在xx日之前完成oo功能，开发团队没办法在规定时间完成指定功能，那要怎么办呢？这时候往往就会降低软件质量来达到目的。</p>

<p>而在敏捷开发中，软件质量是不可妥协的点，在保证高质量的软件基础上对其他2个要素进行裁剪，如果你的时间是deadline，一旦改了会影响产品推广，那我们就保证完成核心功能，其他不是那么重要的功能放到下一个版本；如果功能全部都是必须的，那么请把交付时间延后。</p>

<h2>Which One</h2>

<p>在TDD三顶帽子中，你最喜欢哪一个呢？可能大部分人都喜欢绿帽子（你才喜欢绿帽子!!你全家都喜欢绿帽子!!!&hellip;&ndash;_&ndash;#），因为绿帽子表示你的测试通过了，功能完成了，系统可以上线了。但我觉得蓝帽子和红帽子更加重要，为什么呢？</p>

<p>重构在软件开发中不是一项单独的活动，有的开发人员会说等开发完了所有功能之后，再单独找时间做重构，其实这是不对的，重构不是一个很”大“的事情，而是一个个编写好代码的手法或者技巧，这是一项贯穿软件开发整个过程的一个活动，比如在开发功能的时候进行重构，抽取重复代码进行功能复用，又或者在修复Bug时对之前不合理的代码进行重构，使之更具可维护性，各个阶段我们都可以进行重构。</p>

<p>重构是提高软件质量的重要手段之一，在极限编程中有很多实践都是用于提高软件质量的，包括单元测试，持续集成，TDD，结对编程等，而重构是贯穿在这些实践中的一个活动。</p>

<p>红帽子也比较重要，TDD——测试驱动开发，要先写出测试案例和验收条件，而这需要先分析需求、提炼需求，将需求转化为测试用例，测试驱动开发实际上是需求驱动开发，所以能写出一个好的测试用例，实际上就等于已经对功能代码做好了设计。经历过结对编程的人就有这种感觉，一个人写好测试案例，再由另外一个人来写功能代码，第二个人基本上不用费什么劲就可以写出功能代码，为什么呢？因为思路已经在测试案例中体现出来了，你只要照着写就可以了。</p>

<p>要学习TDD网上有很多资料，甚至还有不少视频是演示怎么做TDD的，这里就不详细举例子了，大家可以自行在网上查阅。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何学习Python]]></title>
    <link href="http://zhaozhiming.github.io/blog/2015/09/05/how-to-learn-python/"/>
    <updated>2015-09-05T15:01:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2015/09/05/how-to-learn-python</id>
    <content type="html"><![CDATA[<p>{% img /images/post/2015-9/python.jpg 400 300 %}</p>

<p>Python语言相对Java来说，最大的特点就是易用易学，基本上每个linux系统都有安装python，不像Java一样还需要自己下JVM、安装、设置环境变量等。有了其他编程语言的基础再来学习Python其实是非常简单的，因为Python语言是基于<a href="https://en.wikipedia.org/wiki/ABC_(programming_language)">ABC</a>语言开发出来的，ABC语言是以教学为目的的语言，其宗旨是让编程变得容易阅读和理解，所以Python语言也很容易理解和学习。</p>

<!--more-->


<p></p>

<h2>Pyhotn学习介绍</h2>

<p>关于Python的学习网上有很多介绍，我在这里介绍一下我的学习过程，包括书籍，网站和一些工具等。</p>

<h4>书籍</h4>

<p>关于Python的书我推荐<a href="http://book.douban.com/subject/3112503/">《Python核心编程（第二版）》</a>，这本书看起来很厚其实读起来非常浅显易懂，重点可以看看下面这几章。</p>

<p>{% codeblock lang:sh %}
第4章 Python对象
6.8 Unicode
8.11 迭代器和iter()函数
第9章 文件的输入和输出
第10章 错误和异常
第11章 函数和函数式编程
第12章 模块
第13章 面向对象编程
第14章 执行环境
第15章 正则表达式
第18章 多线程编程
20.2 使用Python进行Web应用：创建一个简单的Web客户端
{% endcodeblock %}</p>

<p>如果不想看这种太多理论的书的话，可以看这本实战的书<a href="http://learnpythonthehardway.org/">《Learn Python The Hard Way》</a>，里面的例子从浅到深让你一步步的学习Python，比较适合没有编程经验的新手。里面的例子不要只是把它们打出来，最好自己可以举一反三做一些关于知识点的挑战和扩展。</p>

<h4>网站</h4>

<p>除了看书编码外，平时业余时间可以订阅一些Python的blog和网站，下面是我最近收集的一些Python博客，分享一下:</p>

<ul>
<li><a href="http://planetpython.org/">Planet Python</a>: 这是最出名的python博客其中之一，快去看看，我希望你能找到对你有用的东西。</li>
<li><a href="http://lucumr.pocoo.org/">lucumr</a>: 博主是flask（一个python web框架）的创始人</li>
<li><a href="https://doughellmann.com">Doug Hellmann</a>: 博主是PYMOTW(Python Module Of the Week)成员之一，博客里面包含了很多python library的知识。如果你是在寻找一些实用的python库的话，你可以在这里找找。</li>
<li><a href="http://www.blog.pythonlibrary.org/">Mouse Vs Python</a>: 这个博客更新也比较频繁。</li>
<li><a href="http://www.pydanny.com/">pydanny</a>: 这是一个主要关注Django的博客，但也有很多关于Python的东西。</li>
</ul>


<h4>工具 &amp; 技巧</h4>

<p>pip和setuptools就不说了，Python开发必备，下载管理依赖包就靠他们了，其他最有用的Python工具要数<a href="http://docs.python-guide.org/en/latest/dev/virtualenvs/">virtualenv</a>了，它可以创建一个虚拟的Python执行环境，因为Python的虚拟机不像JVM那么大，创建出来之后的文件夹非常小（大概只有10M），在这个虚拟环境里面安装执行Python程序不会污染你操作系统的主Python环境。</p>

<p>{% codeblock lang:sh %}</p>

<h1>安装virtualenv</h1>

<p>pip install virtualenv</p>

<h1>创建Python虚拟环境</h1>

<p>virtualenv venv</p>

<h1>让虚拟环境生效</h1>

<p>source venv/bin/activate</p>

<h1>取消虚拟环境</h1>

<p>deactivate
{% endcodeblock %}</p>

<p>另外Pyhton的调试也非常方便，只要在需要设置断点的地方添加代码<code>import pdb;pdb.set_trace()</code>即可，然后执行程序就会在断点出停止，你可以通过打印下面命令进行调试:</p>

<ul>
<li><code>c</code>: 让程序继续往下走，continue的意思</li>
<li><code>s</code>: 进入子方法内部，相当于step into</li>
<li><code>n</code>: 跳到下一句
这里介绍的只是一些基本的命令，更多的命令可以看<a href="https://docs.python.org/2/library/pdb.html">这里</a>，另外还可以打印断点处的各种变量和执行各种语句。</li>
</ul>


<h2>简洁的Python</h2>

<p>在Python中执行<code>import this</code>可以看到Python之禅。</p>

<p>{% blockquote %}
The Zen of Python, by Tim Peters</p>

<p>Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren&rsquo;t special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one&mdash; and preferably only one &mdash;obvious way to do it.
Although that way may not be obvious at first unless you&rsquo;re Dutch.
Now is better than never.
Although never is often better than <em>right</em> now.
If the implementation is hard to explain, it&rsquo;s a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea &mdash; let&rsquo;s do more of those!
{% endblockquote %}</p>

<p>从Python之禅中我们可以看到Python是一门追求简洁，追求优雅的语言，语言设计者对代码质量要求比较高，希望编写Python代码的开发人员也能写出高质量的代码。</p>

<p>由于Python简洁而强大的函数式编程，我们可以很方便的创建结构稍微复杂的对象，特别复杂的还是建议使用class来创建对象。</p>

<p>比如我们有这样的一个数据结构，一个字典里面包含多个集合，用Java来初始化大概是这个样子:</p>

<p>{% codeblock lang:java %}
Map&lt;String, List<String>> map = new HashMap&lt;String, List<String>>();
List<String> list1 = new ArrayList<String>();
list1.add(&ldquo;foo1&rdquo;);
list1.add(&ldquo;bar1&rdquo;);
map.put(&ldquo;list1&rdquo;, list1);</p>

<p>List<String> list2 = new ArrayList<String>();
list2.add(&ldquo;foo2&rdquo;);
list2.add(&ldquo;bar2&rdquo;);
map.put(&ldquo;list2&rdquo;, list2);
{% endcodeblock %}</p>

<p>而用Python一行代码就可以搞定:</p>

<p>{% codeblock lang:python %}
my_map = {&lsquo;list1&rsquo;: [foo1, bar1], &lsquo;list2&rsquo;: [&lsquo;foo2'，'bar2&rsquo;]}
{% endcodeblock %}</p>

<p>所以说Java是一门很啰嗦的语言，虽然新版本的Java加了lambda，然而并不能减少多少Java语言本身的繁杂性。</p>

<h2>Djaogo学习介绍</h2>

<p>Python来实现一些小工具小应用是十分方便的，但Python也可以用来做Web开发，Python比较有名的Web框架有Django，Flask，Tormado等，其中Djaongo使用最为广泛，集成的东西也比较多，不管你是使用关系系数据库还是非关系数据库，是否使用缓存等都可以使用Django，其最好的一个特点是集成了管理员功能，可以省却开发者很大的一部分开发量。</p>

<p>有人可能会说Django比较重，对于新手来说学习成本比较高，对于这个我没有什么意见，因为工作需要使用Django，对于其他的框架还没有接触过，但我使用后的体验是Django虽然要配置的东西比较多，但只要配置好了，开发效率还是挺快的，也可能是我以前大部分时间使用Spring来开发，相对Spring来说Django的配置还算比较轻的，所以对我来说没有什么感觉:)</p>

<p>学习Django可以上Django的<a href="http//www.djangoproject.com">官网</a>，上面有startup的向导，通过向导一步步的操作可以让你快速了解一个web项目的开发，另外上面还有很多文档，可以知道Django的所有内容。</p>

<p>另外一个学习Django比较好的是《Django Book》这本书，这里有它的<a href="http://www.djangobook.com/en/2.0/index.html">网站</a>，书很浅显易读，详细讲解了Django各个部分的内容，有时候是先通过一个比较简单的实现方案实现需求，然后利用Django的特性让代码得到优化，更少的代码来实现更多的内容，这也体现了Django的思想，简洁优雅，复用性高。</p>

<p>理论知识学习的差不多了，最后当然是做项目练手了，可以自己动手做一个web项目来熟悉Python和Django，在实际操作的过程中遇到不懂的问题就google一下，然后记录下来，做过一两个项目之后你应该对Python和Django比较了解了:)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python-docx使用简介]]></title>
    <link href="http://zhaozhiming.github.io/blog/2015/08/16/hello-python-doxc/"/>
    <updated>2015-08-16T20:18:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2015/08/16/hello-python-doxc</id>
    <content type="html"><![CDATA[<p>{% img /images/post/2015-8/python-docx.png 400 300 %}</p>

<p>使用word文档来展现内容是很多企业使用的方式之一，但如果文档内容比较多，或者需要制作很多重复文档的话，编写文档的过程会十分枯燥无聊，如果这个时候有一个程序可以帮助你来完成文档制作工作的话那就太好了，这就是<a href="https://python-docx.readthedocs.org/en/latest/">python-docx</a>可以做的事情，下面我们就来看看python-docx的强大功能。</p>

<!--more-->


<p></p>

<h2>安装</h2>

<p>python-docx安装非常简单，可以使用<code>pip install python-docx</code>进行安装。</p>

<h2>创建文档</h2>

<p>使用python-docx创建一个文档非常简单，只需要2行代码就可以搞定，代码如下：</p>

<p>{% codeblock lang:python %}
document = Document()
document.save(&lsquo;foo.docx&rsquo;)
{% endcodeblock %}</p>

<h2>编写段落</h2>

<p>word文档最基本的内容就是一段段的文字信息，使用python-docx可以轻松的生成各种不同风格的段落。</p>

<p>{% codeblock lang:python %}</p>

<h1>普通段落</h1>

<p>document.add_paragraph(u'我是普通文档')</p>

<h1>带风格的段落</h1>

<p>document.add_paragraph(u'我是好看的文档', style=&lsquo;IntenseQuote&rsquo;)
{% endcodeblock %}</p>

<p>style属性是使用一个定制好的风格，名称必须是document对象包含了这个style名称才能使用，否则在生成文档的过程会报错或者style没有生效。</p>

<p>add_paragraph方法会返回一个paragraph对象，这个对象中有一个ParagraphFormat属性，通过设置ParagraphFormat属性的内容可以展示不同的风格：</p>

<ul>
<li>alignment: 段落对齐方式，值为<code>WD_PARAGRAPH_ALIGNMENT</code>常量中的一个。</li>
<li>line_spacing: 行间隔，单位可以有多种，详情参见<a href="https://python-docx.readthedocs.org/en/latest/api/shared.html">这里</a>。</li>
<li>first_line_indent: 首行缩进，值为整数，单位与line_spacing相同。</li>
</ul>


<p>还有其他更多的属性就不一一介绍了，我们还可以更加细粒度地控制一个段落的风格，比如前两句话我们使用粗体展示，后两句使用斜体，这就需要用到Run对象的属性设置了，Run可以看成是段落中的一句话，一个段落包含了n个Run。</p>

<p>{% codeblock lang:python %}
p = document.add_paragraph(&lsquo;&rsquo;)
run1 = p.add_run(u'句子一')
run1.bold = True</p>

<p>run2 = p.add_run(u'句子二')
run1.italic = True
{% endcodeblock %}</p>

<p>在document中我们还可以添加标题<code>Heading</code>，新建的文档有<code>0~9</code>级的标题让你选择（默认是1级），其实标题也是段落的一种，我们可以使用设置段落风格的方式来设置标题的风格。</p>

<p>{% codeblock lang:python %}
h = document.add_heading(u'标题', 0)
h.paragraph_format.alignment = WD_ALIGN_PARAGRAPH.LEFT
{% endcodeblock %}</p>

<h2>绘制表格</h2>

<p>在文档中我们可能会添加一些表格作为数据内容的展示，在python-docx里面可以轻松的绘制不同的表格。</p>

<p>{% codeblock lang:python %}</p>

<h1>绘制一个2 * 2的表格</h1>

<p>t = document.add_table(rows=2, cols=2)
t.cell(0, 0).text = u'单元1'
t.cell(0, 1).text = u'单元2'
t.cell(1, 0).text = u'单元3'
t.cell(1, 1).text = u'单元4'
{% endcodeblock %}</p>

<p>还可以对单元格进行合并：</p>

<p>{% codeblock lang:python %}
t = document.add_table(rows=2, cols=2)</p>

<h1>将第一行的2个单元格合并</h1>

<p>merge_cell = t.cell(0, 0).merge(t.cell(0, 1))
merge_cell.text = u'合并单元格'
{% endcodeblock %}</p>

<p>默认的表格是不带边框的，如果想让表格有边框，可以使用<code>Table Grid</code>这种表格的style。</p>

<p>{% codeblock lang:python %}
t = document.add_table(rows=2, cols=2)
t.style = &lsquo;Table Grid&rsquo;
{% endcodeblock %}</p>

<h2>添加图片</h2>

<p>添加图片也非常简单，在添加图片的方法中输入图片的相对路径即可。</p>

<p>{% codeblock lang:python %}
document.add_picture(&lsquo;demo.png&rsquo;)
{% endcodeblock %}</p>

<p>甚至可以添加网络上的图片到文档中，但前提是把图片下载到内存。</p>

<p>{% codeblock lang:python %}
import urllib2
import StringIO</p>

<h1>img_url为网络图片url地址</h1>

<p>image_from_url = urllib2.urlopen(img_url)
io_url = StringIO.StringIO()
io_url.write(image_from_url.read())
io_url.seek(0)
document.add_picture(io_url)
{% endcodeblock %}</p>

<h2>文档风格</h2>

<p>每个document对象里面都有一个styles对象，styles对象包含了文档可以使用的style，包括段落，表格，图片等的风格。</p>

<p>{% codeblock lang:python %}
document = Document()
print len(document.styles)
for s in document.styles:</p>

<pre><code>print s.name
</code></pre>

<p>console&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;
160
Normal
Heading 1
Heading 2
Heading 3
Heading 4
Heading 5
Heading 6
Heading 7
Heading 8
Heading 9
Default Paragraph Font
Normal Table
&hellip;
{% endcodeblock %}</p>

<p>这是新建的文档所包含的style，比较齐全，但如果是基于已有文档的document就只能使用已有文档的styles，可能会比新建的文档少很多。</p>

<p>{% codeblock lang:python %}
document = Document(&lsquo;exist.docx&rsquo;)
print len(document.styles)</p>

<p>console&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;
12
{% endcodeblock %}</p>

<p>python-docx是没有设置页眉页脚功能的，但是通过打开一个已经存在页眉页脚的文档，我们就可以拥有包含页眉页脚的document了。</p>

<p>这些是python-docx的一些基本使用方法，更多的内容请参考官方文档，谢谢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何在Spring中配置Websocket]]></title>
    <link href="http://zhaozhiming.github.io/blog/2015/05/11/spring-websocket-config/"/>
    <updated>2015-05-11T09:41:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2015/05/11/spring-websocket-config</id>
    <content type="html"><![CDATA[<p>{% img /images/post/2015-5/websockets.png %}</p>

<p>Websocket是HTML5的一项新技术，可以让服务端和客户端进行实时的通信，主要的使用场景有: 实时的聊天系统，对实时性要求比较高的游戏，或者金融行业对股票市场数据的及时获取等。在Spring3的时候就已经有了对Websocket的支持，不过需要一些高版本的web容器来运行，比如Tomcat7.0.47+，Jetty9等。</p>

<!--more-->


<p></p>

<p>在Spring的官网上有关于Websocket的示例工程，<a href="https://spring.io/guides/gs/messaging-stomp-websocket/">https://spring.io/guides/gs/messaging-stomp-websocket/</a>，里面简单介绍了如何通过Spring-boot来进行Websocket系统的构建。我们的例子将基于这个例子进行修改，但是是使用传统的Spring的方式进行配置。</p>

<h2>依赖包</h2>

<p>首先我们需要添加相关的依赖包:</p>

<ul>
<li>Websocket需要servlet3.1的版本</li>
<li>spring-websocket和spring-messaging是Spring关于Websocket的组件</li>
<li>使用Jackson进行json数据的处理</li>
</ul>


<p>{% codeblock build.gradle lang:groovy %}
String springVersion = &ldquo;4.1.4.RELEASE&rdquo;
String jacksonDatabindVersion = &ldquo;2.5.0&rdquo;
String jacksonVersion = &ldquo;1.9.13&rdquo;
dependencies {</p>

<pre><code>//websocket
compile("javax.websocket:javax.websocket-api:1.1")
compile("javax.servlet:javax.servlet-api:3.1.0")

//spring
compile("org.springframework:spring-messaging:" + springVersion)
compile("org.springframework:spring-websocket:" + springVersion)

//json
compile "com.fasterxml.jackson.core:jackson-databind:" + jacksonDatabindVersion
compile "org.codehaus.jackson:jackson-mapper-asl:" + jacksonVersion
compile "org.codehaus.jackson:jackson-core-asl:" + jacksonVersion
</code></pre>

<p>}
{% endcodeblock %}</p>

<h2>xml配置（类配置）</h2>

<p>我们有两种方式进行Websocket的配置，一种是通过xml文件的方式，在这里我们定义了websocket的配置信息，这样服务器往客户端发送消息就可以通过<code>/topic/xx</code>来发送，客户端则可以通过<code>/app/hello</code>来发送消息到服务端。</p>

<p>{% codeblock lang:xml %}
&lt;beans xmlns=&ldquo;<a href="http://www.springframework.org/schema/beans">http://www.springframework.org/schema/beans</a>&rdquo;</p>

<pre><code>   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:websocket="http://www.springframework.org/schema/websocket"
   xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
    http://www.springframework.org/schema/websocket http://www.springframework.org/schema/websocket/spring-websocket.xsd"&gt;

...... // other configurations

&lt;websocket:message-broker application-destination-prefix="/app"&gt;
    &lt;websocket:stomp-endpoint path="/hello"&gt;
        &lt;websocket:sockjs/&gt;
    &lt;/websocket:stomp-endpoint&gt;
    &lt;websocket:simple-broker prefix="/topic"/&gt;
&lt;/websocket:message-broker&gt;
</code></pre>

<p></beans>
{% endcodeblock %}</p>

<p>另外一种方式是通过类的方式，代码如下，功能与上面的xml配置相同:</p>

<p>{% codeblock WebSocketConfig.java lang:java %}
import org.springframework.context.annotation.Configuration;
import org.springframework.messaging.simp.config.MessageBrokerRegistry;
import org.springframework.web.socket.config.annotation.AbstractWebSocketMessageBrokerConfigurer;
import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;
import org.springframework.web.socket.config.annotation.StompEndpointRegistry;</p>

<p>@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig extends AbstractWebSocketMessageBrokerConfigurer {</p>

<pre><code>@Override
public void configureMessageBroker(MessageBrokerRegistry config) {
    config.enableSimpleBroker("/topic");
    config.setApplicationDestinationPrefixes("/app");
}

@Override
public void registerStompEndpoints(StompEndpointRegistry registry) {
    registry.addEndpoint("/hello").withSockJS();
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<h2>消息类和Controller定义</h2>

<p>Controller定义:</p>

<p>{% codeblock WebSocketConfig.java lang:java %}
import com.zzm.wechat.model.Greeting;
import com.zzm.wechat.model.HelloMessage;
import org.springframework.messaging.handler.annotation.MessageMapping;
import org.springframework.messaging.handler.annotation.SendTo;
import org.springframework.stereotype.Controller;</p>

<p>@Controller
public class GreetingController {</p>

<pre><code>@MessageMapping("/hello")
@SendTo("/topic/greetings")
public Greeting greeting(HelloMessage message) throws Exception {
    Thread.sleep(3000); // simulated delay
    return new Greeting("Hello, " + message.getName() + "!");
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>消息model的定义:</p>

<p>{% codeblock WebSocketConfig.java lang:java %}
public class Greeting {</p>

<pre><code>private String content;

public Greeting(String content) {
    this.content = content;
}

public String getContent() {
    return content;
}
</code></pre>

<p>}</p>

<p>public class HelloMessage {</p>

<pre><code>private String name;

public String getName() {
    return name;
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>在web.xml中设置controller的url前缀，这样可以避免一些页面的url被controller拦截。</p>

<p>{% codeblock web.xml lang:xml %}</p>

<pre><code>&lt;servlet&gt;
    &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/api/*&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>

<p>{% endcodeblock %}</p>

<h2>客户端页面</h2>

<p>首先下载<code>stomp.js</code>和<code>sockjs.js</code>，然后编写一个html页面进行客户端websocket的连接，并实现发送消息和接收消息的功能。我们使用SockJS的方式来创建Websocket连接，注意url要加上domain名称(这里是<code>server</code>)和<code>api</code>前缀。</p>

<p>{% codeblock demo.html lang:html %}
&lt;!DOCTYPE html>
<html>
<head></p>

<pre><code>&lt;title&gt;Hello WebSocket&lt;/title&gt;
&lt;script src="resources/sockjs-0.3.4.js"&gt;&lt;/script&gt;
&lt;script src="resources/stomp.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
    var stompClient = null;

    function setConnected(connected) {
        document.getElementById('connect').disabled = connected;
        document.getElementById('disconnect').disabled = !connected;
        document.getElementById('conversationDiv').style.visibility = connected ? 'visible' : 'hidden';
        document.getElementById('response').innerHTML = '';
    }

    function connect() {
        var socket = new SockJS('/server/api/hello');
        stompClient = Stomp.over(socket);
        stompClient.connect({}, function(frame) {
            setConnected(true);
            console.log('Connected: ' + frame);
            stompClient.subscribe('/topic/greetings', function(greeting){
                showGreeting(JSON.parse(greeting.body).content);
            });
        });
    }

    function disconnect() {
        if (stompClient != null) {
            stompClient.disconnect();
        }
        setConnected(false);
        console.log("Disconnected");
    }

    function sendName() {
        var name = document.getElementById('name').value;
        stompClient.send("/app/hello", {}, JSON.stringify({ 'name': name }));
    }

    function showGreeting(message) {
        var response = document.getElementById('response');
        var p = document.createElement('p');
        p.style.wordWrap = 'break-word';
        p.appendChild(document.createTextNode(message));
        response.appendChild(p);
    }
&lt;/script&gt;
</code></pre>

<p></head>
<body onload="disconnect()">
<noscript><h2 style="color: #ff0000">Seems your browser doesn&rsquo;t support Javascript! Websocket relies on Javascript being enabled. Please enable</p>

<pre><code>Javascript and reload this page!&lt;/h2&gt;&lt;/noscript&gt;
</code></pre>

<div>
    <div>
        <button id="connect" onclick="connect();">Connect</button>
        <button id="disconnect" disabled="disabled" onclick="disconnect();">Disconnect</button>
    </div>
    <div id="conversationDiv">
        <label>What is your name?</label><input type="text" id="name" />
        <button id="sendName" onclick="sendName();">Send</button>
        <p id="response"></p>
    </div>
</div>


<p></body>
</html>
{% endcodeblock %}</p>

<p>运行结果：</p>

<p>{% img /images/post/2015-5/websocket-run.png %}</p>

<p>浏览器console信息:</p>

<p>{% codeblock lang:sh %}
Disconnected
chrome-extension://fhhdlnnepfjhlhilgmeepgkhjmhhhjkh/js/detector.js:505 detector
chrome-extension://fhhdlnnepfjhlhilgmeepgkhjmhhhjkh/js/detector.js:506 Object
stomp.js:130 Opening Web Socket&hellip;
stomp.js:130 Web Socket Opened&hellip;
stomp.js:130 >>> CONNECT
accept-version:1.1,1.0
heart-beat:10000,10000</p>

<p>&lt;&lt;&lt; CONNECTED
version:1.1
heart-beat:0,0</p>

<p>connected to server undefined
demo.html:22 Connected: CONNECTED
heart-beat:0,0
version:1.1</p>

<blockquote><blockquote><blockquote><p>SUBSCRIBE
id:sub-0
destination:/topic/greetings</p>

<p>SEND
destination:/app/hello
content-length:14</p></blockquote></blockquote></blockquote>

<p>{&ldquo;name&rdquo;:&ldquo;zzm&rdquo;}
&lt;&lt;&lt; MESSAGE
destination:/topic/greetings
content-type:application/json;charset=UTF-8
subscription:sub-0
message-id:3657pj5u-0
content-length:25</p>

<p>{&ldquo;content&rdquo;:&ldquo;Hello, zzm!&rdquo;}
{% endcodeblock %}</p>

<h2>gradle运行jetty9</h2>

<p>gradle内置的Jetty版本是Jetty6，由于版本较低不支持websocket，所以我们测试的话需要打包并部署到Jetty9或Tomcat7.0.47+上，但我们可以通过其他gradle插件来把我们的本地服务运行到Jetty9上。这里介绍2个插件，<a href="https://github.com/akhikhl/gretty">Gretty</a>和<a href="https://github.com/bmuschko/gradle-cargo-plugin">Cargo</a>。</p>

<h4>Gretty</h4>

<p>在<code>build.gradle</code>中添加如下脚本:</p>

<p>{% codeblock build.gradle lang:groovy %}
buildscript {</p>

<pre><code>repositories {
    maven {
        url "http://maven.oschina.net/content/groups/public/"
    }
}

dependencies {
    classpath 'org.akhikhl.gretty:gretty:+'
}
</code></pre>

<p>}</p>

<p>apply plugin: &lsquo;org.akhikhl.gretty&rsquo;
// apply plugin: &lsquo;jetty&rsquo; 注意要注释掉原来的jetty插件</p>

<p>gretty {</p>

<pre><code>httpPort = 9898 // 指定web服务的http端口
servletContainer = 'jetty9' // 这里可以指定tomcat,jetty的几个版本
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>然后运行<code>gradle appRun</code>即可。</p>

<h4>Cargo</h4>

<p>在<code>build.gradle</code>中添加如下脚本，注意要先下载jetty9的安装包并解压:</p>

<p>{% codeblock build.gradle lang:groovy %}
buildscript {</p>

<pre><code>repositories {
    maven {
        url "http://maven.oschina.net/content/groups/public/"
    }
}

dependencies {
    classpath 'com.bmuschko:gradle-cargo-plugin:2.1'
}
</code></pre>

<p>}</p>

<p>apply plugin: &lsquo;com.bmuschko.cargo&rsquo;
cargo {</p>

<pre><code>containerId = 'jetty9x'
port = 9898
local {
    homeDir = file('/Users/zhaozhiming/tools/jetty-distribution-9.2.10.v20150310')
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>然后运行<code>gradle war CargoRunLocal</code>，注意首先要打出war包，然后插件会自动部署war包到Jetty9的安装目录下，这种方式不大灵活，比如一些页面的修改都需要重新部署才能进行测试。</p>

<p>最后附上Spring关于Websocket的文档链接，请见<a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html">这里</a>。</p>
]]></content>
  </entry>
  
</feed>
