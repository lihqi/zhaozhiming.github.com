<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Hacker and Geeker's Way]]></title>
  <link href="http://zhaozhiming.github.io/atom.xml" rel="self"/>
  <link href="http://zhaozhiming.github.io/"/>
  <updated>2013-09-11T08:03:35+08:00</updated>
  <id>http://zhaozhiming.github.io/</id>
  <author>
    <name><![CDATA[赵芝明]]></name>
    <email><![CDATA[kingzzm1982@sina.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[我的octopress配置]]></title>
    <link href="http://zhaozhiming.github.io/blog/2013/09/05/my-octopress-setting/"/>
    <updated>2013-09-05T07:33:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2013/09/05/my-octopress-setting</id>
    <content type="html"><![CDATA[<p>在github上用octopress搭建了自己的blog，octopress号称是“专门给黑客打造的博客（A blogging framework for
把hackers）”，使用Markdown语法来写blog确实感觉像写代码一样，而且写好的
把blog可以本地调试好了再上传到github的服务器，就像你的应用程序调试好了部署到服务器一样。</p>

<p>我最喜欢的是octopress的代码片段，简洁清晰，而且支持各种语言的高亮显示，你还可以在你的blog中嵌入不同的js框架（比如jquery或angularJs），展示js代码的效果。octopress支持的插件很多，还可以选择各种主题来装饰你的blog，下面我也按照惯例秀秀自己的octopress配置。</p>

<h3>主题</h3>

<p>你当然可以使用octopress的默认主题，但这样很容易和其他人的界面“撞衫”，想要让自己的octopress与众不同，就要定制自己的主题界面。在github上面可以找到octopress的第三方主题，地址在<a href="https://github.com/imathis/octopress/wiki/3rd-Party-Octopress-Themes">这里</a>，另外还有一个网站也是专门介绍octopress主题的，地址在<a href="http://opthemes.com/">这里</a>。其中也有一些国人制作的主题界面，非常漂亮。</p>

<h3>评论插件</h3>

<p>原先使用的是国外的一个第三方评论插件Disqus，但由于国外多用facebook或twitter等帐号来登录这个插件，而这些网站都被我们伟大的GFW墙了，所以我选择了国内的一个同类产品——多说（其实应该是山寨Disqus的）。多说可以使用国内主流应用的帐号来登录，比如新浪微博或QQ等，可以将你blog中的评论保存到服务器上，后续不管你把blog迁移到什么地方，评论都不会消失。可以到<a href="http://duoshuo.com/">这里</a>下载。</p>

<h3>标签云</h3>

<p>octopress默认的只有目录（categories），没有标签（Tag），目录和标签是不一样的，每一篇p ost只能归在一个目录里面，但却可以归在多个标签中。随着post的增多，标签也会慢慢变多，标签多了之后可以将标签做成标签云，放在blog的边栏上，非常美观。想做标签云，需要使用到2个插件，<a href="https://github.com/robbyedwards/octopress-tag-pages">robbyedwards/octopress-tag-pages</a>和<a href="https://github.com/robbyedwards/octopress-tag-cloud">robbyedwards/octopress-tag-cloud</a>。具体安装步骤请参照该github上的说明。</p>

<h3>同步插件</h3>

<p>在github上面搭建自己的octopress博客，有个缺点是在搜索引擎中没有收录你的网站，导致别人很难在google或者百度里面找到你的文章，如果你的博客放在比较大的博客网站的话（比如博客园、博客大巴等），在各大搜索网站就可以很容易搜到你的blog。我曾经试过在每篇post上面加上“keywords&#8221;标签来记录post的关键字，希望搜索引擎可以搜录，但结果还是不行。<br/>
在网上搜了一下，发现有人写了一个octopress插件，可以将octopress的post同步到几个比较大的博客网站，可以同步所有的post，也可以同步最近一篇post。网址在<a href="https://github.com/huangbowen521/octopress-syncPost">这里</a>。<br/>
上面几个是我的octopress主要插件，主题上面我还是不大满意，可能以后还会更新。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[facebook的工程师文化——《打造facebook》读后感]]></title>
    <link href="http://zhaozhiming.github.io/blog/2013/06/04/facebook-engineer-culture/"/>
    <updated>2013-06-04T07:36:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2013/06/04/facebook-engineer-culture</id>
    <content type="html"><![CDATA[<p>在今年北京的QCon大会上听了facebook早期中国籍工程师王淮的演讲，受益匪浅，主题是如何打造高效能团队，主要介绍他在facebook的一些经历和管理上的经验分享。现在的他是一名天使投资人，投资的领域有移动互联，支付，云应用等。他还写了《打造facebook》一书，讲了facebook的公司文化和他在其中的开发管理等经历。</p>

<h3>工具文化</h3>

<p>这本书给我印象最深的一点是facebook的&#8221;工具文化&#8221;。为帮助工程师更好的进行产品开发，facebook对内部工具Tools是非常关注的。facebook极力强调，要将最好的工程师放到工具开发这一块，因为工具做好了，可以达到事半功倍的效果，所有人的效率都可以提高，而不仅仅是工程师。还有通过工具来解决流程上面的问题，比如公司在推广一些规范性的规则，传统的方法是反复强调，另一种是开发出好用的工具，将这些东西固定在工具里面，借助工具进行强制性推广。不断的更新和完善公司自己的工具，并将公司的企业文化也融入到工具之中，有时候比找到一个伟大的创意更重要。</p>

<p>facebook研发的工具有很多，比如新人刚加入facebook时，需要分配自己的开发服务器，facebook就有一个工具来管理公司的开发机器。在这个工具上，你可以看到所有机器的详细信息，包括分配给什么人，什么时间分配的，机器的配置信息等。在还未申请的机器上面，只需要点击一个按钮就会帮你安装好开发服务器，非常方便和简单。对于我们开发人员来说工作主要是写代码，facebook针对代码管理业开发了很多工具。比如有一款工具是在开发人员提交代码之前对代码进行检查，如果代码不符合代码规范或者没有写测试案例，工具会发出警告并交给开发人员修改。还有一款code review的工具叫Phabricator，开发人员可以在上面针对每一行代码进行讨论，如果代码有问题，代码审查者可以提问题，或者让代码提交者修改等，只有代码明确接受后，才可以提交到服务器的代码库中。这些工具的理念是将重复性的劳动交给电脑来执行，以&#8221;Don&rsquo;t Make Me Think&#8221;的方式来推广好习惯。</p>

<h3>黑客文化</h3>

<p>facebook一直强调公司的黑客文化，总部基地建有&#8221;黑客广场&#8221;，公司内部随处可见的黑客标志，facebook还会定期举行黑客马拉松(Hackathon)。像Google 允许员工用工作时间的20%来做自己喜欢的东西一样，Hackathon也是facebook让员工保持创造力，避免工作枯燥而失去工作激情的一种方式，在这个过程中，也催生了很多伟大的作品，比如timeline(时间轴)，全屏照片视图等。参加Hackathon虽然是自愿的，但facebook强烈建议每个员工都去参加Hackahton，甚至有的工程师因为要安排产品上线而无法参加Hackathon，公司会调整产品的上线时间来让工程师去参加Hackathon。</p>

<p>facebook的CEO 扎克伯格本身就是一个黑客，看过《社交网络》的朋友都会记得电影开始的那一段场景，扎克伯格做了一个哈佛版美女评选网站（Facemash），为了得到更多女同学的照片，他黑进了当时学生宿舍里面每个学生的电脑去获取他们同学的照片。扎克伯格想打造独一无二的企业文化和管理方式，他将公司的这种文化称之为&#8221;黑客之道&#8221;(Hacker Wiay)，他诠释说，黑客文化是一种持续改进的做事方法，黑客迅速发布小规模的更新，然后从中获取到经验，在下一次更新中更好的改进，直到产品完成（有点敏捷开发的意思）。Done is better than prefect（完成胜于完美），这是facebook对这种黑客精神的诠释。</p>

<p>facebook的黑客文化还包括一种亲身实践，积极进取的精神。Code Wins Arguments（代码胜于雄辩），在facebook的产品开发过程中，经常会有一个工程师站出来说，给我2天的时间我做个demo出来，证明我的想法是可行的。facebook不会有那种长达几天的马拉松会议，工程师们会开发出产品原型来证明是否行得通，在facebook每个工程师都是顶尖的人才，他们具有这样一种快速开发的能力。</p>

<p>书中除了谈到上面所讲的这些点外，还谈到了作者在facebook中的项目管理经验，适合做项目管理的同学参考借鉴，最后希望大家也喜欢facebook的黑客文化。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[利用Sonar定制自定义JS扫描规则（三）——SSLR JavaScript Toolkit 使用说明]]></title>
    <link href="http://zhaozhiming.github.io/blog/2013/05/20/use-sonar-create-customer-js-verify-rule-part-3/"/>
    <updated>2013-05-20T11:20:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2013/05/20/use-sonar-create-customer-js-verify-rule-part-3</id>
    <content type="html"><![CDATA[<p>在上一篇blog中讲了在sonar中如何新增自定义的JS规则，这里面比较难的地方是XPath语句的编写，而要编写正确的XPath语句，首先要拿到语法的AST，下面我们就来介绍如何使用SSLR JavaScript Toolkit 工具来得到源代码的语法树。</p>

<p>首先通过在<a href="http://repository.codehaus.org/org/codehaus/sonar-plugins/javascript/sslr-javascript-toolkit/1.3/sslr-javascript-toolkit-1.3.jar">这里</a>下载SSLR JavaScript Toolkit 工具，下载下来是一个jar包，在cmd窗口使用java -jar sslr-javascript-toolkit-1.3.jar打开这个工具，操作界面如下：<br/>
<img src="http://zhaozhiming.github.io/images/02073536-58b547f5394041cdb795a717087eca35.png"></p>

<p>左上方的窗口是用来输入你的源代码，右上方的窗口是来显示你的AST，最下面的窗口是来输入你的XPath规则。</p>

<p>我们现在左上方输入一些简单的javascript代码，然后点击 Parse Source Code按钮，可以得到源代码的语法树：</p>

<p><img src="http://zhaozhiming.github.io/images/02074124-ca30984af1704101962348b52d4a5f34.png"></p>

<p>得到语法树后，我们也可以点击右边窗口的XML页面，得到的是语法树的XML文档。有了XML文档，就可以通过XPath轻松得到你想要的语句了。</p>

<p>举个例子：比如我想得到本地变量名，即var关键字后面的变量名，可以通过XPath的语法来查询。</p>

<p>在最下方的窗口输入XPath语法规则，点击Evaluate XPath按钮，如果语法正确，就会出现返回结果，并高亮选中你想要查询的代码，如下：</p>

<p><img src="http://zhaozhiming.github.io/images/02074943-45053229678b4effbec60cf2c363b076.png"></p>

<p>如果语法错误，右边的窗口会给出提示，如果查询语句不正确，任何源代码都不会被选中。更多的XPath语法可以参考<a href="http://www.w3schools.com/xpath/">http://www.w3schools.com/xpath/</a>。<br/>
总结：sonar其实很早就支持了对JS的代码校验，但是你如果想自己定制校验规则，最简单的方式就是通过sonar的web接口增加XPath规则，这个需要在XPath语法上多花点力气，如果写出来的查询语法不正确，可以多试几遍，用SSLR JavaScript Toolkit 可以很方便的调试。最后祝大家都可以在sonar上配置自己的自定义规则。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[利用Sonar定制自定义JS扫描规则（二）——自定义JS扫描规则]]></title>
    <link href="http://zhaozhiming.github.io/blog/2013/05/19/use-sonar-create-customer-js-verify-rule-part-2/"/>
    <updated>2013-05-19T11:20:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2013/05/19/use-sonar-create-customer-js-verify-rule-part-2</id>
    <content type="html"><![CDATA[<p>在上一篇blog中，我们将sonar几个需要的环境都搭建好了，包括sonar的服务器，sonar runner，sonar的javascript插件。现在我们就来讲如何自定义JS扫描规则。</p>

<p>实际上有3种方法可以自定义代码的校验规则：</p>

<ul>
<li>直接在sonar的web接口中增加XPath规则；</li>
<li>通过插件的功能来增加自定义规则，比如checkstyle，pmd等插件是允许自定义规则的；</li>
<li>通过新增一个代码分析器来实现自定义规则；</li>
</ul>


<p>sonar官方推荐的方式是使用最简单的XPath方式来增加自定义规则，如果语言太复杂或者XPath无法查询其结构的，再使用自定义插件的方式，所以我们这里重点介绍的是使用XPath的方式。</p>

<h3>使用XPath增加自定义JS规则</h3>

<p>sonar为大部分流行的语言（C, C#, C++, Cobol, Flex, JavaScript, PL/I, PL/SQL, Python and VB.NET）提供了一个简洁的方式来增加代码规则。这些新增规则必须使用<a href="http://en.wikipedia.org/wiki/XPath">XPath</a>来实现，这样的话语言的每一部分都可以映射到<a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree">Abstract Syntax Tree</a>（AST）。对于每一种语言，SSLR Toolkit 工具提供了代码转AST的功能，该工具具体的使用在下面会介绍，这里是<a href="http://repository.codehaus.org/org/codehaus/sonar-plugins/javascript/sslr-javascript-toolkit/1.3/sslr-javascript-toolkit-1.3.jar">SSLR Javascript Toolkit</a>工具的下载。如果对XPath不熟悉，可以参考这里看一下例子<a href="http://www.w3schools.com/xpath/">http://www.w3schools.com/xpath/</a>。<br/>
1、首先使用管理员的角色登录sonar，然后去到Settings > Quality Profile页面，选择Js规则（如下图所示）。</p>

<p><img src="http://zhaozhiming.github.io/images/02070803-9bce5fab1bf543059071fafff2ae37d8.png"></p>

<p>2、接着在Coding rules页面输入查询条件，找到XPath规则：</p>

<p><img src="http://zhaozhiming.github.io/images/02070943-c9a5b7732ea6478fba266555c308fc29.png"></p>

<p>3、查询结果出来后，点击Copy rule连接来新增规则：</p>

<p><img src="http://zhaozhiming.github.io/images/02071054-da90a48498234fc19d34aff75c84a104.png"></p>

<p>4、按照XPath的语法编写自己的规则：</p>

<p><img src="http://zhaozhiming.github.io/images/02071436-15c170e9f4eb4f6684d95df76fe6e628.png"></p>

<p>如果对XPath不熟悉，建议先学习一些XPath的语法，下面给出3个javascript xpath的规则：</p>

<h5>不要使用document.write:</h5>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>//callExpression/memberExpression[count(*) = 3 and primaryExpression[@tokenValue = &quot;document&quot;] and identifierName[@tokenValue = &quot;write&quot;]]
</span></code></pre></td></tr></table></div></figure>


<h5>if/else语句后面必须接大括号：</h5>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>//ifStatement/statement[not(block)]
</span></code></pre></td></tr></table></div></figure>


<h5>本地变量名以XX开头：</h5>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>//functionBody//variableDeclaration/IDENTIFIER[not(starts-with(@tokenValue,&#39;zzm&#39;))]
</span></code></pre></td></tr></table></div></figure>


<p>5、创建好规则之后，把规则设置为active，将规则的级别调高一些就会自动变为active，然后重新跑一下规则分析，这样新增的规则就生效了。</p>

<p><img src="http://zhaozhiming.github.io/images/02072520-4308a5a558d04ded998bb54f452c71f7.png"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[利用Sonar定制自定义JS扫描规则（一）——sonar环境搭建]]></title>
    <link href="http://zhaozhiming.github.io/blog/2013/05/19/use-sonar-create-customer-js-verify-rule-part-1/"/>
    <updated>2013-05-19T11:20:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2013/05/19/use-sonar-create-customer-js-verify-rule-part-1</id>
    <content type="html"><![CDATA[<p>接触sonar已经有段时间了，最早是在一个项目组里面听到这个框架，后来在公司持续集成活动的推动下，也逐渐学习了sonar的具体功能。sonar集成了findbugs，pmd，checkstyle各种静态代码检查工具的功能，并且可以将各种扫描结果组合成一张张漂亮的报告，功能很是强大。下面介绍一下如何使用sonar来自定义javascrpit的扫描规则。</p>

<p>虽然使用过很多次sonar，但都是在别人搭好的环境上使用的，自己还没有真正搭建过，这里首先介绍一下sonar环境的搭建。</p>

<h3>sonar环境搭建</h3>

<p>首先到sonar官网上下载其最新版本，我下的是3.5.1。下下来是一个zip包，直接将其解压到你想要安装的目录就好了。</p>

<h4>使用H2内存数据库</h4>

<p>sonar服务的启动是要有数据库来支持的，sonar本身自带了H2内存数据库，可以直接使用。在解压目录下的conf目录下，有一个sonar.properties的配置文件是来保存sonar的配置，如果你使用的是H2数据库的话，将配置文件中的下面部分代码注释去掉即可。</p>

<figure class='code'><figcaption><span>sonar.properties </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='properties'><span class='line'><span class="c">#sonar.jdbc.url:                            jdbc:h2:tcp://localhost:9092/sonar</span>
</span><span class='line'><span class="c">#sonar.jdbc.driverClassName:                org.h2.Driver</span>
</span></code></pre></td></tr></table></div></figure>


<p>在解压目录下的extras\database\mysql目录，有2个mysql的sql文件，其中1个是创建sonar数据库和用户的脚本，可以参照这个脚本来创建H2的sonar相关数据库和用户。</p>

<h4>使用外部数据库（以mysql为例）</h4>

<p>sonar官网强烈建议，如果你的产品只是学习或者练习用的demo，可以使用内存数据库，否则请使用外部数据库。sonar支持大部分主流的数据库，比如mysql，oracle，postgresql，Microsoft SQLServer。</p>

<p>我们以mysql为例，首先安装mysql（安装mysql的过程就不再详细描述，网上有很多），这里要注意将数据库的字符集设置为UTF-8。安装完成之后，同样修改conf目录下的sonar.properties文件，将mysql部分的配置项打开。然后在mysql中将上面提到的那个创建sonar数据库和用户脚本施行一遍。</p>

<figure class='code'><figcaption><span>sonar.properties </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='properties'><span class='line'><span class="c">#----- MySQL 5.x</span>
</span><span class='line'><span class="c"># Comment the embedded database and uncomment the following line to use MySQL</span>
</span><span class='line'><span class="c">#sonar.jdbc.url:                            jdbc:mysql://localhost:3306/sonar?useUnicode=true&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=true</span>
</span></code></pre></td></tr></table></div></figure>


<h4>启动服务</h4>

<p>数据库配置完成之后，就可以来启动web服务了，去到解压目录下的bin目录，找到自己相关系统的目录，以64位windows系统为例，目录为：bin\windows-x86-64，运行该目录下的Startsonar.bat文件，如果启动没有报错的话，就可以在浏览器中输入：<code>http://localhost:9000</code>，查看sonar的主界面了。</p>

<h3>安装Sonar Runner</h3>

<p>上面搭建的只是sonar的服务平台，如果想用sonar来分析自己项目代码的话，可以有多种方式，比如ant、maven等，而sonar官网上推荐的是使用Sonar Runner来执行分析项目的操作。</p>

<p>首先去到sonar官网下载Sonar Runner的压缩包，和sonar的压缩包一样，先解压到你要安装的目录。然后增加SONAR_RUNNER_HOME这个环境变量，变量值为你runner的解压目录，然后将$SONAR_RUNNER_HOME$/bin的加到PATH变量后面（配置过java环境变量的同学都懂的）。这样就安装完成了，打开cmd验证一下，打出sonar-runner -h，如果出现下面的提示信息，即表示你的runner安装成功了。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>usage: sonar-runner <span class="o">[</span>options<span class="o">]</span>
</span><span class='line'>
</span><span class='line'>Options:
</span><span class='line'> -h,--help             Display <span class="nb">help </span>information
</span><span class='line'> -X,--debug            Produce execution debug output
</span><span class='line'> -D,--define &lt;arg&gt;     Define property
</span></code></pre></td></tr></table></div></figure>


<p>安装完runner以后，在你的项目根目录下，增加sonar-project.properties文件，内容如下：</p>

<figure class='code'><figcaption><span>sonar.properties </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='properties'><span class='line'><span class="c"># required metadata</span>
</span><span class='line'><span class="na">sonar.projectKey</span><span class="o">=</span><span class="s">my:project</span>
</span><span class='line'><span class="na">sonar.projectName</span><span class="o">=</span><span class="s">My project</span>
</span><span class='line'><span class="na">sonar.projectVersion</span><span class="o">=</span><span class="s">1.0</span>
</span><span class='line'>
</span><span class='line'><span class="c"># optional description</span>
</span><span class='line'><span class="na">sonar.projectDescription</span><span class="o">=</span><span class="s">Fake description</span>
</span><span class='line'>
</span><span class='line'><span class="c"># path to source directories (required)</span>
</span><span class='line'><span class="na">sonar.sources</span><span class="o">=</span><span class="s">srcDir1,srcDir2</span>
</span><span class='line'>
</span><span class='line'><span class="c"># path to test source directories (optional)</span>
</span><span class='line'><span class="na">sonar.tests</span><span class="o">=</span><span class="s">testDir1,testDir2</span>
</span><span class='line'>
</span><span class='line'><span class="c"># path to project binaries (optional), for example directory of Java bytecode</span>
</span><span class='line'><span class="na">sonar.binaries</span><span class="o">=</span><span class="s">binDir</span>
</span><span class='line'>
</span><span class='line'><span class="c"># optional comma-separated list of paths to libraries. Only path to JAR file is supported.</span>
</span><span class='line'><span class="na">sonar.libraries</span><span class="o">=</span><span class="s">path/to/library/*.jar,path/to/specific/library/myLibrary.jar,parent/*/*.jar</span>
</span><span class='line'>
</span><span class='line'><span class="c"># The value of the property must be the key of the language.</span>
</span><span class='line'><span class="na">sonar.language</span><span class="o">=</span><span class="s">java</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Additional parameters</span>
</span><span class='line'><span class="na">sonar.my.property</span><span class="o">=</span><span class="s">value</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的配置项根据名字和说明大概知道是做什么用的了，填上自己项目中对应的值即可。然后打开cmd窗口，去到你的项目根目录下，执行sonar-runner命令，这样sonar就开始分析你的项目代码了，分析完成之后，在浏览器中刚才那个9000端口地址的网页中就可以看到你的项目了。</p>

<h3>安装Javascript插件</h3>

<p>使用管理员的角色登录sonar，根据这个路径进入更新中心：Settings > System > Update Center。在Available Plugins窗口找到javascript插件，点击其中的install按钮进行安装（如下图所示）。安装完后重启sonar服务器即可。</p>

<p><img src="http://zhaozhiming.github.io/images/01202231-c4477ac31ac3411686f1a4b98ae3ece1.png"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[持续交付——发布可靠软件的系统方法]]></title>
    <link href="http://zhaozhiming.github.io/blog/2013/03/05/continuous-delivery/"/>
    <updated>2013-03-05T15:53:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2013/03/05/continuous-delivery</id>
    <content type="html"><![CDATA[<p>断断续续看完了《持续交付——发布可靠软件的系统方法》一书，中间有几次由于事情太忙而中断，直到今天才把书读完。书的内容很精彩，大致分持续集成，测试和部署三大块，还有介绍包括软件开发、项目管理等其他内容。我下面介绍几个我印象比较深刻的内容。</p>

<h3>预测试提交（pretested commit）</h3>

<p>简单来说，预测试提交就是在将代码提交到代码库之前，先在本地跑一遍持续集成上的操作，比如编译，单元测试等，保证提交的代码不会破坏基本的构建，然后再将代码提交到代码库。有一些持续集成的框架已经提供了这样的功能，可以在开发人员提交代码之后先执行基本构建，如果有问题，则通知开发人员且不会提交代码到代码库；如果没问题再提交代码到代码库，在CI上跑真正的构建。如下图所示：</p>

<p><img src="http://zhaozhiming.github.io/images/04143846-935bd06aa7d74c8cba067610a4f2143a.gif">
<img src="http://zhaozhiming.github.io/images/04143855-576fc9a7738e410d8de01ee7a9212723.gif"></p>

<p>这样的好处是，如果有人的提交了破坏构建的代码（比如编译不通过，单元测试失败等），没有预测试提交的话，只能等到破坏构建的人修复了代码后，其他人才能继续提交代码；而使用了预测试提交，破坏构建的提交根本不会提交到CI服务器上去，所以也就省去了等待其他人修复的时间了。</p>

<p>但是预测试提交只是做简单的本地构建，其他比较复杂的比如UAT测试，性能测试等，可能不会放到预测试提交中执行，因为如果要执行这些操作的话，开发人员在本地提交要等待的时间就会比较长，从而影响开发效率。</p>

<h3>部署流水线：一键部署，一键回退</h3>

<p>所谓的部署流水线，就是从提交代码开始，CI服务器进行代码编译、单元测试、验收测试，然后自动化部署，接着执行集成测试，UAT测试，性能（容量）测试等操作，一般是由多个CI任务来执行，每个CI任务都有上下游关系。比如，任务A执行代码编译，单元测试操作，任务B执行自动化部署操作，任务C执行集成测试，UAT测试等操作，这3个任务间的关系是：先执行任务A，执行完了再执行任务B，最后执行任务C，像生产流水线一样，组成了这样的一个部署流水线。最后产生的结果可能是一个完成了完整测试的一个产品交付物，或是将交付物部署到了生产环境上。</p>

<p>一般的持续集成只是在开发环境使用（像我目前所在的公司），而书中提到的部署流水线还包括了测试环境和类生产环境的部署。测试环境和类生产环境的部署不是由CI服务器自动触发的，而是有相关的操作人员（比如部署人员或者运营人员）通过点击相应的按钮来完成自动部署的操作，即一键化操作。这里的自动部署还可以选择产品交付物（ear、war或jar包）的某一个版本来进行部署，而不是简单的部署最新版本。</p>

<p>除了一键部署，还有一键回退。如果自动部署过程中有异常问题，或者是部署到指定环境后验证出现问题，操作人员可以通过点击相应按钮进行版本回退的操作，即一键回退。同样的，回退也可以选择相应要回退的交付物版本来进行回退，而不是简单的回退到上一个版本。</p>

<p>目前有一些CI工具已经支持了这些操作，比如ThoughtWorks的Go系统等。</p>

<h3>蓝绿发布，无停机发布</h3>

<p>无停机发布版本有很多种方法，这里只介绍蓝绿发布的方法。所谓的蓝绿发布，指的是系统的两个版本，蓝色的表示已经在生产上运行的版本，绿色表示即将发布的新版本。首先将两套版本的系统都启动起来，现有的用户请求连接的还是旧的蓝色版本，而新的绿色版本启动起来后，观察有没有启动的异常，或者其他一些异常，如果没有问题的话，再将现有的用户请求连接到新的绿色版本。对于用户来说，版本的切换是透明的，系统在发布过程中没有中断过。这样就达到了无停机发布的目的。</p>

<p>如果切换到新的绿色版本后，发现有故障或者异常，可以随时切换到旧的蓝色版本，这样同样可以达到无停机回滚的目的。但是要注意的是，在使用新的绿色版本过程中发现异常需要回滚，这时用户已经使用系统而产生了一些数据，这时候需要在回滚的同时，将数据同步到旧的蓝色版本环境中，或者根据判断是否放弃这些数据。也可以在绿色版本发布后，先用小众的用户做一些操作，如果发现没有问题，再将所有用户请求切换到绿色版本中来。</p>

<h3>坚持主干修改，不推荐分支操作</h3>

<p>在日常的开发中，经常会遇到这样一种情况。系统的一个版本即将发布生产，这个时候只能做一些测试工作和严重Bug的修复，而新的功能需求又需要继续开发，如果在现有的代码中继续修改的话，可能会影响新版本的发布。通常在这种情况下，很多开发团队会选择在版本控制管理器上拉一个分支出来，在新的分支上做新需求的开发，而在老的分支上做系统测试和bug修复，老的分支最终会发布到生产上。</p>

<p>首先说下这种做法有什么问题。新拉出来的分支最终是要合并到老的主干分支上去的，如果合并的间隔时间很长，到了合并代码的时候就会出现很多问题，甚至有些功能可能需要在老的分支上重新实现。第二个问题，新分支如何确保没有问题？如果已经有持续集成环境的话，对于新的分支就需要重新再搭建一套持续集成环境来跑每天提交的代码，增加了人力和资源的消耗。最终分支被合并到主干后，分支是要被废弃掉的，所以可以说分支的代码是一种开发上的浪费，即使它最终被合并到主干上。总的来说，分支操作跟持续集成是对立的，如果是只有一套持续集成环境，就必须频繁地合并分支代码到主干才不会有问题，但一般合并的时间都会比较长，因为要发布的主干代码要等到发布后才允许合并；如果有多套持续集成环境，又需要增加相关的人力去维护，等分支被合并到主干后，新增的持续集成环境也不需要了，这又是一种资源的浪费。</p>

<p>所以推荐的做法是坚持在主干上做修改，而不是拉分支。如何在主干上做大动作的修改，而又能确保不会破坏即将发布的功能，书上介绍了很多方法，包括“提取抽象层”、将大的修改分解成多而小的修改等，后者可以让每一次提交的小修改都可以通过持续集成上面的各种测试，从而保证主干上的功能不被破坏。这样做的好处是，你始终只需要维护一套代码，不需要做额外的合并工作，不会产生合并代码后的问题，而在持续集成上始终对主干代码进行构建，一旦有问题可以马上发现，缺陷发现的越早修复的成本也就越低。</p>

<h3>小结</h3>

<p>此书是TW公司的人出的，是很多战斗在一线的开发人员的经验总结，也是获得 jolt 大奖的书籍。有些内容比较深，需要有多年开发经验才好理解，正在实施敏捷或者持续集成的同学可以找来看看，一定会对你的工作有所帮助的，谢谢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jenkins插件开发（四）-- 插件发布]]></title>
    <link href="http://zhaozhiming.github.io/blog/2013/02/04/jenkins-plugins-develop-part-4/"/>
    <updated>2013-02-04T20:47:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2013/02/04/jenkins-plugins-develop-part-4</id>
    <content type="html"><![CDATA[<p>上一篇blog介绍了插件开发中要注意的一些问题， 我们再来介绍插件开发完成后，如何上传到jenkins的插件中心（这里假设你的代码是放在github上的，使用svn或其他版本管理工具的请参考其他文章）。</p>

<h3>组织授权</h3>

<p>首先去到google group（被伟大的GFW和谐了，只能翻墙访问，如何翻墙不在这里讨论）的jenkins开发列表（jenkinsci-dev@googlegroups.com）里发帖告诉组织者，你开发的插件id是什么，插件功能是做什么的，还有你的github用户名是什么。组织者如果觉得没问题，就会在jenkins 的github上给你创建一个以你插件名称命名的代码库，然后在github上将你拉入jenkins的组织，这样就可以在这个代码库上添加你的插件代码了。如果你在github上已经有了自己插件的代码库，也可以将地址告诉组织者，这样他会fork你的代码库，如果是这样的话你需要在更新了你原仓库的代码后，再将jenkins仓库上的代码同步。</p>

<h3>修改POM文件</h3>

<p>再来是修改项目的pom文件，需要增加一些信息，这样发布的时候才可以正确显示你的插件内容。首先是你的源码控制管理配置，增加配置如下：</p>

<figure class='code'><figcaption><span>pom.xml </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'>  <span class="nt">&lt;scm&gt;</span>
</span><span class='line'>    <span class="nt">&lt;connection&gt;</span>scm:git:ssh://github.com/jenkinsci/MYPLLUGINNAME.git<span class="nt">&lt;/connection&gt;</span>
</span><span class='line'>    <span class="nt">&lt;developerConnection&gt;</span>scm:git:ssh://git@github.com/jenkinsci/MYPLUGINNAME.git<span class="nt">&lt;/developerConnection&gt;</span>
</span><span class='line'>    <span class="nt">&lt;url&gt;</span>https://github.com/jenkinsci/MYPLUGINNAME<span class="nt">&lt;/url&gt;</span>
</span><span class='line'>  <span class="nt">&lt;/scm&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>插件的WIKI页面（后面会说明如何添加WIKI）：</p>

<figure class='code'><figcaption><span>pom.xml </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;project&gt;</span>
</span><span class='line'>  ...
</span><span class='line'>  <span class="nt">&lt;url&gt;</span>http://wiki.jenkins-ci.org/display/JENKINS/My+Plugin<span class="nt">&lt;/url&gt;</span>
</span><span class='line'><span class="nt">&lt;/project&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>还有维护人员信息：</p>

<figure class='code'><figcaption><span>pom.xml </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;project&gt;</span>
</span><span class='line'>  ...
</span><span class='line'>  <span class="nt">&lt;developers&gt;</span>
</span><span class='line'>    <span class="nt">&lt;developer&gt;</span>
</span><span class='line'>      <span class="nt">&lt;id&gt;</span>devguy<span class="nt">&lt;/id&gt;</span>
</span><span class='line'>      <span class="nt">&lt;name&gt;</span>Developer Guy<span class="nt">&lt;/name&gt;</span>
</span><span class='line'>      <span class="nt">&lt;email&gt;</span>devguy@developerguy.blah<span class="nt">&lt;/email&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/developer&gt;</span>
</span><span class='line'>  <span class="nt">&lt;/developers&gt;</span>
</span><span class='line'><span class="nt">&lt;/project&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>发布插件</h3>

<p>最简单的方式就是执行以下命令：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'> mvn release:prepare release:perform
</span></code></pre></td></tr></table></div></figure>


<p>如果发布成功（窗口提示BUILD SUCCESS 字样）就表示你的插件已经发布到jenkins的更新中心了，不过一般要等个一到半天更新中心才会更新。</p>

<p>一般第一次发布都会有一些问题，没有那么容易成功，这里再介绍一下发布过程中容易出现的问题。</p>

<p><strong>插件版本没有以-SNAPSHOT 结尾。</strong>可能有些同学会将-SNAPSHOT结尾的版本号给改成一个正式的版本号，比如1.0，如果是这样的话，发布的时候就会报错。因为jenkins 插件发布的过程中会将你的预设版本号（比如 1.0-SNAPSHOT）改成一个正式的版本号 1.0，然后提交到代码仓库，在检查插件版本号的时候，如果发现不是预设版本号（以-SNAPSHOT结尾）就会报错，所以大家不用担心自己的插件版本号命名问题，在插件发布的时候，会自动帮你修正为正式版本号的。</p>

<p><strong>发布出错回滚。</strong>如果在插件发布的过程中出错，重新再执行上面的命令是不行的，会报版本已存在的错误，需要先执行一下下面的命令来清除出错的发布信息。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'> mvn release:clean
</span></code></pre></td></tr></table></div></figure>


<p><strong>Github 无法push。</strong>发布的过程中会使用git将你的代码push到github上，有时候会报权限不允许的问题（Permission denied），那可能是你的github配置有问题，可以参考<a href="https://help.github.com/articles/generating-ssh-keys">这里</a>来设置你的SSH或者<a href="https://help.github.com/articles/error-permission-denied-publickey">这里</a>看看是否其他问题。</p>

<h3>WIKI页面</h3>

<p>发布好了你的插件之后呢，我们需要在jenkins的官网上添加关于你插件的WIKI，以便让使用你插件的用户知道插件的信息。</p>

<p>首先要在jenkins官网上申请一个帐号，申请成功之后你就可以在插件主页上添加你的插件页面了。去到插件主页面（<a href="https://wiki.jenkins-ci.org/display/JENKINS/Plugins">https://wiki.jenkins-ci.org/display/JENKINS/Plugins</a>），点击右上角的Add链接，选择page选项，就可以进入页面编写了。<br/>
在WIKI页面中写上你的插件名称，内容要加上下面的语句：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'> {jenkins-plugin-info:pluginId=your-artifact}
</span><span class='line'>{excerpt}  your plugin description  {excerpt}
</span></code></pre></td></tr></table></div></figure>


<p>your-artifact要写你的插件id，这样页面就会自动去加载插件的相关信息。excerpt里面的是你插件描述，会显示在插件主页上。</p>

<p>最后是在WIKI label上加上插件的分类，比如是UI相关的插件就写plugin-UI，报告类相关的就写plugin-report，这样在插件主页上会将你的插件归到某类插件下。</p>

<p>这里介绍编写WIKI的一个小窍门，可以先进入其他插件页面，然后点击右上角的Edit链接，这样就进入了页面的编辑页面，在这里就可以看到其他插件是如何编写的，参考一下再来编写自己的WIKI页面吧。</p>

<h3>持续集成</h3>

<p>在上传你插件代码的时候，可能你会想使用持续集成来跑你的测试案例，看看上传的代码是否有破坏原有的功能。没有问题，可以使用BuildHive@CloudBees来为你Github上的代码做持续集成。</p>

<p>使用很简单，先进入这个网址<a href="https://wiki.jenkins-ci.org/display/JENKINS/Plugins">https://buildhive.cloudbees.com/job/jenkinsci/</a>，然后使用你的github帐号登录，接着勾选你想要做持续集成的github项目。这样该项目每次提交代码之后，BuildHive@CloudBees就会为你做持续集成，如果有问题的话会发邮件通知你。  <br/>
到这里，jenkins插件开发的所有介绍已经全部结束了，之前做插件开发的时候查到一些中文资料，都是一些比较入门的内容，所以自己就想写一个比较全面的介绍，希望这一系列的文章可以帮到你，谢谢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jenkins插件开发（三）-- 插件编写]]></title>
    <link href="http://zhaozhiming.github.io/blog/2013/02/03/jenkins-plugins-develop-part-3/"/>
    <updated>2013-02-03T20:18:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2013/02/03/jenkins-plugins-develop-part-3</id>
    <content type="html"><![CDATA[<p>在上一篇blog 中我们介绍了如何创建我们第一个jenkins插件，在这一篇blog继续介绍在开发我们的插件过程中需要注意的一些问题。</p>

<h3>扩展点选择</h3>

<p>Jenkings插件是基于扩展点来实现的，比如基于Builder这个扩展点，那这个插件的功能就是一个构建插件，类似ant-builder（使用ant来执行构建脚本）。Jenkins插件的扩展点有很多，具体可以查询<a href="https://wiki.jenkins-ci.org/display/JENKINS/Action+and+its+family+of+subtypes">这里</a>。该网页列出了Jenkins所有的扩展点，点击每个扩展点下面Implementations，会列出该扩展点对应的实现类。找到实现类的源码就可以知道具体怎么使用该扩展点了，大部分的代码在github上都可以找到。在前面创建的HelloWorld插件是一个基于Builder扩展点的插件，可以在job 配置页面的Build 中增加该插件，以后每次Job每次构建的时候就会去调用该插件了。</p>

<h3>Action介绍</h3>

<p>Action是插件用来在Job或Build页面增加功能的一种主要方式，是Jenkins最常用的一个扩展点。从下图中可以看出什么是Action，就是页面左边菜单栏的一个菜单项，还可以在右边的主页面显示相应的功能。</p>

<p><img src="https://wiki.jenkins-ci.org/download/thumbnails/58001011/actions.png"></p>

<p>每个继承了Action这个扩展点的插件都要实现3个方法，方法如下：</p>

<figure class='code'><figcaption><span>Action.java </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Action</span> <span class="kd">extends</span> <span class="n">hudson</span><span class="o">.</span><span class="na">model</span><span class="o">.</span><span class="na">ModelObject</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span> <span class="nf">getIconFileName</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span> <span class="nf">getDisplayName</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span> <span class="nf">getUrlName</span><span class="o">();</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>第一个是菜单项图片，第二个是菜单名称，第三个是菜单链接。</p>

<p>Action分瞬时和持久2种，这里主要介绍的是瞬时的Action。瞬时的Action可以随时废弃，让另外一个新的Action来取代，适合一些每次构建都要执行操作的插件，但不适合需要保存持久数据的插件。</p>

<p>在Jenkins官网的插件开发指南中，推荐使用Transient***ActionFactory系列的继承点， 有TransientViewActionFactory，TransientProjectActionFactory，TransientBuildActionFactory等，使用该系列的继承点，只需要简单的覆写父类的 createFor方法，就可以实现创建瞬时Action的目的，可以根据不同的需要创建Job，Build，View的Action。</p>

<p>更多内容可以参考<a href="https://wiki.jenkins-ci.org/display/JENKINS/Action+and+its+family+of+subtypes">这里</a>。</p>

<h3>Jelly页面</h3>

<p>Jenkins插件开发中涉及到页面的开发，比如Job的配置页面，相关插件需要加上相关的配置开关，配置参数时，就需要有一个配置页面来做相应的显示。插件开发中用到的页面是Jelly页面，在第一篇blog中介绍了IDEA中关于jelly的插件，使用该插件可以更加方便 Jelly页面的编写。</p>

<p>Jelly页面的简单例子就不介绍了，官网上都有，这里简单介绍一下Jelly页面相关的一些标签。与JSTL类似，Jelly也有自己的一些标签，如下：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;j:jelly</span>
</span><span class='line'>   <span class="na">xmlns:j=</span><span class="s">&quot;jelly:core&quot;</span>
</span><span class='line'>   <span class="na">xmlns:st=</span><span class="s">&quot;jelly:stapler&quot;</span>
</span><span class='line'>   <span class="na">xmlns:d=</span><span class="s">&quot;jelly:define&quot;</span>
</span><span class='line'>   <span class="na">xmlns:l=</span><span class="s">&quot;/lib/layout&quot;</span>
</span><span class='line'>   <span class="na">xmlns:t=</span><span class="s">&quot;/lib/hudson&quot;</span>
</span><span class='line'>   <span class="na">xmlns:f=</span><span class="s">&quot;/lib/form&quot;</span>
</span><span class='line'>   <span class="na">xmlns:i=</span><span class="s">&quot;jelly:fmt&quot;</span>
</span><span class='line'>   <span class="na">xmlns:p=</span><span class="s">&quot;/lib/hudson/project&quot;</span><span class="nt">&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>比如想使用jelly:core标签，就可以在页面中直接使用 j:XX来调用标签的相关功能，其他标签同样按照这个方式来使用。其中jelly:core是常用的功能，比如设置变量，循环，判断等功能。jelly:layout是分层相关的标签，/lib/hudson是jenkins相关的功能，比如设置Job页面图标，Build页面图标等。更多标签相关的内容可以参考<a href="https://jenkins-ci.org/maven-site/jenkins-core/jelly-taglib-ref.html">这里</a>。</p>

<h3>配置文件</h3>

<p>Jenkins插件开发中还涉及到一类文件，就是配置文件。配置文件不仅可以在Jelly页面中使用，而且可以在Java文件中使用，不过在Java文件中使用的话需要先将配置文件编译成对应的Java文件。</p>

<p><strong>如何在Jelly页面中使用配置文件？</strong>首先要在Jelly页面所在的文件夹中放置配置文件，比如 页面在这里dir/myAction.jelly，那么页面对应的配置文件就应该在dir/myAction.properties。注意，配置文件名字需要和页面名字相同，这样页面才可以找到对应的配置文件。比如有个Jelly页面如下：</p>

<figure class='code'><figcaption><span>demo.jelly </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'>    <span class="cp">&lt;?jelly escape-by-default=&#39;true&#39;?&gt;</span>
</span><span class='line'>    <span class="nt">&lt;j:jelly</span> <span class="na">xmlns:j=</span><span class="s">&quot;jelly:core&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>        <span class="nt">&lt;th&gt;</span>${\%allBuildsColumnHeader}<span class="nt">&lt;/th&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/j:jelly&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>其对应的配置文件内容如下：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='properties'><span class='line'><span class="na">allBuildsColumnHeader</span><span class="o">=</span><span class="s">mean time to repair for all history</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样配置了以后，展示Jelly 页面时就可以自动调用配置文件里面的内容了。</p>

<p><strong>如何在Java文件中使用配置文件？</strong>一般插件所用的Java配置文件名称都叫做Messages.properties，文件保存在resources目录下。比如我们的插件包结构是jenkins.plugins.myplugin，那么Messages.properties文件就保存在 resources/jenkins/plugins/myplugin/目录下。</p>

<p>如果Java 文件中想要使用配置文件里面的值，需要先执行mvn pacakge命令，执行之后，以上面的例子为例，在target目录下会产生generated-sources/localizer/jenkins/plugins/myplugin/Messages.java这个Java文件，如果配置文件里面有这样的一个配置项：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='properties'><span class='line'><span class="na">allBuildsColumnHeader</span><span class="o">=</span><span class="s">mean time to repair for all history</span>
</span></code></pre></td></tr></table></div></figure>


<p>那么Messages.java里面就会产生这样的2个方法：</p>

<figure class='code'><figcaption><span>Message.java </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'>   <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * mean time to repair for all history</span>
</span><span class='line'><span class="cm">     * </span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="n">String</span> <span class="nf">allBuildsColumnHeader</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">holder</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">&quot;allBuildsColumnHeader&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * mean time to repair for all history</span>
</span><span class='line'><span class="cm">     * </span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Localizable</span> <span class="nf">_allBuildsColumnHeader</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="k">new</span> <span class="nf">Localizable</span><span class="o">(</span><span class="n">holder</span><span class="o">,</span> <span class="s">&quot;allBuildsColumnHeader&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样在Java文件中就可以直接调用这2个方法了，一般是调用第一个方法。</p>

<p><strong>多语言配置。</strong>配置文件的文件名如果不带后缀就是内容是英语的配置文件，比如Messages.properties。如果想让你的插件可以在不同的国家语言下都显示正常的话，就需要将你的配置文件复制多份，在名字后面加上不同的后缀，然后内容换上相关语言的内容。</p>

<p>比如，以上面例子为例，中文的配置文件名称就是Messages_zh_CN.properties，配置文件的页面也要换上相应的中文ASCII编码，这样就可以在中文系统环境下显示中文内容了。如何将中文转ASCII码？可以直接使用Java Home里面的native2ascii命令。</p>

<h3>开发经验</h3>

<p>在开发Jenkins插件的过程中自己摸索了一些方法，在这里介绍一下，以免让其他同学走弯路。<br/>
首先是去到Jenkins的<a href="https://wiki.jenkins-ci.org/display/JENKINS/Extend+Jenkins">官网WIKI</a>。这里介绍了如何创建你的插件工程，插件扩展点，插件编码和页面如何编写等，内容比较多，但你只需要关注你需要的内容就可以了。<br/>
光看Jenkins的WIKI是不够的，有一些页面和类的用法上面没有直接给出，那肿么办呢？很简单：看源码。在github上download下jenkins的源码（<a href="https://github.com/jenkinsci/jenkins">这里</a>），在IDE里面打开Jenkins工程，比如想要查看某个jelly页面的用法，就可以在工程中搜索所有jelly页面，看看源码中的页面是怎么写的，我们再拿过来改一下就可以了。类和扩展点不知道如何写，也可以参照这个方法，通过源码了解其他扩展点子类是如何写的，然后再写出自己的插件。<br/>
可能在jenkins的源码中还是找不到扩展点的用法，那怎么办呢？这个时候可能就需要去参考其他插件是如何写的了，幸运的是，大部分插件的代码现在都放在了github上，我们可以通过了解其他插件来写出自己的插件。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jenkins插件开发（二）-- HelloWorld]]></title>
    <link href="http://zhaozhiming.github.io/blog/2013/02/02/jenkins-plugins-develop-part-2/"/>
    <updated>2013-02-02T18:35:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2013/02/02/jenkins-plugins-develop-part-2</id>
    <content type="html"><![CDATA[<p>在上一篇blog中我们讲了如何搭建jenkins插件的开发环境，接下来介绍如何开发我们的插件。</p>

<h3>创建HelloWorld插件</h3>

<p>学习每门新语言的时候，我们都会写一个HelloWorld程序，这里介绍的是如何创建一个Jenkins的HelloWorld插件。</p>

<h5>1、首先修改Maven的配置，将Maven的连接库修改为jenkins plugins的资源库，方便相关pom组件从jenkins上下载，修改的是 %USERPROFILE%/.m2/settings.xml文件。</h5>

<figure class='code'><figcaption><span>settings.xml </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;settings&gt;</span>
</span><span class='line'>  <span class="nt">&lt;pluginGroups&gt;</span>
</span><span class='line'>    <span class="nt">&lt;pluginGroup&gt;</span>org.jenkins-ci.tools<span class="nt">&lt;/pluginGroup&gt;</span>
</span><span class='line'>  <span class="nt">&lt;/pluginGroups&gt;</span>
</span><span class='line'>
</span><span class='line'>  <span class="nt">&lt;profiles&gt;</span>
</span><span class='line'>    <span class="c">&lt;!-- Give access to Jenkins plugins --&gt;</span>
</span><span class='line'>    <span class="nt">&lt;profile&gt;</span>
</span><span class='line'>      <span class="nt">&lt;id&gt;</span>jenkins<span class="nt">&lt;/id&gt;</span>
</span><span class='line'>      <span class="nt">&lt;activation&gt;</span>
</span><span class='line'>        <span class="nt">&lt;activeByDefault&gt;</span>true<span class="nt">&lt;/activeByDefault&gt;</span> <span class="c">&lt;!-- change this to false, if you don&#39;t like to have it on per default --&gt;</span>
</span><span class='line'>      <span class="nt">&lt;/activation&gt;</span>
</span><span class='line'>      <span class="nt">&lt;repositories&gt;</span>
</span><span class='line'>        <span class="nt">&lt;repository&gt;</span>
</span><span class='line'>          <span class="nt">&lt;id&gt;</span>repo.jenkins-ci.org<span class="nt">&lt;/id&gt;</span>
</span><span class='line'>          <span class="nt">&lt;url&gt;</span>http://repo.jenkins-ci.org/public/<span class="nt">&lt;/url&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/repository&gt;</span>
</span><span class='line'>      <span class="nt">&lt;/repositories&gt;</span>
</span><span class='line'>      <span class="nt">&lt;pluginRepositories&gt;</span>
</span><span class='line'>        <span class="nt">&lt;pluginRepository&gt;</span>
</span><span class='line'>          <span class="nt">&lt;id&gt;</span>repo.jenkins-ci.org<span class="nt">&lt;/id&gt;</span>
</span><span class='line'>          <span class="nt">&lt;url&gt;</span>http://repo.jenkins-ci.org/public/<span class="nt">&lt;/url&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/pluginRepository&gt;</span>
</span><span class='line'>      <span class="nt">&lt;/pluginRepositories&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/profile&gt;</span>
</span><span class='line'>  <span class="nt">&lt;/profiles&gt;</span>
</span><span class='line'>  <span class="nt">&lt;mirrors&gt;</span>
</span><span class='line'>    <span class="nt">&lt;mirror&gt;</span>
</span><span class='line'>      <span class="nt">&lt;id&gt;</span>repo.jenkins-ci.org<span class="nt">&lt;/id&gt;</span>
</span><span class='line'>      <span class="nt">&lt;url&gt;</span>http://repo.jenkins-ci.org/public/<span class="nt">&lt;/url&gt;</span>
</span><span class='line'>      <span class="nt">&lt;mirrorOf&gt;</span>m.g.o-public<span class="nt">&lt;/mirrorOf&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/mirror&gt;</span>
</span><span class='line'>  <span class="nt">&lt;/mirrors&gt;</span>
</span><span class='line'><span class="nt">&lt;/settings&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<h5>2、打开CMD，进入一个想要放插件工程的目录，执行以下命令。</h5>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>mvn -U org.jenkins-ci.tools:maven-hpi-plugin:create -DgroupId<span class="o">={</span>your.gound.id<span class="o">}</span> -DartifactId<span class="o">={</span>your.plugin.id<span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>命令中的 your.groud.id 和 your.plugin.id 填你插件的具体对应的值。</p>

<p>your.group.id 会形成你的包结构，比如 your.group.id=abc.def.ghi，那工程下的src/main/java 目录下会产生abc.def.ghi 这样的目录。</p>

<p>执行完命令后，该目录下会产生一个名称是{your.plugin.id}的目录，这个目录工程就是我们的HelloWorld插件工程。</p>

<h5>3、插件打包</h5>

<p>创建好工程之后，执行下面的命令可以在 target 子目录下产生一个 hpi 文件，该文件就是我们的插件文件，可以直接上传到 jenkins 的服务器。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>mvn package
</span></code></pre></td></tr></table></div></figure>


<h5>4、启动本地服务</h5>

<p>在第三步产生的 hpi 文件要上传到一个部署好的jenkins服务器才可以看到效果，我们也可以通过以下命令启动一个包含插件的本地jenkins服务。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>mvn hpi:run
</span></code></pre></td></tr></table></div></figure>


<p>执行完命令之后，在浏览器打开localhost:8080，就可以访问本地的Jenkins服务了，这里默认用的是 jetty6的 web 容器。</p>

<h5>5、运行HelloWorld插件</h5>

<p>在Job的配置页面，其中的构建子项中Add Build Step按钮，点击后下拉框中会有一个Say Hello World的选项，这个就是我们的HelloWorld 插件，选中后保存配置，进行Job构建，在构建日志中就可以看到插件的打印日志。</p>

<p>这里介绍的是新建一个插件，对已有插件进行扩展不在本次讨论范围内，更多信息可以参考<a href="https://wiki.jenkins-ci.org/display/JENKINS/Plugin+tutorial">这里</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jenkins插件开发（一）--环境搭建]]></title>
    <link href="http://zhaozhiming.github.io/blog/2013/01/31/jenkins-plugins-develop-part-1/"/>
    <updated>2013-01-31T17:42:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2013/01/31/jenkins-plugins-develop-part-1</id>
    <content type="html"><![CDATA[<p>最近写了一个jenkins插件，功能比较简单，时间主要是花在对jenkins插件框架和Maven的熟悉上。jenkins插件虽然以前也接触过一点，不过现在都忘得差不多了，这个笔记权当知识点记录，顺带介绍介绍经验。</p>

<p>首先是环境搭建，这里列一下jenkins插件开发所需工具：</p>

<ul>
<li>JDK6.0或更高</li>
<li>构建工具&mdash;Maven</li>
<li>IDE&mdash;IDEA或eclipse</li>
<li>web服务器：jetty或tomcat（可选）</li>
</ul>


<h3>Maven</h3>

<p>jenkins插件需要用到Maven这个构建工具，大家可以去Maven的官网下载：<a href="http://maven.apache.org/download.cgi">这里</a><br/>
如何安装Maven？以windows环境为例：</p>

<ol>
<li>解压下载的zip包（比如：apache-maven-3.0.4-bin.zip）到一个指定的目录（比如：D:\apache-maven-3.0.4）；</li>
<li>添加M2_HOME环境变量，指就是我们刚刚解压的目录（如何设置环境变量JAVA开发应该都懂得）；</li>
<li>添加M2这个环境变量，值是%M2_HOME%/bin，并在PATH这个环境变量的值后面追加 %M2%；</li>
<li>环境变量中确保有JAVA_HOME这个环境变量，有的话在cmd窗口可以直接用java -version打印JDK版本信息；</li>
<li>配置完所有环境变量后，在cmd窗口打印命名mvn -v，会打印出Maven和JDK的信息，这样就表示安装Maven成功了；</li>
</ol>


<p>更详细的安装说明请看<a href="http://maven.apache.org/download.cgi">这里</a>。</p>

<h3>IDE</h3>

<p>我以前的blog还介绍过IDEA，相对于eclipse我还是比较喜欢用IDEA来开发。因为IDEA已经集成了Maven的插件，所以可以直接通过项目中的pom文件打开整个项目。在IDEA主界面右边有个maven projects的区域，打开可以看到工程的各个maven命令（图1）。</p>

<p>使用IDEA还需要添加一个针对jelly页面的插件，这个插件可以对jelly文件进行语法提示和高亮显示，插件地址点击<a href="http://plugins.intellij.net/plugin/?id=1885">这里</a>，效果见图2。<br/>
图1:<br/>
<img src="http://zhaozhiming.github.io/images/29152926-97e25c38b1754deca8843030a113cb3e.png" title="图1" ></p>

<p>图2:<br/>
<img src="http://zhaozhiming.github.io/images/29152950-1f91f25eac354a75a44e34287f75cbba.png" title="图2" ></p>

<h3>Jetty(可选)</h3>

<p>其实运行插件工程的hpi:run就可以通过maven启动一个自带的Jetty6服务器，不需要额外再安装jetty服务器。但为了让我们的插件测试更接近真实环境，我们可以将做好的插件放到另外一个的Jetty服务器中，来测试插件的运行效果。</p>

<ol>
<li>去Jetty官网下载最新的Jetty包；</li>
<li>将包解压到本地目录；</li>
<li>将jenkins的war包放到解压目录中的webapps子文件夹中；</li>
<li>在解压目录的contexts子目录中增加一个xml文件，文件名是jenkins.xml（内容如下）;</li>
<li>打开CMD进入解压目录，执行java -jar start.jar命令，即可启动Jetty服务器；</li>
<li>打开浏览器，进入localhost:8080/jenkins进入jenkins主页；</li>
</ol>


<figure class='code'><figcaption><span>jenkins.xml </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;Configure</span> <span class="na">class=</span><span class="s">&quot;org.eclipse.jetty.webapp.WebAppContext&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>  <span class="nt">&lt;Set</span> <span class="na">name=</span><span class="s">&quot;contextPath&quot;</span><span class="nt">&gt;</span>/jenkins<span class="nt">&lt;/Set&gt;</span>
</span><span class='line'>  <span class="nt">&lt;Set</span> <span class="na">name=</span><span class="s">&quot;war&quot;</span><span class="nt">&gt;&lt;SystemProperty</span> <span class="na">name=</span><span class="s">&quot;jetty.home&quot;</span> <span class="na">default=</span><span class="s">&quot;.&quot;</span><span class="nt">/&gt;</span>/webapps/jenkins.war<span class="nt">&lt;/Set&gt;</span>
</span><span class='line'>  <span class="nt">&lt;Get</span> <span class="na">name=</span><span class="s">&quot;securityHandler&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>    <span class="nt">&lt;Set</span> <span class="na">name=</span><span class="s">&quot;loginService&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>      <span class="nt">&lt;New</span> <span class="na">class=</span><span class="s">&quot;org.eclipse.jetty.security.HashLoginService&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>        <span class="nt">&lt;Set</span> <span class="na">name=</span><span class="s">&quot;name&quot;</span><span class="nt">&gt;</span>Jenkins Realm<span class="nt">&lt;/Set&gt;</span>
</span><span class='line'>        <span class="nt">&lt;Set</span> <span class="na">name=</span><span class="s">&quot;config&quot;</span><span class="nt">&gt;&lt;SystemProperty</span> <span class="na">name=</span><span class="s">&quot;jetty.home&quot;</span> <span class="na">default=</span><span class="s">&quot;.&quot;</span><span class="nt">/&gt;</span>/etc/realm.properties<span class="nt">&lt;/Set&gt;</span>
</span><span class='line'>      <span class="nt">&lt;/New&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/Set&gt;</span>
</span><span class='line'>  <span class="nt">&lt;/Get&gt;</span>
</span><span class='line'><span class="nt">&lt;/Configure&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意：如果用hpi:run启动的服务，jenkins地址是：localhost:8080，而使用真实Jetty启动的服务，地址是：localhost:8080/jenkins。<br/>
到这里你的jenkins插件开发环境已经搭建好了，我们在下一篇blog再继续介绍具体的插件开发，谢谢！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[单例模式的5种形式]]></title>
    <link href="http://zhaozhiming.github.io/blog/2012/12/20/5-type-of-singleton-pattern/"/>
    <updated>2012-12-20T17:53:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2012/12/20/5-type-of-singleton-pattern</id>
    <content type="html"><![CDATA[<p>有过编程经验的朋友都知道设计模式中的单例模式，最近又重新看了一遍设计模式，今天将单例模式的几种形式介绍一下：</p>

<h3>1、懒汉形式（延迟加载）</h3>

<figure class='code'><figcaption><span>Singleton.java </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Singleton</span><span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="n">Singleton</span> <span class="n">singleton</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kd">static</span> <span class="n">Single</span> <span class="nf">newInstance</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">singleton</span><span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">singleton</span><span class="o">=</span> <span class="k">new</span> <span class="n">Singleton</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">singleton</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个是标准的单例模式，通过newInstance里面的判断来进行延迟加载单例对象，这里加了synchronized关键字可以避免多线程问题，但会影响程序性能。</p>

<h3>2、饿汉形式（贪婪加载）</h3>

<figure class='code'><figcaption><span>Singleton.java </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Singleton</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="n">Singleton</span> <span class="n">singleton</span><span class="o">=</span> <span class="k">new</span> <span class="n">Singleton</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="nf">singleton</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Singleton</span> <span class="nf">newInstance</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">singleton</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在单例对象声明的时候就直接初始化对象，可以避免多线程问题，但是如果对象初始化比较复杂，会导致程序初始化缓慢。</p>

<h3>3、双重检查加锁</h3>

<figure class='code'><figcaption><span>Singleton.java </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Singleton</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">volatile</span> <span class="kd">static</span> <span class="n">Singleton</span> <span class="n">singleton</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Singleton</span> <span class="nf">newInstance</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">singleton</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="kd">synchronized</span> <span class="o">(</span><span class="n">Singleton</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                <span class="k">if</span> <span class="o">(</span><span class="n">singleton</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                    <span class="n">singleton</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton</span><span class="o">();</span>
</span><span class='line'>                <span class="o">}</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">singleton</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个是懒汉形式的加强版，将synchronized关键字移到了newInstance方法里面，同时将singleton对象加上volatile关键字，这种方式既可以避免多线程问题，又不会降低程序的性能。但volatile关键字也有一些性能问题，不建议大量使用。</p>

<h3>4、Lazy initialization holder class</h3>

<figure class='code'><figcaption><span>Singleton.java </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Singleton</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">SingletonHolder</span> <span class="o">{</span>
</span><span class='line'>        <span class="kd">private</span> <span class="kd">static</span> <span class="n">Singleton</span> <span class="n">singleton</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Singleton</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Singleton</span> <span class="nf">newInstance</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">SingletonHolder</span><span class="o">.</span><span class="na">singleton</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里创建了一个内部静态类，通过内部类的机制使得单例对象可以延迟加载，同时内部类相当于是外部类的静态部分，所以可以通过jvm来保证其线程安全。这种形式比较推荐。</p>

<h3>5、枚举</h3>

<figure class='code'><figcaption><span>Singleton.java </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">enum</span> <span class="n">Singleton</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">singleton</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>单因素的枚举类已经实现了单例，这种方法更加简单。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IDEA12使用初体验]]></title>
    <link href="http://zhaozhiming.github.io/blog/2012/12/20/first-experience-at-idea-12/"/>
    <updated>2012-12-20T17:06:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2012/12/20/first-experience-at-idea-12</id>
    <content type="html"><![CDATA[<p>最近将开发工具IDEA升级到了12.0版本，被它新的UI界面深深吸引，看下面，很酷哦~</p>

<p><img src="http://zhaozhiming.github.io/images/20164405-12c5f44041bf43af8351e3812f69cf3b.PNG"></p>

<h3>一、下载安装</h3>

<p>在IDEA官网下载最近版本12.0，有免费的社区版，还有收费的无限制版，大家可以自行下载。</p>

<p>下载后进行安装，windows系统直接执行exe文件即可，ubuntu系统先将下载包解压，然后执行bin文件夹里面的idea.sh就可以运行了。</p>

<h3>二、使用新的UI界面</h3>

<p>安装完后的IDEA默认UI可不是上面那个，需要先去到setting里面设置，如下图：</p>

<p><img src="http://zhaozhiming.github.io/images/20165722-72e913a55f7e436b89b87bb1fe1d6126.PNG"></p>

<ol>
<li>点击进入setting窗口；</li>
<li>选择Appearance；</li>
<li>在theme里面选择Darcula，没错，新UI主题的名称就叫Darcula，设置好了保存。</li>
</ol>


<h3>三、正确设置中文乱码</h3>

<p>使用Darcula主题的时候，发现中文变成了一堆乱码，这个问题可以也可以在setting里面解决：</p>

<p><img src="http://zhaozhiming.github.io/images/20170004-5ac2c44f1bde48c2a842afd551cf9f3c.PNG"></p>

<p>同样进入setting的Appearance页面，将Override default fonts by(not recommended) 勾选上，然后选择字体，如果觉得字体太小，还可以选择字体大小。设置以后，IDEA就可以正常使用了。</p>

<p>喜欢的这个开发工具的原因是里面的重构功能非常强大，还有快捷操作也很多，可以让你少敲很多代码，很多时候一个alt + enter就可以搞定一切。希望喜欢的朋友去下来试试，用过之后你会发现比eclipse好的不是一点半点。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jacoco的原理]]></title>
    <link href="http://zhaozhiming.github.io/blog/2012/12/07/the-elements-of-jacoco/"/>
    <updated>2012-12-07T19:47:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2012/12/07/the-elements-of-jacoco</id>
    <content type="html"><![CDATA[<h2>覆盖率计数器</h2>

<p>Jacoco使用一系列的不同的计数器来做覆盖率的度量计算。所有这些计数器都是从java的class文件中获取信息，这些class文件可以（可选）包含调试的信息在里面。即使在没有源码的情况下，这种方法也可以实时有效地对应用程序进行度量和分析。在大部分情况下，收集到的信息可以映射到源码，可视化到每一行代码的粒度。但这种方法还是有一些限制。这些class文件必须使用调试信息来编译，这样才可以计算行的覆盖率和提供出源码的高亮。但不是所有的JAVA语言的结构都可以直接编译成一致的二进制代码。在这种情况下，java 编译器会创建所谓的“合成”代码，会导致产生一些不期望得到的覆盖率结果。</p>

<h4>指令（C0 Coverage）</h4>

<p>Jacoco最小的计数单元是单个java二进制代码指令。指令覆盖率提供了代码是否被执行的信息。这个度量完全独立源码格式，并且总是可用，即使class文件里面没有调试信息。</p>

<h4>分支（C1 Coverage）</h4>

<p>Jacoco也计算分支的覆盖率，包括所有的if和switch语句。这个度量计算一个方法里面的总分支数，确定执行和不执行的分支数量。分支覆盖率总是可用的，即使class文件里面没有调试信息。注意异常处理是不在分支度量里面统计的。</p>

<p>如果class文件使用调试信息编译的话，产生的覆盖率可以映射到源码行并且高亮提示：</p>

<ul>
<li>没有覆盖：在这一行中没有分支被执行（红色方块）</li>
<li>部分覆盖：这一行的分支中只有一部分被执行（黄色方块）</li>
<li>完全覆盖：这一行的所有分支都被执行（绿色方块）</li>
</ul>


<h4>圈复杂度</h4>

<p>Jacoco同样可以为每一个非抽象方法计算复杂度，最终计算出类、包和组的复杂度。根据由McCabe1996圈复杂度的定义是，在（线性）组合中，计算在一个方法里面所有可能路径的最小数目。所以复杂度可以作为度量单元测试是否有完全覆盖所有场景的一个依据。复杂度即使是在没有调试信息的情况下也可以计算。</p>

<p>圈复杂度V（G）的正式定义是基于方法的控制流图的有向图表示：</p>

<p>v(G) = E &ndash; N + 2</p>

<p>E是边界的数量，N是节点的数量。Jacoco 基于下面的方程来计算复杂度，B是分支的数量，D是决策点的数量：</p>

<p>v(G) = B &ndash; D + 1</p>

<p>基于每个分支的被覆盖情况，Jacoco也为每个方法计算覆盖和缺失的复杂度。缺失的复杂度同样表示测试案例没有完全覆盖到这个模块。注意Jacoco不将异常处理作为分支，try/catch块也同样不增加复杂度。</p>

<h4>行</h4>

<p>所有的class文件使用debug信息编译之后，就可以计算行的覆盖率信息。一行源代码是否被执行，要看这一行中是否至少有一个指令被执行。</p>

<p>由于实际上一行代码一般被编译成多个二进制代码指令，这样源码在高亮显示时，会显示成3种不同的状态：</p>

<ul>
<li>没有覆盖：这一行中没有指令被执行（红色背景）</li>
<li>部分覆盖：这一行中只有一部分指令被执行（黄色背景）</li>
<li>完全覆盖：这一行中所有指令都被覆盖（绿色背景</li>
</ul>


<h4>方法</h4>

<p>每一个非抽象方法至少包含一个指令。一个方法是否执行取决于方法中是否有至少一个指令被执行。在Jacoco中，构造器和静态初始化同样会像方法一样统计。其中一些方法可能没有可以直接对应的源码，比如默认构造器或常量的初始化命令。</p>

<h4>类</h4>

<p>一个方法是否执行取决于类中是否有至少一个方法被执行。注意Jacoco认为构造器和静态初始化都是方法。Java的接口一般包含静态初始化，所以接口也同样被认为是可执行的类。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在jenkins和sonar中集成jacoco(四)--在sonar中集成jacoco]]></title>
    <link href="http://zhaozhiming.github.io/blog/2012/12/02/use-jacoco-in-jenkins-and-sonar-part-4/"/>
    <updated>2012-12-02T14:46:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2012/12/02/use-jacoco-in-jenkins-and-sonar-part-4</id>
    <content type="html"><![CDATA[<p>首先要得到之前的单元测试和集成测试的覆盖率文件，还有对应的class文件以及单元测试的覆盖率报告，材料准备齐全之后，使用如下命令：</p>

<figure class='code'><figcaption><span>build.xml </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;taskdef</span> <span class="na">uri=</span><span class="s">&quot;antlib:org.sonar.ant&quot;</span> <span class="na">resource=</span><span class="s">&quot;org/sonar/ant/antlib.xml&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>        <span class="nt">&lt;classpath</span> <span class="na">path=</span><span class="s">&quot;${env.SONAR-ANT-TASK.JAR}&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/taskdef&gt;</span>
</span><span class='line'>
</span><span class='line'>    <span class="nt">&lt;target</span> <span class="na">name=</span><span class="s">&quot;sonar&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>        <span class="nt">&lt;sonar:sonar</span> <span class="na">key=</span><span class="s">&quot;${sonar.project.key}&quot;</span> <span class="na">version=</span><span class="s">&quot;${sonar.project.version}&quot;</span> <span class="na">xmlns:sonar=</span><span class="s">&quot;antlib:org.sonar.ant&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>            <span class="nt">&lt;sources&gt;</span>
</span><span class='line'>                <span class="nt">&lt;path</span> <span class="na">location=</span><span class="s">&quot;${src.dir}&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>            <span class="nt">&lt;/sources&gt;</span>
</span><span class='line'>
</span><span class='line'>            <span class="nt">&lt;property</span> <span class="na">key=</span><span class="s">&quot;sonar.projectName&quot;</span> <span class="na">value=</span><span class="s">&quot;jacoco_demo&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>            <span class="nt">&lt;property</span> <span class="na">key=</span><span class="s">&quot;sonar.sourceEncoding&quot;</span> <span class="na">value=</span><span class="s">&quot;UTF-8&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>            <span class="nt">&lt;property</span> <span class="na">key=</span><span class="s">&quot;sonar.dynamicAnalysis&quot;</span> <span class="na">value=</span><span class="s">&quot;reuseReports&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>            <span class="nt">&lt;property</span> <span class="na">key=</span><span class="s">&quot;sonar.surefire.reportsPath&quot;</span> <span class="na">value=</span><span class="s">&quot;${junit.dir}&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>            <span class="nt">&lt;property</span> <span class="na">key=</span><span class="s">&quot;sonar.core.codeCoveragePlugin&quot;</span> <span class="na">value=</span><span class="s">&quot;jacoco&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>            <span class="nt">&lt;property</span> <span class="na">key=</span><span class="s">&quot;sonar.jacoco.reportPath&quot;</span> <span class="na">value=</span><span class="s">&quot;${basedir}/ut.exec&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>            <span class="nt">&lt;property</span> <span class="na">key=</span><span class="s">&quot;sonar.jacoco.itReportPath&quot;</span> <span class="na">value=</span><span class="s">&quot;${basedir}/uat.exec&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>
</span><span class='line'>            <span class="nt">&lt;tests&gt;</span>
</span><span class='line'>                <span class="nt">&lt;path</span> <span class="na">location=</span><span class="s">&quot;${src.test.dir}&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>            <span class="nt">&lt;/tests&gt;</span>
</span><span class='line'>
</span><span class='line'>            <span class="nt">&lt;binaries&gt;</span>
</span><span class='line'>                <span class="nt">&lt;path</span> <span class="na">location=</span><span class="s">&quot;${build.src.class}&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>                <span class="nt">&lt;path</span> <span class="na">location=</span><span class="s">&quot;${build.test.class}&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>            <span class="nt">&lt;/binaries&gt;</span>
</span><span class='line'>
</span><span class='line'>            <span class="nt">&lt;libraries&gt;</span>
</span><span class='line'>                <span class="nt">&lt;path</span> <span class="na">location=</span><span class="s">&quot;${build.lib.dir}&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>            <span class="nt">&lt;/libraries&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/sonar:sonar&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/target&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>参数解释：</p>

<ul>
<li>sonar.dynamicAnalysis是指单元测试报告的生成方式，值为reuseReports是指给出生成好的单元测试报告路径。</li>
<li>sonar.surefire.reportsPath是指单元测试报告的路径。</li>
<li>sonar.core.codeCoveragePlugin是覆盖率插件，有jacoco,cobetura等。</li>
<li>sonar.jacoco.reportPath是单元测试覆盖率文件的路径。</li>
<li>sonar.jacoco.itReportPath是集成测试覆盖率文件的路径。</li>
</ul>


<p>更多参数可以参考这里：<a href="http://docs.codehaus.org/display/SONAR/Code+Coverage+by+Unit+Tests">单元测试</a>，<a href="http://docs.codehaus.org/display/SONAR/Code+Coverage+by+Integration+Tests">集成测试</a><br/>
在sonar 3.3的版本会自动将单元测试和集成测试的覆盖率合并，最后附上sonar上的覆盖率显示：</p>

<p><img src="http://zhaozhiming.github.io/images/2012112914305954.png"><br/>
<img src="http://zhaozhiming.github.io/images/2012112914311753.png"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在jenkins和sonar中集成jacoco(三)--使用jacoco收集集成测试的覆盖率]]></title>
    <link href="http://zhaozhiming.github.io/blog/2012/12/01/use-jacoco-in-jenkins-and-sonar-part-3/"/>
    <updated>2012-12-01T14:45:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2012/12/01/use-jacoco-in-jenkins-and-sonar-part-3</id>
    <content type="html"><![CDATA[<p>我们系统使用weblogic做服务器，集成测试框架使用的是junit+selenium。</p>

<p>首先，要把jacoco的jacocoagent.jar包放到部署应用的服务器上，接着在系统服务的JAVA_OPTIONS 后面添加如下参数：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>-javaagent:<span class="o">[</span>yourpath/<span class="o">]</span>jacocoagent.jar<span class="o">=</span><span class="nv">includes</span><span class="o">=</span>com.xxx.xxx.*,output<span class="o">=</span>tcpserver,address<span class="o">=</span>xxx.xxx.xxx.xxx,port<span class="o">=</span>xxxxx
</span></code></pre></td></tr></table></div></figure>


<p>参数解释：</p>

<ol>
<li>前面的yourpath是放jacocoagent.jar文件的目录路径；</li>
<li>includes是指要收集哪些类（注意不要关写包名，最后要写.*)，不写的话默认是*，会收集应用服务上所有的类，包括服务器和其他中间件的类，一般要过滤；</li>
<li>output有4个值，分别是file,tcpserver,tcpclient,mbean，默认是file。使用file的方式只有在停掉应用服务的时候才能产生覆盖率文件，而使用tcpserver的方式可以在不停止应用服务的情况下下载覆盖率文件，后面会介绍如何使用dump方法来得到覆盖率文件。</li>
<li>address是ip， port是端口，这是使用tcpserver方式需要的2个参数，也是后面dump方法要用到的。（这里的address我只能使用服务器的ip，如果使用其他ip，服务启动时会报错。）</li>
</ol>


<p>更多参数可以参考<a href="http://www.eclemma.org/jacoco/trunk/doc/agent.html">java agent</a>。<br/>
配置完应用服务的JAVA_OPTIONS之后，启动服务器，然后可以开始跑你的集成测试，跑完之后，实际上jacocoagent已经将覆盖率数据记录下来了，我们可以使用下面的ant任务来dump出覆盖率文件：</p>

<figure class='code'><figcaption><span>build.xml </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'>　 <span class="nt">&lt;target</span> <span class="na">name=</span><span class="s">&quot;downloadUatCoverageData&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>        <span class="nt">&lt;jacoco:dump</span> <span class="na">address=</span><span class="s">&quot;xxx.xxx.xxx.xxx&quot;</span> <span class="na">port=</span><span class="s">&quot;xxxx&quot;</span> <span class="na">reset=</span><span class="s">&quot;true&quot;</span> <span class="na">destfile=</span><span class="s">&quot;${basedir}/uat.exec&quot;</span> <span class="na">append=</span><span class="s">&quot;false&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/target&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里的address和port是刚才在JAVA_OPTIONS里面写的address和port的值，destfile是指生成的覆盖率文件路径。</p>

<p><strong>注意，这里虽然得到了集成测试的覆盖率文件，但是需要应用服务器上的类文件才能产出相应的覆盖率报告，如果类文件是其他JVM编译的，产出的报告覆盖率是0%。</strong></p>

<p>有2种方法可以得到覆盖率文件所需的class文件：</p>

<ol>
<li>将应用服务部署的包（ear或war或jar）包下载下来之后解压，即可得到对应的class文件；</li>
<li>在前面做单元测试之后，可以将class文件打成一个zip包，然后上传到服务器，最后在需要的时候去服务器上取。</li>
</ol>


<p>得到集成测试的覆盖率文件之后，结合之前取到的单元测试覆盖率文件，我们可以将2个文件合并，得到综合的覆盖率文件，命令如下：</p>

<figure class='code'><figcaption><span>build.xml </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'>　<span class="nt">&lt;target</span> <span class="na">name=</span><span class="s">&quot;mergeCoverage&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>        <span class="nt">&lt;jacoco:merge</span> <span class="na">destfile=</span><span class="s">&quot;merged.exec&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>            <span class="nt">&lt;fileset</span> <span class="na">dir=</span><span class="s">&quot;${basedir}&quot;</span> <span class="na">includes=</span><span class="s">&quot;*.exec&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/jacoco:merge&gt;</span>
</span><span class='line'>   <span class="nt">&lt;/target&gt;</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在jenkins和sonar中集成jacoco(二)--在jenkins中生成jacoco覆盖率报告]]></title>
    <link href="http://zhaozhiming.github.io/blog/2012/11/30/use-jacoco-in-jenkins-and-sonar-part-2/"/>
    <updated>2012-11-30T14:45:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2012/11/30/use-jacoco-in-jenkins-and-sonar-part-2</id>
    <content type="html"><![CDATA[<p>先要在jenkins上安装jacoco的插件，安装完成之后在job的配置项中可以增加这个选项：</p>

<p><img src="http://zhaozhiming.github.io/images/2012112911555041.png"><br/>
<img src="http://zhaozhiming.github.io/images/2012112911561356.png"></p>

<p>第一个录入框是你的覆盖率文件（exec），第二个是class文件目录，第三个是源代码文件目录。</p>

<p>配置好了之后进行构建，构建完成之后job首页就会出现覆盖率的趋势图，鼠标点击趋势图可以看到覆盖率详情，包括具体覆盖率数据和源码的覆盖率情况：</p>

<p>趋势图<br/>
<img src="http://zhaozhiming.github.io/images/2012112911373757.png" title="趋势图" ></p>

<p>覆盖率详情  <br/>
<img src="http://zhaozhiming.github.io/images/2012112911394918.png" title="覆盖率详情" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在jenkins和sonar中集成jacoco(一)--使用jacoco收集单元测试的覆盖率]]></title>
    <link href="http://zhaozhiming.github.io/blog/2012/11/29/use-jacoco-in-jenkins-and-sonar-part-1/"/>
    <updated>2012-11-29T14:45:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2012/11/29/use-jacoco-in-jenkins-and-sonar-part-1</id>
    <content type="html"><![CDATA[<p>  之前系统的持续集成覆盖率工具使用的是cobetura，使用的过程中虽然没什么问题，但感觉配置比较麻烦，现在准备改用jacoco这个覆盖率工具来代替它。接下来我介绍一下jenkins配置jacoco，并且在sonar显示单元测试和集成测试覆盖率的过程。</p>

<p>用jacoco来实现单元测试的覆盖率比较简单，在ant脚本中先增加下面的任务：</p>

<figure class='code'><figcaption><span>build.xml </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;taskdef</span> <span class="na">uri=</span><span class="s">&quot;antlib:org.jacoco.ant&quot;</span> <span class="na">resource=</span><span class="s">&quot;org/jacoco/ant/antlib.xml&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>        <span class="nt">&lt;classpath</span> <span class="na">path=</span><span class="s">&quot;${basedir}/jacoco_lib/jacocoant.jar&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'><span class="nt">&lt;/taskdef&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里要引入jacoco的jar包jacocoant.jar，增加了这个命令之后，将原有的单元测试任务用 jacoco:coverage包括起来，实例代码如下：</p>

<figure class='code'><figcaption><span>build.xml </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;target</span> <span class="na">name=</span><span class="s">&quot;unitTest&quot;</span> <span class="na">depends=</span><span class="s">&quot;test_compile&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>        <span class="nt">&lt;mkdir</span> <span class="na">dir=</span><span class="s">&quot;${junit.dir}&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>        <span class="nt">&lt;jacoco:coverage</span> <span class="na">destfile=</span><span class="s">&quot;${basedir}/ut.exec&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>            <span class="nt">&lt;junit</span> <span class="na">fork=</span><span class="s">&quot;true&quot;</span> <span class="na">forkmode=</span><span class="s">&quot;once&quot;</span> <span class="na">printsummary=</span><span class="s">&quot;on&quot;</span> <span class="na">failureproperty=</span><span class="s">&quot;unit.test.failure&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>                <span class="nt">&lt;classpath&gt;</span>
</span><span class='line'>                    <span class="nt">&lt;pathelement</span> <span class="na">location=</span><span class="s">&quot;${build.class}&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>                    <span class="nt">&lt;fileset</span> <span class="na">dir=</span><span class="s">&quot;${build.lib.dir}&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>                <span class="nt">&lt;/classpath&gt;</span>
</span><span class='line'>
</span><span class='line'>                <span class="nt">&lt;formatter</span> <span class="na">type=</span><span class="s">&quot;xml&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>                <span class="nt">&lt;batchtest</span> <span class="na">todir=</span><span class="s">&quot;${junit.dir}&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>                    <span class="nt">&lt;fileset</span> <span class="na">dir=</span><span class="s">&quot;${src.test.dir}&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>                        <span class="nt">&lt;include</span> <span class="na">name=</span><span class="s">&quot;**/*Test.java&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>                    <span class="nt">&lt;/fileset&gt;</span>
</span><span class='line'>                <span class="nt">&lt;/batchtest&gt;</span>
</span><span class='line'>            <span class="nt">&lt;/junit&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/jacoco:coverage&gt;</span>
</span><span class='line'>　　　　<span class="c">&lt;!-- 其他内容 --&gt;</span>
</span><span class='line'><span class="nt">&lt;/target&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>jacoco:coverage的destfile参数是指生成的覆盖率文件路径，不写默认文件名为jacoco.exec。另外在forkmode这个参数设置为once，可以提高你的单元测试的执行效率。</p>

<p>这样跑完单元测试后，就会在指定路径下生成覆盖率文件ut.exec（或默认的jacoco.exec，在工程根目录下）。</p>

<p>如果要在本地生成jacoco的覆盖率报告，可以增加如下任务：</p>

<figure class='code'><figcaption><span>build.xml </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;target</span> <span class="na">name=</span><span class="s">&quot;jacocoReport&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>        <span class="nt">&lt;delete</span> <span class="na">dir=</span><span class="s">&quot;${basedir}/jacoco&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>        <span class="nt">&lt;mkdir</span> <span class="na">dir=</span><span class="s">&quot;${result.jacoco.report.dir}/ut&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>        <span class="nt">&lt;jacoco:report&gt;</span>
</span><span class='line'>            <span class="nt">&lt;executiondata&gt;</span>
</span><span class='line'>                <span class="nt">&lt;file</span> <span class="na">file=</span><span class="s">&quot;${basedir}/ut.exec&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>            <span class="nt">&lt;/executiondata&gt;</span>
</span><span class='line'>
</span><span class='line'>            <span class="nt">&lt;structure</span> <span class="na">name=</span><span class="s">&quot;jacoco_demo&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>                <span class="nt">&lt;classfiles&gt;</span>
</span><span class='line'>                    <span class="nt">&lt;fileset</span> <span class="na">dir=</span><span class="s">&quot;${build.dir}&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>                <span class="nt">&lt;/classfiles&gt;</span>
</span><span class='line'>                <span class="nt">&lt;sourcefiles</span> <span class="na">encoding=</span><span class="s">&quot;UTF-8&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>                    <span class="nt">&lt;fileset</span> <span class="na">dir=</span><span class="s">&quot;${src.dir}&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>                <span class="nt">&lt;/sourcefiles&gt;</span>
</span><span class='line'>            <span class="nt">&lt;/structure&gt;</span>
</span><span class='line'>            <span class="nt">&lt;html</span> <span class="na">destdir=</span><span class="s">&quot;${result.jacoco.report.dir}/ut&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/jacoco:report&gt;</span>
</span><span class='line'><span class="nt">&lt;/target&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>生成覆盖率报告需要覆盖率文件（exec）、源码、编译后的class文件。这里导出的格式是html，还有xml和cvs 2种格式可以导出，具体参考<a href="http://www.eclemma.org/jacoco/trunk/doc/ant.html#report">jacoco:report</a>。<br/>
注意，这里的class文件和exec文件必须用同一个jvm执行，如果是用JVM A来编译class文件，然后用JVM B来生成覆盖率文件，生成出来的报告覆盖率会为0%。<strong>这一点对生成集成测试的覆盖率特别重要。</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[持续集成一天一美元]]></title>
    <link href="http://zhaozhiming.github.io/blog/2012/09/17/continuous-integration-on-a-dollar-a-day/"/>
    <updated>2012-09-17T21:53:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2012/09/17/continuous-integration-on-a-dollar-a-day</id>
    <content type="html"><![CDATA[<p>原文：<a href="http://jamesshore.com/Blog/Continuous-Integration-on-a-Dollar-a-Day.html">http://jamesshore.com/Blog/Continuous-Integration-on-a-Dollar-a-Day.html</a>
有一种持续集成，比使用像CruiseControl这样的构建服务来的更容易更便宜。实际上，它是如此简单，你可以从现在开始做这件事，不用为你还没有构建服务而感到不舒服。</p>

<p>（肮脏的小秘密？我将要告诉你的是比使用CruiseControl更好的东西!）</p>

<h3>第一步：找一台老的电脑</h3>

<p>找一台你以前用来做开发的电脑，不要太老&hellip;它需要用来跑构建程序。找一个没用的显示器和一个废弃的角落，把它连接起来，放一张破旧的椅子在前面，不需要太舒适&hellip;你不会想这里坐太久。</p>

<h3>第二步：找一只橡皮鸡(<em>不是真的鸡</em>)</h3>

<p><img src="http://www.jamesshore.com/Blog/usbchicken.jpg"><br/>
<em>我的办公室，大概在2001年</em></p>

<p>你如果想要也可以使用其他东西，比如毛绒绒的玩具。玩具要搞笑、没有菱角，这样你用力把它扔向某人时不会不小心伤害到别人的眼睛（特别是你误中他人的时候）。如果你没有合适的东西，不要让这一步搁置你的下一步行动。即兴创作，有趣就行。</p>

<p>我想<a href="http://www.cs.cmu.edu/afs/cs.cmu.edu/user/sprite/www/Origami/crane_gif.html">这个</a>有助于即兴创作，但我做不来，所以你不会也没关系。</p>

<h3>第三步：买一个桌铃</h3>

<p>那种你轻拍就会发出“叮”的铃铛。不要因为你没有一个桌铃就停止做持续集成，可以后面再做这一步。现在你已经有开始的势头了。旧电脑，就绪。插线，就绪。搞笑玩具，就绪。你离开始做持续集成已经越来越近了（如果你真的没钱，你可以完全跳过这一步（译者注：指桌铃））。</p>

<h3>第四步：让你的构建自动化</h3>

<p>噢！这是最难的一步。好消息是CruiseControl 的好处之一就是可以使你的构建自动化。更好的消息是你接下来要做的持续集成，可以做的事情比CruiseControl的自动化构建要多，并且我将帮你获得所有的这些好处。但你还是需要让你的构建自动化。</p>

<p>好吧，这个很难，我知道。如果你已经依赖你的IDE为你构建，让构建自动化可能意味着要做很多的工作。现在，你可能要创建一个批处理文件来跑你的IDE并要求它来构建。程序运行的时间太长不是件好事，所以还是回来做正确的事情吧。</p>

<p>如果你已经有了自动化检查的单元测试，比如JUnit/NUnit 测试，也将它们放到构建里面。</p>

<p>在你继续之前，走向那台旧电脑（见第一步），然后确认你的版本库中的最新代码可以成功构建。没有使用任何版本控制工具？额&hellip;好吧&hellip;放下键盘然后离开电脑。现在，跟我读：“原谅我，老天爷，我错了。我又一次没有使用版本控制来编程。我会马上下载TortoiseSvn（译者注：现在当然是git了），安装使用它。从今以后我不会再犯了。”谢谢。</p>

<p>如果一个干净运行的自动化构建超过10分钟，那么请停下来。你还没为持续集成做好准备，你需要加速你的构建。你可以做接下来的步骤，或者你可以使用CruiseControl，但真正的持续集成现在还不属于你。</p>

<h3>第五步：洗脑</h3>

<p>这在列表中绝对，毫无疑问，100%是最重要的一步。让你团队中的所有开发人员一起去到一个房间。</p>

<p>如果有人问，不，这不是开会。你将要在5分钟内完成某件事情。有用，简短，所以这不是一个会议。</p>

<p>现在，在保证没有动用武力胁迫的情况下，让每个人都同意下面的话：</p>

<blockquote><p>“从现在开始，我们版本库中的代码将一直构建成功并且可以跑过所有测试。”</p></blockquote>


<p>如果有人抱怨这个太难了，让他们知道，通过持续集成来做这个很简单。额，应该说更简单。如果他们仍然认为这太难了，可以委婉地提醒他们的工作，你知道，构建软件。</p>

<p>噢，太残酷了，还是不要说的好。啊，我刚失去了10个粉丝，呀，又一个，11个。</p>

<p>实际上，“每个人都同意这是个好主意”的部分真的非常重要。你看，能够一直依赖你的软件构建，是持续集成的革命性部分。想象一下如果你知道你刚从版本库上下下来的代码可以工作，你的生活会变得多轻松。</p>

<p>让我来讲一个小故事。我维护开源软件的一块叫NUnitAsp。去年，我开了一门课来专门将它。在讲课期间，有人要求增加一个NUnitAsp没有的功能。我看了下代码发现很容易就可以增加。所以我做了修改（花了几分钟）。然后我跑我的构建，96秒后有个新的发布文件，然后把它拿出来。真实的故事，我们甚至有一个编程奖品，我们叫它“找bug得杯具”（我们人很好，即使没有找到bug的人我们也给他杯具）。</p>

<p>好了，你的持续集成可能还没到那一步。你需要像我的那个项目一样有很好的自动化测试来构建和发布。所以让我来讲另外一个故事。在另外一个项目，没有那么成功，我们所有人在代码的不同部分上工作。虽然我们每天都很小心的检入代码，但我们没有构建整个工程或跑测试。（测试？我们没有任何自动化测试。）六个月以后，我们尝试去集成，但没有东西可以组装在一起。我们花费了一个星期才让程序跑起来。我甚至不想描述在这个过程中有多少个bug了。持续集成，即使没有好的测试，也意味着你将再次不会面对这种噩梦了。</p>

<p>我讨厌试图去说服人们相信这是个好主意。我告诉你要刷牙了吗？但你还是会每天做。这个对你有好处。不想做？那就不要做！不是我的问题。</p>

<p>12&hellip;13&hellip;14，15，16&hellip;妹的。（译者注：指粉丝流失）</p>

<p>不然怎样，如果没有让每个人都同意这样做，那么这个过程将不会有效。你还能指望什么？</p>

<h3>第六步：启动！</h3>

<p>在<a href="http://jamesshore.com/Blog/Continuous-Integration-Checklist.html">这里</a>看到可打印的清单。
你已经准备好了！让我们浏览一下预启动清单：</p>

<ol>
<li>构建电脑？就绪。</li>
<li>搞笑玩具？就绪。</li>
<li>烦人的闹铃？可选。</li>
<li>自动构建？就绪。</li>
<li>团队同意？就绪。</li>
</ol>


<p>现在，让我们开始吧！</p>

<p>首先，每天至少检入代码2次。这是“持续”的部分。当你熟练以后，你将每1~2个小时检入一次。</p>

<p>在获取版本库的最新代码之前，看下有没有人手里有橡皮鸡。如果有，先等他们把代码检入。</p>

<p>当你检入时，遵循以下步骤：</p>

<p>A 在本地跑构建/测试脚本，确认100%通过。 <br/>
B 把橡皮鸡从它原来的地方拿过来。如果橡皮鸡不在原地，找一下看在谁那里，然后一直烦着他们直到他们检入代码。<br/>
C 从版本库下载最新代码然后再次运行构建脚本。如果没有运行成功，你知道刚下的代码有问题。发发牢骚抱怨一下，然后找到最后检入代码的那个人帮你解决问题。解决问题后重新开始。<br/>
D 检入你的代码。<br/>
E 走向那台破旧的构建电脑，从版本库获取最新代码，再次运行构建脚本。如果没有运行成功，将你检入的代码还原。没成功的原因，可能是你安装了一些新的软件，或者修改了一个环境变量，或者设置注册表环境，或者忘记添加文件到版本库，或者其他原因。不管怎样，你需要在你的电脑上修复这个问题然后重新试一次。你可以暂时保留橡皮鸡，但如果其他人需要你要还回去（然后重新开始）。<br/>
F 让铃铛响起来。（其他人会为你鼓掌，或以其他方式为你高兴。）把橡皮鸡放回去，你已经做完了。</p>

<p>顺便说一下，当步骤E失败了，你可能会冒险在构建机器上直接修复问题，但如果你这样做了，下一个可怜的家伙下载了最新代码后将会构建失败。</p>

<p>最后，但并非最不重要：保持你的构建时间在10分钟之内，少于5分钟更好。如果运行时间太长，这个过程将不再是一件愉快的事情而是痛苦的开始。而且一般来说快速构建对你有好处，不管怎样，因为速度慢的构建往往意味着测试方法的缺陷。</p>

<h3>为什么比 CruiseControl 好？</h3>

<ol>
<li>代码在版本控制中总是周期性地可以构建和通过测试。</li>
<li>如果出错了，你知道问题出在哪里。要么是你的代码（在步骤A失败了），要么是其他人的代码（在步骤C失败了），或者是环境改变了（在步骤E失败了）。反正你可以找到原因，让修复问题更简单。</li>
<li>当其他人没有等CruiseControl 跑完构建就跑去吃午饭时，你不用再去修复其他人引起的构建失败。</li>
<li>你会让构建运行的时间保持简短（长时间运行的构建会让你痛苦），这意味着测试写得更好，使设计更佳。</li>
</ol>


<h3>高级课程</h3>

<p>一旦你让基础设施工作起来了，你可以继续真正完善你的持续集成的使用。一个可选的做法是让你的构建独立起来，换句话说，你构建所需的所有东西就只是你的源控制，一旦你得到代码了，你就可以断开网络连接去构建。这个好处是让你的构建更可信，允许你轻易地去构建老版本。这也有助于找出数据库配置和迁移的错误。</p>

<p>真正给力的测试也是一个好的选择。如果你真的拥有给力的测试，那么你可以盖着帽子好好休息了。</p>

<p>我同样喜欢让我的构建脚本来构建一个安装包。人们经常从他们的测试和集成过程中拿掉安装程序，然后忍受花费额外时间来构建一个安装包。这是快速构建带来的众多好处之一，让你做这件事情更容易，虽然自动测试安装程序是一件痛苦的事情。</p>

<p>嗯&hellip;我讨厌承认&hellip;安装CruiseControl 也是一个好主意，等你从高级课程毕业了再接触比较好。而现在，你已经真正做到熟悉（持续集成）基础（团队同意，快速测试，永不破坏的构建），你已经不大可能回到坏实践中去了。</p>

<p>最后祝你好运！别忘了给我一美元。</p>

<p><em>相关材料：</em></p>

<ul>
<li><a href="http://www.martinfowler.com/articles/continuousIntegration.html">Continuous Integration</a> (Martin Fowler)</li>
<li><a href="http://jamesshore.com/Blog/Red-Green-Refactor.html">Red-Green-Refactor</a> (James Shore)</li>
<li><a href="http://jamesshore.com/Blog/Continuous-Integration-is-an-Attitude.html">Continuous Integration is an Attitude, Not a Tool</a> (James Shore)</li>
<li><a href="http://blogs.msdn.com/mswanson/articles/169058.aspx">Automated Continuous Integration and the Ambient Orb</a> (Michael Swanson)</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[读《丰田生产方式》——联系敏捷开发的思考]]></title>
    <link href="http://zhaozhiming.github.io/blog/2012/08/06/read-toyota-product-method/"/>
    <updated>2012-08-06T10:16:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2012/08/06/read-toyota-product-method</id>
    <content type="html"><![CDATA[<p>平时工作和同事讨论敏捷，曾多次听到丰田的精益思想，说是很多敏捷的想法都是从丰田的精益思想中得来的，后来在Kent Beck的《解析极限编程》里看到有这样一本书是讲丰田的精益思想的，找来看了一下，发现书中讲的一些思想或者实践和敏捷开发很相似，下面我就讲讲我对于丰田生产方式和敏捷开发的一些联系。</p>

<h2>一、逆向思维，由生产的最后一道工序为起点，从后往前推进。</h2>

<p>丰田生产方式的两大支柱是准时化和自动化。准时化（Just In Time）是指通过流水作业装配一辆汽车的过程中，所需零部件在需要的时刻，以需要的数量，不多不少的送到生产线的旁边。如何达到这种不多不少的状态呢？丰田的做法是由生产的最后一道工序为起点，从后往前推进。这样以最后要生产的汽车数量，就可以推测所需的零部件各是多少，从而达到降低浪费的目的。</p>

<p>在敏捷开发中，我们如何做到准时化？从相关的敏捷实践来看，测试驱动开发（TDD）就是达到这一目的的过程。先从原始需求上面得到一个个的Story，Story规定了需求的入口和出口，然后再驱动出测试案例，最后由测试案例驱动出产品代码，这样就能保证产品代码的功能是包括了原始需求所要求的功能，但又避免产生过渡设计。这个也是减少浪费的一种过程。</p>

<h2>二、每个工人都有一根警报线，在生产过程中发现产品有问题，随时拉线让整个生产线停止，等待解决问题后再恢复生产。</h2>

<p>丰田生产方式的另外一个支柱是自动化。丰田使用了很多自动化机器，但自动化的标准不是简单的去使用机器，而是实现人的自动化。丰田几乎所有的机器设备都装有自动停止装置，平时机器自动运转的时候用不到人，如果生产过程中发现问题，人会去停止机器，然后修复问题，重新启动机器。如果在生产过程中发现问题没有及时停止生产，那就可能生产出大量的残次品，这些残次品无法装配到汽车上，是一种很大的浪费。</p>

<p>在敏捷开发中，持续集成体现的就是这种自动化思想。在持续集成的过程中，一旦发现问题（比如单元测试跑失败了），服务器就会马上停止构建，并通知相关的开发人员进行问题修复，等问题修复完成后，再重新进行构建。这样每当问题出现，我们就可以以最小的代价找到问题的根源，然后修复它。如果等问题遗留到后面的测试阶段或者生产阶段，再去找问题的根源，所需的代价就要大的多得多。</p>

<p>光有持续集成的服务器还不行，服务器不会自己去编译、测试、部署，所有这些行为都需要人去开发出相应的脚本，然后在服务器上运行，这就是所谓的“人的自动化”。开发人员应该将所有可以自动化的东西都做成自动化，让单元测试自动化，集成测试自动化，部署自动化，总之一个目的，减少浪费，这也是丰田生产一直追求的目标之一。</p>

<h2>三、看板</h2>

<p>看板在丰田生产中是一种工具，在生产中起到一个传递情报和指令的作用。</p>

<p>敏捷开发很好的运用了看板。有过敏捷开发经验的同学应该知道，敏捷中的看板就是整天摆在你跟前的那块白板，白板上将开发过程分成好几个阶段，每个阶段上面贴着该阶段下的开发任务，通过白板可以随时了解项目的进展。</p>

<h2>其他思想和实践</h2>

<p>除了和敏捷开发有这些联系外，丰田生产方式还有一些思想和实践适合软件开发。</p>

<h4>一人掌握多种技能，每个人都是多面手。</h4>

<p>由于历史和文化的原因，美国的的制度是，车工始终是车工，焊工永远是焊工；日本的制度是，工人既能操作车床，也能开钻床，而且能焊接，能够学会和掌握多种技能。</p>

<p>两种制度孰优孰劣很难确定，但个人认为，在软件开发高速发展的今天，开发人员应该要有更高的要求。开发人员所掌握的技能不仅仅是会编写产品代码，还要会写单元测试，会部署，会搭建环境等等。比如在缺少测试人员的情况下，开发人员可以自己测试，依靠开发的编程技能可以写出更好的测试代码。要能够快速学会和掌握多种技能。</p>

<h4>反复问5个为什么</h4>

<p>比如一台机器不转动了，你就要问：</p>

<ol>
<li>为什么机器停了？——“因为超负荷，保险丝断了。”</li>
<li>“为什么超负荷了呢？”——“因为轴承部分的润滑不够。&#8221;</li>
<li>&ldquo;为什么润滑不够？”——“因为润滑泵吸不上油来。”</li>
<li>“为什么吸不上油来呢？”——“因为油泵轴磨损，松动了。”</li>
<li>“为什么磨损了呢？”——因为没有安装过滤器，混进了铁屑。”</li>
</ol>


<p>通过问5个为什么就可以知道需要安装过滤器了。如果问题问的不彻底，可能是加上润滑油，或者换上油泵轴了事，这样等过了一段时间后问题还是会出现。丰田生产方式可以说是丰田人反复问5个为什么才创造出来的。</p>

<h4>拥抱小团队，不要大块头</h4>

<p>团队合作高于一切，由于合作或其他种种原因，人少的团队反而容易取胜。小船容易转舵，大船步履阑珊，小团队的灵活性更强，这也符合敏捷开发的原则——要做到简洁。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《Agile Web Development with Rails》读后感--rails基于web设计的best practices]]></title>
    <link href="http://zhaozhiming.github.io/blog/2012/08/05/best-practices-in-rails-with-web-app-design/"/>
    <updated>2012-08-05T18:18:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2012/08/05/best-practices-in-rails-with-web-app-design</id>
    <content type="html"><![CDATA[<p>最近看完《Agile Web Development with Rails》一书，受益匪浅。书中先是用一个简单的web应用带你进入Rails的世界，然后在你大致熟悉之后，再带你了解Rails的一些细节，比如ActiveRecord，ActiveController等。最让我觉得Rails美的是其中的一些best practices，这些都可以很好地借鉴到平时的开发中去。下面我简单举几个在Rails中我认为比较好的一些best practies。</p>

<h3>数据库迁移</h3>

<p>在Rails中，SQL脚本可以通过命令来生成，生成的脚本以时间戳加意图命名，比如创建表的SQL脚本文件可能是“20120529151027_create_products.rb&#8221;，加时间戳可以让人一眼就知道脚本的执行顺序，实际上Rails在也是根据时间戳来执行脚本的。创建完脚本后只要简单的执行&#8221;rake db:migrate&#8221;命令即可完成脚本的执行，在Rails中会有脚本执行的记录，已经执行过的脚本不会重复执行。另外，在每个SQL脚本中，不仅有执行的操作，还有回滚的操作。比如：</p>

<figure class='code'><figcaption><span>demo.rb </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">AddPriceToLineItem</span> <span class="o">&lt;</span> <span class="ss">ActiveRecord</span><span class="p">:</span><span class="ss">:Migration</span>
</span><span class='line'>    <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">up</span>
</span><span class='line'>    <span class="err">　　</span><span class="n">add_column</span> <span class="ss">:line_items</span><span class="p">,</span> <span class="ss">:price</span><span class="p">,</span> <span class="ss">:decimal</span><span class="p">,</span> <span class="ss">:precision</span> <span class="o">=&gt;</span> <span class="mi">8</span><span class="p">,</span> <span class="ss">:scale</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="ss">:default</span> <span class="o">=&gt;</span> <span class="mi">0</span>
</span><span class='line'>
</span><span class='line'>    <span class="err">　　</span><span class="n">say_with_time</span> <span class="s2">&quot;Updating prices...&quot;</span> <span class="k">do</span>
</span><span class='line'>      <span class="err">　　</span><span class="no">LineItem</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="ss">:all</span><span class="p">)</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">lineitem</span><span class="o">|</span>
</span><span class='line'>        <span class="err">　　</span><span class="n">lineitem</span><span class="o">.</span><span class="n">update_attribute</span> <span class="ss">:price</span><span class="p">,</span> <span class="n">lineitem</span><span class="o">.</span><span class="n">product</span><span class="o">.</span><span class="n">price</span>
</span><span class='line'>         <span class="k">end</span>
</span><span class='line'>    <span class="err">　　</span><span class="k">end</span>
</span><span class='line'>  <span class="err">　</span><span class="k">end</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">down</span>
</span><span class='line'>    <span class="err">　　</span><span class="n">remove_column</span> <span class="ss">:line_items</span><span class="p">,</span> <span class="ss">:price</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里的up方法是正常执行时的操作，down方法则是回滚时所做的操作。如果发现执行的脚本有问题，简单地执行“rake db:rollback&#8221;即可回退到脚本执行前的状态。</p>

<h3>Convention over Configuration</h3>

<p>在上面创建的脚本中可以看到，Rails的表名都是复数形式，因为Rails认为每张表都会存放很多个同一类型的数据，因此是复数，这种清晰的命名规范不仅体现在数据库，还有其他很多地方。比如，model的文件名都是单数形式存在，controller都是以复数形式存在。Rails将MVC各模块连接起来就是通过COC约定，举个简单例子，product的model文件是product.rb，controller文件是products_controller.rb，而view文件则是放在对应的product文件夹里面，每个view文件名以action方法名开头，这样在写代码的时候就可以不用具体指定要发送给哪个controller，给哪个model存储数据，让哪个页面显示数据，只要你遵守了COC约定，Rails会帮你跳转到最合适的地方。</p>

<h3>分层的页面布局</h3>

<p>在书中的例子，作者会建议你将页面分成一个个小的局部文件。实际上Rails也是推荐你这么做的，局部文件只需以下划线开头，Rails就会帮你识别出来。小的页面文件结构简单，容易维护，比如有显示列标题的页面，其中嵌套显示具体行内容的页面，其中再嵌套分页页面文件。对比平时在工作里遇到的一个个硕大无比的jsp文件，rails的页面文件让人有了进入世外桃源的感觉。</p>

<p>Rails还有其他很多的best practices，这里只是简单的介绍。Rails框架集中了很多开发中遇到的常见问题的解决方案，而且是一些最佳的解决方案，像集中了很多经验丰富的大师智慧一样，使用Rails并学习其中的best practices，能让你在web开发上少走很多弯路。</p>
]]></content>
  </entry>
  
</feed>
