<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: websocket | Hacker and Geeker's Way]]></title>
  <link href="http://zhaozhiming.github.io/tags/websocket/atom.xml" rel="self"/>
  <link href="http://zhaozhiming.github.io/"/>
  <updated>2015-09-23T11:54:46+08:00</updated>
  <id>http://zhaozhiming.github.io/</id>
  <author>
    <name><![CDATA[赵芝明]]></name>
    <email><![CDATA[kingzzm1982@sina.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[如何在Spring中配置Websocket]]></title>
    <link href="http://zhaozhiming.github.io/blog/2015/05/11/spring-websocket-config/"/>
    <updated>2015-05-11T09:41:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2015/05/11/spring-websocket-config</id>
    <content type="html"><![CDATA[<p>{% img /images/post/2015-5/websockets.png %}</p>

<p>Websocket是HTML5的一项新技术，可以让服务端和客户端进行实时的通信，主要的使用场景有: 实时的聊天系统，对实时性要求比较高的游戏，或者金融行业对股票市场数据的及时获取等。在Spring3的时候就已经有了对Websocket的支持，不过需要一些高版本的web容器来运行，比如Tomcat7.0.47+，Jetty9等。</p>

<!--more-->


<p></p>

<p>在Spring的官网上有关于Websocket的示例工程，<a href="https://spring.io/guides/gs/messaging-stomp-websocket/">https://spring.io/guides/gs/messaging-stomp-websocket/</a>，里面简单介绍了如何通过Spring-boot来进行Websocket系统的构建。我们的例子将基于这个例子进行修改，但是是使用传统的Spring的方式进行配置。</p>

<h2>依赖包</h2>

<p>首先我们需要添加相关的依赖包:</p>

<ul>
<li>Websocket需要servlet3.1的版本</li>
<li>spring-websocket和spring-messaging是Spring关于Websocket的组件</li>
<li>使用Jackson进行json数据的处理</li>
</ul>


<p>{% codeblock build.gradle lang:groovy %}
String springVersion = &ldquo;4.1.4.RELEASE&rdquo;
String jacksonDatabindVersion = &ldquo;2.5.0&rdquo;
String jacksonVersion = &ldquo;1.9.13&rdquo;
dependencies {</p>

<pre><code>//websocket
compile("javax.websocket:javax.websocket-api:1.1")
compile("javax.servlet:javax.servlet-api:3.1.0")

//spring
compile("org.springframework:spring-messaging:" + springVersion)
compile("org.springframework:spring-websocket:" + springVersion)

//json
compile "com.fasterxml.jackson.core:jackson-databind:" + jacksonDatabindVersion
compile "org.codehaus.jackson:jackson-mapper-asl:" + jacksonVersion
compile "org.codehaus.jackson:jackson-core-asl:" + jacksonVersion
</code></pre>

<p>}
{% endcodeblock %}</p>

<h2>xml配置（类配置）</h2>

<p>我们有两种方式进行Websocket的配置，一种是通过xml文件的方式，在这里我们定义了websocket的配置信息，这样服务器往客户端发送消息就可以通过<code>/topic/xx</code>来发送，客户端则可以通过<code>/app/hello</code>来发送消息到服务端。</p>

<p>{% codeblock lang:xml %}
&lt;beans xmlns=&ldquo;<a href="http://www.springframework.org/schema/beans">http://www.springframework.org/schema/beans</a>&rdquo;</p>

<pre><code>   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:websocket="http://www.springframework.org/schema/websocket"
   xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
    http://www.springframework.org/schema/websocket http://www.springframework.org/schema/websocket/spring-websocket.xsd"&gt;

...... // other configurations

&lt;websocket:message-broker application-destination-prefix="/app"&gt;
    &lt;websocket:stomp-endpoint path="/hello"&gt;
        &lt;websocket:sockjs/&gt;
    &lt;/websocket:stomp-endpoint&gt;
    &lt;websocket:simple-broker prefix="/topic"/&gt;
&lt;/websocket:message-broker&gt;
</code></pre>

<p></beans>
{% endcodeblock %}</p>

<p>另外一种方式是通过类的方式，代码如下，功能与上面的xml配置相同:</p>

<p>{% codeblock WebSocketConfig.java lang:java %}
import org.springframework.context.annotation.Configuration;
import org.springframework.messaging.simp.config.MessageBrokerRegistry;
import org.springframework.web.socket.config.annotation.AbstractWebSocketMessageBrokerConfigurer;
import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;
import org.springframework.web.socket.config.annotation.StompEndpointRegistry;</p>

<p>@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig extends AbstractWebSocketMessageBrokerConfigurer {</p>

<pre><code>@Override
public void configureMessageBroker(MessageBrokerRegistry config) {
    config.enableSimpleBroker("/topic");
    config.setApplicationDestinationPrefixes("/app");
}

@Override
public void registerStompEndpoints(StompEndpointRegistry registry) {
    registry.addEndpoint("/hello").withSockJS();
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<h2>消息类和Controller定义</h2>

<p>Controller定义:</p>

<p>{% codeblock WebSocketConfig.java lang:java %}
import com.zzm.wechat.model.Greeting;
import com.zzm.wechat.model.HelloMessage;
import org.springframework.messaging.handler.annotation.MessageMapping;
import org.springframework.messaging.handler.annotation.SendTo;
import org.springframework.stereotype.Controller;</p>

<p>@Controller
public class GreetingController {</p>

<pre><code>@MessageMapping("/hello")
@SendTo("/topic/greetings")
public Greeting greeting(HelloMessage message) throws Exception {
    Thread.sleep(3000); // simulated delay
    return new Greeting("Hello, " + message.getName() + "!");
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>消息model的定义:</p>

<p>{% codeblock WebSocketConfig.java lang:java %}
public class Greeting {</p>

<pre><code>private String content;

public Greeting(String content) {
    this.content = content;
}

public String getContent() {
    return content;
}
</code></pre>

<p>}</p>

<p>public class HelloMessage {</p>

<pre><code>private String name;

public String getName() {
    return name;
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>在web.xml中设置controller的url前缀，这样可以避免一些页面的url被controller拦截。</p>

<p>{% codeblock web.xml lang:xml %}</p>

<pre><code>&lt;servlet&gt;
    &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/api/*&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>

<p>{% endcodeblock %}</p>

<h2>客户端页面</h2>

<p>首先下载<code>stomp.js</code>和<code>sockjs.js</code>，然后编写一个html页面进行客户端websocket的连接，并实现发送消息和接收消息的功能。我们使用SockJS的方式来创建Websocket连接，注意url要加上domain名称(这里是<code>server</code>)和<code>api</code>前缀。</p>

<p>{% codeblock demo.html lang:html %}
&lt;!DOCTYPE html>
<html>
<head></p>

<pre><code>&lt;title&gt;Hello WebSocket&lt;/title&gt;
&lt;script src="resources/sockjs-0.3.4.js"&gt;&lt;/script&gt;
&lt;script src="resources/stomp.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
    var stompClient = null;

    function setConnected(connected) {
        document.getElementById('connect').disabled = connected;
        document.getElementById('disconnect').disabled = !connected;
        document.getElementById('conversationDiv').style.visibility = connected ? 'visible' : 'hidden';
        document.getElementById('response').innerHTML = '';
    }

    function connect() {
        var socket = new SockJS('/server/api/hello');
        stompClient = Stomp.over(socket);
        stompClient.connect({}, function(frame) {
            setConnected(true);
            console.log('Connected: ' + frame);
            stompClient.subscribe('/topic/greetings', function(greeting){
                showGreeting(JSON.parse(greeting.body).content);
            });
        });
    }

    function disconnect() {
        if (stompClient != null) {
            stompClient.disconnect();
        }
        setConnected(false);
        console.log("Disconnected");
    }

    function sendName() {
        var name = document.getElementById('name').value;
        stompClient.send("/app/hello", {}, JSON.stringify({ 'name': name }));
    }

    function showGreeting(message) {
        var response = document.getElementById('response');
        var p = document.createElement('p');
        p.style.wordWrap = 'break-word';
        p.appendChild(document.createTextNode(message));
        response.appendChild(p);
    }
&lt;/script&gt;
</code></pre>

<p></head>
<body onload="disconnect()">
<noscript><h2 style="color: #ff0000">Seems your browser doesn&rsquo;t support Javascript! Websocket relies on Javascript being enabled. Please enable</p>

<pre><code>Javascript and reload this page!&lt;/h2&gt;&lt;/noscript&gt;
</code></pre>

<div>
    <div>
        <button id="connect" onclick="connect();">Connect</button>
        <button id="disconnect" disabled="disabled" onclick="disconnect();">Disconnect</button>
    </div>
    <div id="conversationDiv">
        <label>What is your name?</label><input type="text" id="name" />
        <button id="sendName" onclick="sendName();">Send</button>
        <p id="response"></p>
    </div>
</div>


<p></body>
</html>
{% endcodeblock %}</p>

<p>运行结果：</p>

<p>{% img /images/post/2015-5/websocket-run.png %}</p>

<p>浏览器console信息:</p>

<p>{% codeblock lang:sh %}
Disconnected
chrome-extension://fhhdlnnepfjhlhilgmeepgkhjmhhhjkh/js/detector.js:505 detector
chrome-extension://fhhdlnnepfjhlhilgmeepgkhjmhhhjkh/js/detector.js:506 Object
stomp.js:130 Opening Web Socket&hellip;
stomp.js:130 Web Socket Opened&hellip;
stomp.js:130 >>> CONNECT
accept-version:1.1,1.0
heart-beat:10000,10000</p>

<p>&lt;&lt;&lt; CONNECTED
version:1.1
heart-beat:0,0</p>

<p>connected to server undefined
demo.html:22 Connected: CONNECTED
heart-beat:0,0
version:1.1</p>

<blockquote><blockquote><blockquote><p>SUBSCRIBE
id:sub-0
destination:/topic/greetings</p>

<p>SEND
destination:/app/hello
content-length:14</p></blockquote></blockquote></blockquote>

<p>{&ldquo;name&rdquo;:&ldquo;zzm&rdquo;}
&lt;&lt;&lt; MESSAGE
destination:/topic/greetings
content-type:application/json;charset=UTF-8
subscription:sub-0
message-id:3657pj5u-0
content-length:25</p>

<p>{&ldquo;content&rdquo;:&ldquo;Hello, zzm!&rdquo;}
{% endcodeblock %}</p>

<h2>gradle运行jetty9</h2>

<p>gradle内置的Jetty版本是Jetty6，由于版本较低不支持websocket，所以我们测试的话需要打包并部署到Jetty9或Tomcat7.0.47+上，但我们可以通过其他gradle插件来把我们的本地服务运行到Jetty9上。这里介绍2个插件，<a href="https://github.com/akhikhl/gretty">Gretty</a>和<a href="https://github.com/bmuschko/gradle-cargo-plugin">Cargo</a>。</p>

<h4>Gretty</h4>

<p>在<code>build.gradle</code>中添加如下脚本:</p>

<p>{% codeblock build.gradle lang:groovy %}
buildscript {</p>

<pre><code>repositories {
    maven {
        url "http://maven.oschina.net/content/groups/public/"
    }
}

dependencies {
    classpath 'org.akhikhl.gretty:gretty:+'
}
</code></pre>

<p>}</p>

<p>apply plugin: &lsquo;org.akhikhl.gretty&rsquo;
// apply plugin: &lsquo;jetty&rsquo; 注意要注释掉原来的jetty插件</p>

<p>gretty {</p>

<pre><code>httpPort = 9898 // 指定web服务的http端口
servletContainer = 'jetty9' // 这里可以指定tomcat,jetty的几个版本
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>然后运行<code>gradle appRun</code>即可。</p>

<h4>Cargo</h4>

<p>在<code>build.gradle</code>中添加如下脚本，注意要先下载jetty9的安装包并解压:</p>

<p>{% codeblock build.gradle lang:groovy %}
buildscript {</p>

<pre><code>repositories {
    maven {
        url "http://maven.oschina.net/content/groups/public/"
    }
}

dependencies {
    classpath 'com.bmuschko:gradle-cargo-plugin:2.1'
}
</code></pre>

<p>}</p>

<p>apply plugin: &lsquo;com.bmuschko.cargo&rsquo;
cargo {</p>

<pre><code>containerId = 'jetty9x'
port = 9898
local {
    homeDir = file('/Users/zhaozhiming/tools/jetty-distribution-9.2.10.v20150310')
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>然后运行<code>gradle war CargoRunLocal</code>，注意首先要打出war包，然后插件会自动部署war包到Jetty9的安装目录下，这种方式不大灵活，比如一些页面的修改都需要重新部署才能进行测试。</p>

<p>最后附上Spring关于Websocket的文档链接，请见<a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html">这里</a>。</p>
]]></content>
  </entry>
  
</feed>
