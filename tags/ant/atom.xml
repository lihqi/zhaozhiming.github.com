<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: ant | Hacker and Geeker's Way]]></title>
  <link href="http://zhaozhiming.github.io/tags/ant/atom.xml" rel="self"/>
  <link href="http://zhaozhiming.github.io/"/>
  <updated>2018-04-29T16:58:02+08:00</updated>
  <id>http://zhaozhiming.github.io/</id>
  <author>
    <name><![CDATA[赵芝明]]></name>
    <email><![CDATA[kingzzm1982@sina.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[sonar在ant工程中读取单元测试和覆盖率报告]]></title>
    <link href="http://zhaozhiming.github.io/blog/2012/06/17/read-test-report-and-coverage-report-with-ant-in-sonar/"/>
    <updated>2012-06-17T08:30:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2012/06/17/read-test-report-and-coverage-report-with-ant-in-sonar</id>
    <content type="html"><![CDATA[<p>虽然sonar支持ant工程的构建，但目前最大的不足是无法在分析过程中产生单元测试和覆盖率报告，这样在sonar面板上覆盖率板块就始终没有数据。但幸运的是，sonar可以读取已经生成好的报告，让报告的内容显示在sonar的覆盖率面板上。</p>

<!--more-->


<p>
首先需要配置sonar.dynamicAnalysis属性，这个属性有3个值，分别是true, false和reuseReports，默认值是true，即进行动态分析，但只对maven工程有效，要想读取外部的报告，需要将值设置为reuseReports。</p>

<p>然后是单元测试报告的路径设置，对应的属性是sonar.surefire.reportsPath，value为junit报告的文件夹路径，这个路径下有junit生成的那些TEST-*.xml文件。</p>

<p>最后是覆盖率报告的路径设置，这个要看是用什么覆盖率工具。sonar有3种覆盖率工具的设置属性，分别是<em>jacoco，cobertura和clover</em>。像我们工程用的是cobertura，对应的属性名为<em>sonar.cobertura.reportPath</em>，其他2种分别是<em>sonar.jacoco.reportPath</em>和<em>sonar.clover.reportPath</em>。属性值和单元测试的略为不同，单元测试属性是指向文件夹，覆盖率是指向具体的覆盖率文件，比如cobertura的覆盖率文件是coverage.xml，则value应该写成“yourReportDir/coverage.xml"。</p>

<p>配置完后重新进行sonar分析即可看到覆盖率报告成产生了。下面是具体代码：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>build.xml </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">&quot;sonar.dynamicAnalysis&quot;</span> <span class="na">value=</span><span class="s">&quot;reuseReports&quot;</span> <span class="nt">/&gt;&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="c">&lt;!--unnit test--&gt;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;p&gt;&lt;property</span> <span class="na">name=</span><span class="s">&quot;sonar.surefire.reportsPath&quot;</span> <span class="na">value=</span><span class="s">&quot;[baseDir]/myReports/unitTestReportDir&quot;</span> <span class="nt">/&gt;&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="c">&lt;!--coverage--&gt;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;p&gt;&lt;property</span> <span class="na">name=</span><span class="s">&quot;sonar.cobertura.reportPath&quot;</span> <span class="na">value=</span><span class="s">&quot;[baseDir]/myReports/coverage.xml&quot;</span> <span class="nt">/&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[junit里面Test case的执行顺序]]></title>
    <link href="http://zhaozhiming.github.io/blog/2012/05/21/the-execute-order-of-junit-test-case/"/>
    <updated>2012-05-21T16:02:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2012/05/21/the-execute-order-of-junit-test-case</id>
    <content type="html"><![CDATA[<p>这里讨论的是junit在ant运行的情况，其他build工具应该也适用，但具体没试验过。</p>

<p>首先运行junit时是按照脚本中文件夹的顺序执行，如下脚本会先执行test1目录下的测试，其实是test2目录的，最后是test3目录的。</p>

<!--more-->


<p>
<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>build.xml </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;batchtest</span> <span class="na">todir=</span><span class="s">&quot;${junit.dir}&quot;</span><span class="nt">&gt;&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;pre&gt;&lt;code&gt;</span><span class="ni">&amp;lt;</span>fileset dir=&quot;${test1.dir}&quot;<span class="ni">&amp;gt;</span>
</span><span class='line'>    <span class="ni">&amp;lt;</span>include name=&quot;**/*Test.java&quot;/<span class="ni">&amp;gt;</span>
</span><span class='line'><span class="ni">&amp;lt;</span>/fileset<span class="ni">&amp;gt;</span>
</span><span class='line'><span class="ni">&amp;lt;</span>fileset dir=&quot;${test2.dir}&quot;<span class="ni">&amp;gt;</span>
</span><span class='line'>    <span class="ni">&amp;lt;</span>include name=&quot;**/*Test.java&quot;/<span class="ni">&amp;gt;</span>
</span><span class='line'><span class="ni">&amp;lt;</span>/fileset<span class="ni">&amp;gt;</span>
</span><span class='line'><span class="ni">&amp;lt;</span>fileset dir=&quot;${test3.dir}&quot;<span class="ni">&amp;gt;</span>
</span><span class='line'>    <span class="ni">&amp;lt;</span>include name=&quot;**/*Test.java&quot;/<span class="ni">&amp;gt;</span>
</span><span class='line'><span class="ni">&amp;lt;</span>/fileset<span class="ni">&amp;gt;</span>
</span><span class='line'><span class="nt">&lt;/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;p&gt;&lt;/batchtest&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>其次在同一个目录下，test case 的运行顺序是根据包名的顺序来执行的。比如：a.a.a这个包名里面的test case会比a.a.b这个包名的test case先跑。</p>

<p>再次如果是同一个目录，且在同一个包名下的，会根据类名的顺序来执行test case。比如：a.a.a.A.java会比a.a.a.B.java先执行。</p>

<p>最后如果是同个类的test case，则依照TestClass里面test case的顺序从上往下执行。</p>

<p>Junit Test case 的执行顺序有时候比较重要，可能一些test case会依赖与其他test case产生的结果才能执行，这个时候把要先执行的类按照上面的规则放在前面即可保证整个测试执行正确。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用emma时遇到的一些问题]]></title>
    <link href="http://zhaozhiming.github.io/blog/2012/03/27/some-problems-in-emma/"/>
    <updated>2012-03-27T22:05:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2012/03/27/some-problems-in-emma</id>
    <content type="html"><![CDATA[<p>今天在用使用emma的过程中遇到了几个问题，记录一下.</p>

<p><strong>1.跑junit过程中没办法产生coverage data文件，导致最后没办法出emma报告，上官网查了一下原因如下：</strong></p>

<!--more-->


<p>
<blockquote><p>I have instrumented my classes but am not getting any coverage data&hellip; <br/><br/>This question has been asked several times and in all cases the users forgot to package or deploy the instrumented versions of their classes. Please check that your build places EMMA-instrumented classes ahead of the normal application classpath at runtime.</p></blockquote>
意思是emma会根据工程里面的class文件产生自己的instrumented class，junit在跑单元测试的时候，classpath要把定义emma的class文件路径放在项目class文件路径前面，才能产生coverage data文件。</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;junit</span> <span class="err">...</span><span class="nt">&gt;</span>
</span><span class='line'>  <span class="nt">&lt;classpath</span> <span class="na">location=</span><span class="s">&quot;${emma.classes.dir}&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>  <span class="nt">&lt;classpath</span> <span class="na">location=</span><span class="s">&quot;${project.classes.dir}&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'><span class="ni">&amp;hellip;</span>
</span><span class='line'><span class="nt">&lt;/junit&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><strong>2.emma的示例代码里面，report的sourcepath属性只有一个src路径，如果项目里面有多个src路径同时要进行覆盖率检查的话，则需要这样写：</strong></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;report</span> <span class="na">sourcepath=</span><span class="s">&quot;${src1};${src2};${src3}&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>   <span class="ni">&amp;hellip;</span>
</span><span class='line'><span class="nt">&lt;/report&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div><br/>
不同的src路径用操作系统的classpath分隔符或逗号隔开，比如window用分号隔开，官网是这样解释的：<br/>
<blockquote><p>sourcepath : An optional source path to use for report generation (a path-like structure). It is interpreted as a list of directories (separated by the OS-specific classpath separator or comma) containing .java source files. The local path names within each directory should reflect class package names. (Currently, only the HTML report generator uses this data, and only atmethod report depth.)</p></blockquote></p>

<p><strong>3.jenkins的emma插件可以显示覆盖率的趋势，已经包，类，方法的覆盖率情况，但不支持链接显示代码源文件，看了下jenkins的官网，有人已经对插件提了这样一个需求，但回复说无法实现，说明如下：</strong>  <br/>
<blockquote><p>This was an obvious feature and so I tried to do this, but the problem is that the HTML file names and anchors that EMMA puts are just random numbers. So Hudson cannot link to the appropriate portion of those HTML files.</p></p><p><p>I also thought about generating those reports by myself in Hudson, but EMMA doesn&rsquo;t leave the line-by-line coverage information in XML file either.</p></p><p><p>So that leaves me no choice but to parse emma&rsquo;s data file directly. So this is bit involving.　　</p></blockquote></p>

<p>意思是说emma的html源文件是用随机数字命名，所以在xml文件中无法链接这些html源文件，emma没有修复这个问题，插件作者也无法完成这个需求:(</p>

<p>我的解决方案是用doc link插件在jenkins页面上直接链接coverage.html文件。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java通过class文件得到所在jar包]]></title>
    <link href="http://zhaozhiming.github.io/blog/2012/03/16/java-get-the-jar-file-by-the-class-file-of-jar/"/>
    <updated>2012-03-16T18:04:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2012/03/16/java-get-the-jar-file-by-the-class-file-of-jar</id>
    <content type="html"><![CDATA[<p>今天遇到一个问题，需要通过知道的class文件得到该文件所在的jar包，试过很多办法都不行，最后在网上找到了一个解决办法，如下：</p>

<!--more-->


<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>demo.java </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">String</span> <span class="n">path</span> <span class="o">=</span> <span class="n">XXX</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getProtectionDomain</span><span class="o">().</span><span class="na">getCodeSource</span><span class="o">().</span><span class="na">getLocation</span><span class="o">().</span><span class="na">getFile</span><span class="o">();</span>
</span><span class='line'><span class="n">File</span> <span class="n">jarFile</span> <span class="o">=</span> <span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="n">path</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>其中的XXX指已经知道的类名，然后通过后面的方法可以直接获取到JAR包，具体这些方法是干嘛的，下来研究后再补充。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在ant中将依赖jar包一并打包的方法]]></title>
    <link href="http://zhaozhiming.github.io/blog/2012/03/16/put-the-depend-jar-together-in-a-jar-with-ant/"/>
    <updated>2012-03-16T11:10:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2012/03/16/put-the-depend-jar-together-in-a-jar-with-ant</id>
    <content type="html"><![CDATA[<p>一般jar包里面是不包含jar文件的，如果自己的类有依赖其他jar包，可以通过ant命令将这些jar包解析，然后和自己的class文件打在一起，命令如下：</p>

<!--more-->


<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>build.xml </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;pre&gt;&lt;code&gt;</span>    <span class="ni">&amp;lt;</span>jar basedir=&quot;${build.class}&quot; destfile=&quot;${build.out}/myjar.jar&quot;<span class="ni">&amp;gt;</span>
</span><span class='line'>        <span class="ni">&amp;lt;</span>manifest<span class="ni">&amp;gt;</span>
</span><span class='line'>            <span class="ni">&amp;lt;</span>attribute name=&quot;Main-Class&quot; value=&quot;Main&quot;/<span class="ni">&amp;gt;</span>
</span><span class='line'>        <span class="ni">&amp;lt;</span>/manifest<span class="ni">&amp;gt;</span>
</span><span class='line'>
</span><span class='line'>        <span class="ni">&amp;lt;</span>zipfileset excludes=&quot;META-INF/*.SF&quot; src=&quot;${project.lib}/1.jar&quot; /<span class="ni">&amp;gt;</span>
</span><span class='line'>        <span class="ni">&amp;lt;</span>zipfileset excludes=&quot;META-INF/*.SF&quot; src=&quot;${project.lib}/2.jar&quot; /<span class="ni">&amp;gt;</span>
</span><span class='line'>    <span class="ni">&amp;lt;</span>/jar<span class="ni">&amp;gt;</span>
</span><span class='line'><span class="nt">&lt;/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div><br/>
执行之后，依赖jar包就会解压到要打包的jar文件里面，只要依赖包里面的class和自己的class没有冲突，一般是没有问题的。</p>
]]></content>
  </entry>
  
</feed>
