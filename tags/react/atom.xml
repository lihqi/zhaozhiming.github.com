<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: react | Hacker and Geeker's Way]]></title>
  <link href="http://zhaozhiming.github.io/tags/react/atom.xml" rel="self"/>
  <link href="http://zhaozhiming.github.io/"/>
  <updated>2018-04-18T08:44:40+08:00</updated>
  <id>http://zhaozhiming.github.io/</id>
  <author>
    <name><![CDATA[赵芝明]]></name>
    <email><![CDATA[kingzzm1982@sina.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[基于 React 的 CMS 框架对比：Docusaurus vs. Gatsby]]></title>
    <link href="http://zhaozhiming.github.io/blog/2018/01/30/docusaurus-vs-gatsby/"/>
    <updated>2018-01-30T20:01:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2018/01/30/docusaurus-vs-gatsby</id>
    <content type="html"><![CDATA[<p>{% img /images/post/2018/01/vs.jpg 400 350 %}</p>

<p>最近 Facebook 推出了一个文档工具 <a href="http://docusaurus.io/">Docusaurus</a>，既可以用来做产品网站，也可以用来写博客，还提供很多很有用的功能，最重要的是它是基于 React 实现的。</p>

<p>同样基于 React 技术的静态网站生成工具 <a href="https://www.gatsbyjs.org/">Gatsby</a>，也具备了类似的功能，而且它提供了非常丰富的插件。</p>

<p>可见两者各有千秋，那我们应该选择呢？或者说我们应该基于什么场景来使用它们呢？</p>

<!--more-->


<h2>CMS</h2>

<p>首先我们先了解一下什么是 CMS，下面是维基百科的定义：</p>

<p>{% blockquote 维基百科 %}
内容管理系统（英语：content management system，缩写为 CMS）是指在一个合作模式下，用于管理工作流程的一套制度。该系统可应用于手工操作中，也可以应用到电脑或网络里。作为一种中央储存器（central repository），内容管理系统可将相关内容集中储存并具有群组管理、版本控制等功能。版本控制是内容管理系统的一个主要优势。
{% endblockquote %}</p>

<p>看完是不是对什么是 CMS 更懵了？没关系，我们接着往下看。</p>

<p>那什么样的网站属于 CMS 呢？其实大部分网站都可以归属于 CMS，但更多时候是指下面这些类型的网站：</p>

<ul>
<li>博客类网站，以个人博客类居多</li>
<li>公司类网站，例如<a href="https://www.knownsec.com">知道创宇的网站</a></li>
<li>产品类网站，比如 <a href="https://reactjs.org">Reactjs 的网站</a></li>
</ul>


<p>总的来说就是指由静态化的页面组成的网站。</p>

<p>一直以来都有很多工具来制作或生成 CMS 网站，下面是几个比较出名的 CMS 框架。</p>

<ul>
<li>Wordpress: 老牌的 CMS 框架，以超多插件功能强大而著称，也以多安全漏洞而受广大黑客喜爱。</li>
<li>Gitbook: 是一个支持 Markdown 格式的文档编写工具，可以很方便地和 github 进行集成。</li>
<li>Hexo: 是用 Nodejs 编写的博客框架，支持多种博客主题，同样支持 Markdown 格式。</li>
</ul>


<p>但在现代化的 web 开发体系中，这些框架在前端技术上显得有些落后，目前 React 是全球范围内最受欢迎的前端框架（没有之一），我们当然希望可以有一个基于 React 技术的静态网站开发工具。</p>

<h2>Gatsby 和 Docusaurus</h2>

<p>其实基于 React 技术的静态网站生成工具也有很多，但是比较出名的要数<code>Gatsby</code>了，一个是因为它出来的时间比较早，另一个是因为它一直在迭代完善，从而让很多开发者都喜欢它。</p>

<p><code>Docusaurus</code>是 Facebook 公司最近刚开源出来的一个建站工具，当然它也是基于 React 的。相比<code>Gatsby</code>，它更多是为产品类网站而服务，集成了很多产品类网站所需要的功能，包括：版本化、国际化、站内检索等。</p>

<h2>Gatsby vs. Docusaurus</h2>

<p>虽然两者都是基于 React 的静态网站工具，但是在很多方面还是不一样的，下面通过几个方面介绍两者的不同之处，希望大家看完之后可以根据自己的需求做出正确的选择。</p>

<h3>入门容易度</h3>

<p>在入门容易度方面，<code>Docusaurus</code>要完胜<code>Gatsby</code>，<code>Docusaurus</code>的文档简单易懂，花半个小时基本上就可以看完了，然后再花个 5 分钟就可以搭建出一个静态网站，用户只需要通过 markdown 来编写文档就可以了。</p>

<p><code>Docusaurus</code>留给用户自定义配置的地方并不多，基本上都集中在<code>siteConfig.js</code>这个文件里面，所以用户要关心的东西并不多。</p>

<p><code>Gatsby</code>虽然也有官方文档，但因为涉及的点比较多所以文档也很长，比如你可能需要了解<code>GraphQL</code>（后台通过它来获取博客文章和站点信息），还需要知道有哪些<code>starter</code>（可以理解为项目模板，里面不仅包含了网站的样式，还包含了网站的配置）可以选择，还需要知道有哪些插件可以使用（包括官方和第三方的很多插件），光看完这些文档就要费不少时间。</p>

<p>看完文档之后你可能还需要去参考其他<code>starter</code>，选择其中一个来作为网站的模板，在其基础上进行修改，如果是用最基本的<code>starter</code>来搭建网站的话，那要做的东西就太多了，所以一般是选择一个适合自己的<code>starter</code>来创建项目会比较好。</p>

<h3>页面定制</h3>

<p><code>Docusaurus</code>是集成度比较高的一个产品，所以用户可扩展的东西并不多，比如首页和博客文章页面的布局用户是无法进行大幅度改动的，但可以进行一些小范围的修改。比如在<code>siteConfig.js</code>里面有个属性是<code>colors</code>，里面可以让用户自定义网站的<code>主颜色</code>和<code>次要颜色</code>。</p>

<p>{% codeblock lang:js %}
  /<em> colors for website </em>/
  colors: {</p>

<pre><code>primaryColor: '#2E8555',
secondaryColor: '#205C3B',
</code></pre>

<p>  },
{% endcodeblock %}</p>

<p>另外<code>Docusaurus</code>提供了一个<code>custom.css</code>文件，让用户可以在里面通过覆盖原来的 class 来达到改变样式的目的。</p>

<p>{% codeblock lang:css %}
/<em> your custom css </em>/</p>

<p>@media only screen and (min-device-width: 360px) and (max-device-width: 736px) {}</p>

<p>@media only screen and (min-width: 1024px) {}</p>

<p>@media only screen and (max-width: 1023px) {}</p>

<p>@media only screen and (min-width: 1400px) {}</p>

<p>@media only screen and (min-width: 1500px) {}
{% endcodeblock %}</p>

<p><code>Gatsby</code>在这一点上比<code>Docusaurus</code>要好很多，因为<code>Gatsyb</code>上所有页面文件用户都可以随意修改，包括页面的内容和样式。</p>

<p><code>Gatsby</code>的 src 目录结构如下：</p>

<p>{% codeblock lang:sh %}
.
├── components
│   ├── Bio.js
│   └── profile-pic.jpg
├── layouts
│   └── index.js
├── pages
│   ├── hello-world
│   │   ├── index.md
│   │   └── salty_egg.jpg
│   ├── index.js
│   └── my-second-post
│       └── index.md
└── templates
    └── blog-post.js
{% endcodeblock %}</p>

<ul>
<li>layouts/index.js: 这是网站页面整体布局的文件，可以在这里定义页面头部，底部和侧边栏，然后通过<code>this.props.children</code>来渲染子页面。有 2 种子页面，一种是网站首页页面，另一种是博客文章的页面。</li>
<li>pages/index.js: 这个文件是网站首页的页面文件，在这里可以定义首页页面的内容。</li>
<li>templates/blog-post.js: 这个文件是博客文章的页面文件，在这里可以定义一篇博客文章要如何展示信息，比如标题是什么样式，作者是什么样式等。</li>
</ul>


<p>如果你的网站不需要博客文章，你甚至可以在<code>layout/index.js</code>中去掉<code>this.props.children</code>部分，直接换成你需要的页面内容，这样你也就不需要去编辑<code>pages/index.js</code>文件了。</p>

<p>总之，<code>Gatsby</code>的页面扩展性是非常好的，可以随时将页面修改成你需要的网站样式；而<code>Docusaurus</code> 则只能在其定制好的页面框架下进行一些小修改。</p>

<h3>页面自适应</h3>

<p><code>Docusaurus</code>本身已经做好了页面自适应，用户可以不关心这方面的问题，只要是用<code>Docusaurus</code>搭建出来的网站都是页面自适应的。</p>

<p><code>Gatsby</code>本身是不具备页面自适应功能的，但一些<code>starter</code>会具有页面自适应的能力，只要通过这些<code>starter</code>搭建出来的网站也是页面自适应的，但这种情况相当是受限在这个<code>starter</code>的页面框架里面，如果需要做一些页面样式上的调整，就要检查是否会破坏原来的自适应功能。</p>

<h3>文档检索</h3>

<p><code>Docusaurus</code>本身集成了 <a href="https://www.algolia.com/">algolia</a> 来做站内文档检索功能，用户只需要在<code>siteConfig.js</code>中配置好<code>algolia</code>的选项就好了。</p>

<p>{% codeblock lang:js %}
  algolia: {</p>

<pre><code>apiKey:
  "your api key",
indexName: "your index name"
</code></pre>

<p>  },
{% endcodeblock %}</p>

<p>这是集成了<code>algolia</code>检索功能的截图：</p>

<p>{% img /images/post/2018/01/algolia.png %}</p>

<p><code>Gatsby</code>本身不具备站内检索功能，但它可以通过<code>GraphQL</code>进行文章查询，所以我觉得可以通过<code>GraphQL</code>来实现站内检索的功能，但这个需要用户自己去实现了。</p>

<p>其实<code>Gatsby</code>也可以集成<code>algolia</code>，大家可以看 <a href="https://reactjs.org/">React</a> 的官方网站，它就是用<code>Gatsby</code>做的，里面集成<code>algolia</code>站内检索功能，感兴趣的可以去看下他们网站关于<code>docsearch</code>这一块的<a href="https://github.com/reactjs/reactjs.org/search?utf8=%E2%9C%93&amp;q=docsearch&amp;type=">源码</a>。</p>

<h3>版本化和国际化</h3>

<p>在一些产品中，文档的版本管理是一个比较常见的需求：文档可以根据不同的版本号进行不同的内容展示，这样可以让老版本用户看到相关文档，老文档不会被新版本的文档所覆盖。</p>

<p>同样的，国际化也是一些跨国产品的强需求，可以通过切换不同的语言来展示不同语言的文档，这样可以吸引更多国家的人来使用产品。</p>

<p><code>Docusaurus</code>本身已经集成了这 2 个功能，这也是它的卖点之一，你可以通过命令行来添加新的版本号。每个版本号都是一个文件夹，在里面存放了这个版本的相关文档。</p>

<p>国际化的功能也是类似的操作。</p>

<p><code>Gatsby</code>本身则不具备这些功能，需要用户自己开发。</p>

<h3>编辑分离</h3>

<p>什么是编辑分离呢？假设我们的网站有成千上百个文档，这些文档如果是让搭建网站的程序员来维护的话可能力不从心，而且文档的专业性也得不到保证，但是专业的文档编辑人员又不懂 markdown 语法，那要让他们怎么进行文档编辑呢？这个时候就需要将编辑功能从网站上分离出去了，比如说网站的外部提供了所见即所得的富文本编辑器，让文档编辑人员进行文档编写，然后将编写完的内容同步到网站。</p>

<p><a href="https://www.contentful.com/"><code>contentful</code></a> 是一个专门做文档编辑功能的产品，可以在上面进行文档编辑，并通过 API 获取到文档内容。</p>

<p>而之前我们说了，<code>Gatsby</code>是一个拥有丰富插件的框架，它就提供了这样一个<a href="https://www.gatsbyjs.org/packages/gatsby-source-contentful/">插件</a> 来让网站和 <code>contentful</code>进行集成，配置内容如下：</p>

<p>{% codeblock lang:js %}
// In your gatsby-config.js
plugins: [
  {</p>

<pre><code>resolve: `gatsby-source-contentful`,
options: {
  spaceId: `your_space_id`,
  accessToken: `your_access_token`,
},
</code></pre>

<p>  },
];
{% endcodeblock %}</p>

<p>而<code>Docusaurus</code>不具备这方面的功能。</p>

<h2>总结</h2>

<p>下面的表格总结上面列的点：</p>

<table>
<thead>
<tr>
<th align="left"> </th>
<th align="center"> Docusaurus </th>
<th align="center"> Gatsby</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">入门难度 </td>
<td align="center"> ⭐️⭐️⭐️ </td>
<td align="center"> ⭐️</td>
</tr>
<tr>
<td align="left">页面定制 </td>
<td align="center"> ⭐️ </td>
<td align="center"> ⭐️⭐️⭐️</td>
</tr>
<tr>
<td align="left">页面自适应 </td>
<td align="center"> ⭐️⭐️⭐️  </td>
<td align="center"> ⭐️⭐️</td>
</tr>
<tr>
<td align="left">文档检索 </td>
<td align="center"> ⭐️⭐️⭐️ </td>
<td align="center"> ⭐️⭐️</td>
</tr>
<tr>
<td align="left">版本化和国际化 </td>
<td align="center"> ⭐️⭐️⭐️ </td>
<td align="center"> ⭐️</td>
</tr>
<tr>
<td align="left">编辑分离 </td>
<td align="center"> ⭐️ </td>
<td align="center"> ⭐️⭐️⭐️</td>
</tr>
</tbody>
</table>


<p>总的来说，<code>Docusaurus</code>是一个为产品类网站量身定做的建站工具，具备了大部分产品类网站所需的功能，包括国际化、版本化和站内检索等；而<code>Gatsby</code>更像一个框架，你甚至可以使用<code>Gatsby</code>来制作一个类似<code>Docusaurus</code>一样的产品，如果你的网站有自己的样式要求，或者只是想搭建一个自己的博客，那么你可以选择<code>Gatsby</code>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何扩展 Create React App 的 webpack 配置]]></title>
    <link href="http://zhaozhiming.github.io/blog/2018/01/08/create-react-app-override-webpack-config/"/>
    <updated>2018-01-08T20:04:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2018/01/08/create-react-app-override-webpack-config</id>
    <content type="html"><![CDATA[<p>{% img /images/post/2018/01/cra.png 400 300 %}</p>

<p><a href="https://github.com/facebookincubator/create-react-app">Create React App</a>（以下简称 CRA）是创建 React 应用的一个脚手架，它与其他脚手架不同的一个地方就是将一些复杂工具（比如 webpack）的配置封装了起来，让使用者不用关心这些工具的具体配置，从而降低了工具的使用难度。</p>

<p>但是对于一些熟悉 webpack 的开发者来说，他们可能想对 webpack 配置做一些修改，这个时候应该怎么办呢？</p>

<!--more-->


<p>其实我们可以通过以下几种方式来修改 webpack 的配置：</p>

<ul>
<li>项目 eject</li>
<li>替换 react-scripts 包</li>
<li>使用 react-app-rewired</li>
<li>scripts 包 + override 组合</li>
</ul>


<p>下面对这几种方式分别进行介绍。</p>

<h2>项目 eject</h2>

<p>使用 CRA 创建完项目以后，项目在<code>package.json</code>里面提供了这样一个命令：</p>

<p>{% codeblock lang:json %}
{
  &hellip;
  &ldquo;scripts&rdquo;: {</p>

<pre><code>"eject": "react-scripts eject"
</code></pre>

<p>  },
  &hellip;
}
{% endcodeblock %}</p>

<p>执行完这个命令——<code>yarn run eject</code>后会将封装在 CRA 中的配置全部<code>反编译</code>到当前项目，这样用户就可以完全取得 webpack 文件的控制权，想怎么修改就怎么修改了。</p>

<p>{% codeblock lang:sh %}</p>

<h1>eject 后项目根目录下会出现 config 文件夹，里面就包含了 webpack 配置</h1>

<p>config
├── env.js
├── jest
│   ├── cssTransform.js
│   └── fileTransform.js
├── paths.js
├── polyfills.js
├── webpack.config.dev.js // 开发环境配置
├── webpack.config.prod.js // 生产环境配置
└── webpackDevServer.config.js
{% endcodeblock %}</p>

<p>CRA 与其他脚手架不同的另一个地方，就是可以通过升级其中的<code>react-scripts</code>包来升级 CRA 的特性。比如用老版本 CRA 创建了一个项目，这个项目不具备 <a href="https://developers.google.com/web/progressive-web-apps/">PWA</a> 功能，但只要项目升级了<code>react-scripts</code>包的版本就可以具备 PWA 的功能，项目本身的代码不需要做任何修改。</p>

<p>但如果我们使用了<code>eject</code>命令，就再也享受不到 CRA 升级带来的好处了，因为<code>react-scripts</code>已经是以文件的形式存在于你的项目，而不是以包的形式，所以无法对其升级。</p>

<h2>替换 react-scripts 包</h2>

<p><a href="https://github.com/facebookincubator/create-react-app/tree/8cae659ec5a066eff8ea270346dc8c1ef064f9aa/packages/react-scripts">react-scripts</a> 是 CRA 的一个核心包，一些脚本和工具的默认配置都集成在里面，使用 CRA 创建项目默认就是使用这个包，但是 CRA 还提供了另外一种方式来创建 CRA 项目，即使用自定义 scripts 包的方式。</p>

<p>{% codeblock lang:sh %}</p>

<h1>默认方式</h1>

<p>$ create-react-app foo</p>

<h1>自定义 scripts 包方式</h1>

<p>$ create-react-app foo &mdash;scripts-version 自定义包
{% endcodeblock %}</p>

<p><code>自定义包</code>可以是下面几种形式：</p>

<ul>
<li><code>react-scripts</code>包的版本号，比如<code>0.8.2</code>，这种形式可以用来安装低版本的<code>react-scripts</code>包。</li>
<li>一个已经发布到 npm 仓库上的包的名字，比如<code>your-scripts</code>，里面包含了修改过的 webpack 配置。</li>
<li>一个 tgz 格式的压缩文件，比如<code>/your/local/scripts.tgz</code>，通常是未发布到 npm 仓库的自定义 scripts 包，可以用 <code>npm pack</code> 命令生成。</li>
</ul>


<p>这种方式相对于之前的<code>eject</code>是一种更灵活地修改 webpack 配置的方式，而且可以做到和 CRA 一样，通过升级 scrips 包来升级项目特性。</p>

<p>自定义 scripts 包的结构可以参照<code>react-scripts</code>包的结构，只要修改对应的 webpack 配置文件，并安装上所需的 webpack loader 或 plugin 包就可以了。</p>

<h2>使用 react-app-rewired</h2>

<p>虽然有这两种方式可以扩展 webpack 配置，但是很多开发者还是觉得太麻烦，有没有一种方式可以既不用<code>eject</code>项目又不用创建自己的 scripts 包呢？答案是肯定的，<a href="https://github.com/timarney/react-app-rewired">react-app-rewired</a> 是 react 社区开源的一个修改 CRA 配置的工具。</p>

<p>在 CRA 创建的项目中安装了<code>react-app-rewired</code>后，可以通过创建一个<code>config-overrides.js</code> 文件来对 webpack 配置进行扩展。</p>

<p>{% codeblock lang:js %}
/<em> config-overrides.js </em>/</p>

<p>module.exports = function override(config, env) {
  //do stuff with the webpack config&hellip;
  return config;
}
{% endcodeblock %}</p>

<p><code>override</code>方法的第一个参数<code>config</code>就是 webpack 的配置，在这个方法里面，我们可以对 <code>config</code> 进行扩展，比如安装其他 loader 或者 plugins，最后再将这个 <code>config</code> 对象返回回去。</p>

<p>最后再修改<code>package.json</code>中的脚本命令，修改内容请见<a href="https://github.com/timarney/react-app-rewired#3-flip-the-existing-calls-to-react-scripts-in-npm-scripts">这里</a>。</p>

<h2>scripts 包 + override 组合</h2>

<p>虽然<code>react-app-rewired</code>的方式已经可以很方便地修改 webpack 的配置了，但其实我们也可以在自定义的 script 包中实现类似的功能。</p>

<p>在<code>react-app-rewired</code>的源码中可以看到它核心的包也叫 <a href="https://github.com/timarney/react-app-rewired/tree/4954531eaab6da14c4e3c943cb2038b46d5f9125/packages/react-app-rewired">react-app-rewired</a>，里面重新覆盖了<code>react-scripts</code>中的几个脚本文件，包括<code>build.js</code>、<code>start.js</code>和<code>test.js</code>。</p>

<p>具体过程是怎样的呢？以<code>build.js</code>为例：</p>

<ul>
<li>先获取 webpack 的基本配置，然后再调用<code>config-overrides.js</code>（就是在根目录中新增的那个文件）中的<code>override</code>方法，将原先的 webpack 对象作为参数传入，</li>
<li>再取得经过修改后的 webpack 配置对象</li>
<li>最后再调用<code>react-scripts</code>中的<code>build.js</code>脚本，传入修改后的 webpack 对象来执行命令，</li>
</ul>


<p>具体源码如下：</p>

<p>{% codeblock lang:js %}
const overrides = require(&lsquo;../config-overrides&rsquo;);
const webpackConfigPath = paths.scriptVersion + &ldquo;/config/webpack.config.prod&rdquo;;</p>

<p>// load original config
const webpackConfig = require(webpackConfigPath);
// override config in memory
require.cache[require.resolve(webpackConfigPath)].exports =
  overrides.webpack(webpackConfig, process.env.NODE_ENV);
// run original script
require(paths.scriptVersion + &lsquo;/scripts/build&rsquo;);
{% endcodeblock %}</p>

<p>知道了原理之后，我们也可以修改自定义 scripts 包的脚本文件，还是以<code>build.js</code>为例，在获取基本 webpack 配置对象和使用 webpack 对象之间加入以下代码：</p>

<p>{% codeblock lang:js %}
// override config
const override = require(paths.configOverrides);
const overrideFn = override || ((config, env) => config);
const overrideConfig = overrideFn(config, process.env.NODE_ENV);
{% endcodeblock %}</p>

<p><code>overrideConfig</code>就是修改后的 webpack 对象，最后修改调用了 webpack 对象的代码，将原来的 webpack 对象替换成修改后的 webpack 对象。</p>

<h2>总结</h2>

<p>CRA 是一个非常棒的 React 脚手架工具，但你如果不满足于它的 webpack 默认配置，你可以通过上述几种方式来扩展自己项目的 webpack 配置，这几种方式各有优缺点，可以结合具体的使用场景来选择合适自己的方式。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何运行 react16 之后测试]]></title>
    <link href="http://zhaozhiming.github.io/blog/2017/11/08/run-react-test-with-react-version-16/"/>
    <updated>2017-11-08T20:36:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2017/11/08/run-react-test-with-react-version-16</id>
    <content type="html"><![CDATA[<p>{% img /images/post/2017/11/react-test.png 400 300 %}</p>

<p>React 升级到版本 16 之后，各方面都有不少改进，最重要的是完全向后兼容，功能代码几乎不用怎么修改就可以使用新版本。但是测试代码就不一定了，如果你是使用 <code>enzyme</code> 跑测试的话，以前的测试可能会跑不起来，那么需要如何修改呢？下面我们就来看一下吧。</p>

<!--more-->


<h2>一个简单的测试用例</h2>

<p>让我们来看一个简单的测试，这里面用到了测试 React 组件时常用的 <code>enzyme</code> 包和一个将 <code>enzyme</code> 对象转成 json 的工具<code>enzyme-to-json</code>。</p>

<p>可以暂时不管该测试对应的功能代码是怎么样的，因为校验的结果是组件快照。</p>

<p>{% codeblock lang:js %}
// Demo.js
import React from &lsquo;react&rsquo;;</p>

<p>export default () => <div>Hello World</div>;</p>

<p>// Demo.test.js
import React from &lsquo;react&rsquo;;
import { shallow } from &lsquo;enzyme&rsquo;;
import toJson from &lsquo;enzyme-to-json&rsquo;;
import Demo from &lsquo;./Demo&rsquo;;</p>

<p>describe(&lsquo;Demo Component&rsquo;, () => {
  it(&lsquo;should render correctly&rsquo;, () => {</p>

<pre><code>const wrapper = shallow(&lt;Demo /&gt;);
expect(toJson(wrapper)).toMatchSnapshot();
</code></pre>

<p>  });
});</p>

<p>{% endcodeblock %}</p>

<h2>React16 之前</h2>

<p>在升级 React16 之前，我们依赖的第三方库版本如下，跑这个测试是完全没有问题的。</p>

<ul>
<li>react: 15.4.2</li>
<li>react-dom: 15.4.2</li>
<li>enzyme: 2.8.2</li>
<li>enzyme-to-json: 1.5.1</li>
<li>react-addons-test-utils: 15.4.2</li>
</ul>


<p>{% codeblock lang:bash %}
PASS  src/Demo.test.js
  Demo Component</p>

<pre><code>✓ should render correctly (12ms)
</code></pre>

<p>Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Snapshots:   1 passed, 1 total
{% endcodeblock %}</p>

<h2>React16 之后</h2>

<p>但是升级 React16 之后，这个测试就跑不过了，报以下的错误：</p>

<ul>
<li>react: 15.4.2 => 16.0.0</li>
<li>react-dom: 15.4.2 => 16.0.0</li>
</ul>


<p>{% codeblock lang:bash %}
FAIL  src/Demo.test.js
  ● Test suite failed to run</p>

<pre><code>Cannot find module 'react-dom/lib/ReactTestUtils' from 'index.js'

  at Resolver.resolveModule (node_modules/jest-resolve/build/index.js:179:17)
  at Object.&lt;anonymous&gt; (node_modules/react-addons-test-utils/index.js:1:107)
</code></pre>

<p>Test Suites: 1 failed, 1 total
Tests:       0 total
Snapshots:   0 total
{% endcodeblock %}</p>

<h2>enzyme 的版本升级</h2>

<p>通过报错信息可以发现 React 的一些测试 API 发生了变化，那要如何修正呢？其实在 React 升级到版本 16 以后，<code>enzyme</code> 也对自身做了一次大的重构，我们来看看要怎么使用重构后的<code>enzyme</code>。</p>

<ul>
<li>首先升级 <code>enzyme</code> 的版本到最新版本</li>
<li>然后再安装 <code>enzyme-adapter-react-16</code> 这个包（待会讲这个包是做什么的），原来的 <code>react-addons-test-utils</code> 包可以删掉，新版的 <code>enzyme</code> 已经不需要了</li>
<li>最后在测试的全局配置中增加以下代码（如果是用 <code>create-react-app</code> 创建项目的话，可以在 <code>src/setupTests.js</code>里面修改）</li>
</ul>


<p>{% codeblock lang:js %}
import Enzyme from &lsquo;enzyme&rsquo;;
import Adapter from &lsquo;enzyme-adapter-react-16&rsquo;;</p>

<p>Enzyme.configure({ adapter: new Adapter() });
{% endcodeblock %}</p>

<p>OK！原来的测试通过了！</p>

<p>新版的<code>enzyme</code> 拆分出来了多个 adapter 包，用来支持多种 React 版本，下面是版本对照表：</p>

<table>
<thead>
<tr>
<th></th>
<th align="center"> Enzyme Adapter Package </th>
<th align="center"> React semver compatibility </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="center"> <code>enzyme-adapter-react-16</code> </td>
<td align="center"> <code>^16.0.0</code></td>
</tr>
<tr>
<td></td>
<td align="center"> <code>enzyme-adapter-react-15</code> </td>
<td align="center"> <code>^15.5.0</code></td>
</tr>
<tr>
<td></td>
<td align="center"> <code>enzyme-adapter-react-15.4</code> </td>
<td align="center"> <code>15.0.0-0 - 15.4.x</code></td>
</tr>
<tr>
<td></td>
<td align="center"> <code>enzyme-adapter-react-14</code> </td>
<td align="center"> <code>^0.14.0</code></td>
</tr>
<tr>
<td></td>
<td align="center"> <code>enzyme-adapter-react-13</code> </td>
<td align="center"> <code>^0.13.0</code></td>
</tr>
</tbody>
</table>


<h2>疑难问题</h2>

<p>虽然测试现在已经跑通了，但是你可能会遇到下面这个警告：</p>

<p>{% codeblock lang:bash %}
console.error node_modules/fbjs/lib/warning.js:33</p>

<pre><code>Warning: React depends on requestAnimationFrame. Make sure that you load a polyfill in older browsers. http://fb.me/react-polyfills
</code></pre>

<p> PASS  src/Demo.test.js
  Demo Component</p>

<pre><code>✓ should render correctly (8ms)
</code></pre>

<p>Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Snapshots:   1 passed, 1 total
{% endcodeblock %}</p>

<p>原因是测试用到的<code>jsdom</code> 包还没有提供<code>requestAnimationFrame</code>，所以会报这个警告。</p>

<p>具体内容可以看<a href="https://github.com/facebookincubator/create-react-app/issues/3199">这个 ISSUE</a>，<code>create-react-app</code>已经做了相应的修复，修改内容可以看看<a href="https://github.com/facebookincubator/create-react-app/pull/3340">这个 PR</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何安全地使用 React 的 context]]></title>
    <link href="http://zhaozhiming.github.io/blog/2017/02/19/how-to-safely-use-react-context-zh-cn/"/>
    <updated>2017-02-19T19:38:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2017/02/19/how-to-safely-use-react-context-zh-cn</id>
    <content type="html"><![CDATA[<p>{% img /images/post/2017/02/react-context.jpeg %}</p>

<p>在自己的 React 项目中使用了大量的 context，虽然知道这是一个不推荐使用的特性，但还是用了很多，想看看别人是怎么使用 context，所以翻译了下面这篇文章，注意文章中引用了嵌套的twitter内容，所以访问时最好是翻墙访问，以免影响阅读。</p>

<!--more-->


<h2>如何安全地使用 React 的 context</h2>

<p>Context 是 React 里面一个有着很多免费声明的、非常强大的特性，就像乐园里面的禁果一样。</p>

<p>{% img <a href="https://cdn-images-1.medium.com/max/1600/1*rbUZNOyFC64KmJaRhF2Kww.png">https://cdn-images-1.medium.com/max/1600/1*rbUZNOyFC64KmJaRhF2Kww.png</a> %}</p>

<p>这应该可以让你远离 context 了对吧？当然不是，它虽然是一个被禁用的 React 特性，但它的存在是一个不争的事实！context 可以把数据传递给组件树底层的组件，无需中间组件的参与。context 的经典用法是定制主题，本地化和路由这些方面。</p>

<p><a href="https://medium.com/@dan_abramov">Dan Abramov</a> 设计了一些明智的规则让你知道什么时候不该使用 context：</p>

<p>{% img <a href="https://cdn-images-1.medium.com/max/1600/1*b6Ev2SZ8SBlqhKVrOGDZaA.jpeg">https://cdn-images-1.medium.com/max/1600/1*b6Ev2SZ8SBlqhKVrOGDZaA.jpeg</a> %}</p>

<p>现在你可能已经按照这个明智的建议来做，但同时，使用一些使用了 context 的库，比如 <a href="https://github.com/ReactTraining/react-router">react-router</a>，当它和其他库像 <a href="https://github.com/reactjs/react-redux">react-redux</a> 或 <a href="https://github.com/mobxjs/mobx-react">mbox-react</a>组合时，甚至是和你自己的 shouldeComponentUpdate，又或者是由 React.PureComponent 提供的这个方法组合时，都仍然可能让你有陷入困境。长期存在的<a href="https://github.com/facebook/react/issues/2517">问题</a> 可以在 React 或 React 相关的第三方库的问题跟踪列中找到。</p>

<blockquote class="twitter-tweet" data-lang="zh-cn"><p lang="en" dir="ltr">Redux implements sCU, making setState + context break, forces &quot;subscribe&quot; on everybody else. Seems like React needs a generic solution.</p>&mdash; Ryan Florence (@ryanflorence) <a href="https://twitter.com/ryanflorence/status/779320581678174208">2016 年 9 月 23 日</a></blockquote>


<script async src="http://zhaozhiming.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>所以，为什么这篇博客跟你有关？这是因为：</p>

<ul>
<li>你是一个库的作者</li>
<li>你使用的库使用了 context，或者你自己使用 context，然后你想安全地使用 shouldComponentUpdate (SCU)，或者一些基于此的已有实现（比如 PureComponent, Redux 的 connect, 或者 MobX 的 observer）。</li>
</ul>


<h3>为什么 Context + ShouldComponentUpdate 有问题？</h3>

<p>Context 用来和嵌套很深的组件交流，例如，一个根组件定义了一个主题，然后这个组件树中的任何组件可能（也可能不）对这个信息感兴趣，就像<a href="https://facebook.github.io/react/docs/context.html#passing-info-automatically-through-a-tree">官方的 context 示例</a>。</p>

<p>shouldComponentUpdate (SCU) 另一方面在重新渲染组件树（包括子组件）的一部分中起到短路作用，例如如果 props 或者组件的 state 没有被明确的修改，组件就不会重新渲染，但这可能意外中断 context 的传播。</p>

<blockquote class="twitter-tweet" data-lang="zh-cn"><p lang="en" dir="ltr"><a href="https://twitter.com/dan_abramov">@dan_abramov</a> <a href="https://twitter.com/iammerrick">@iammerrick</a> <a href="https://twitter.com/ryanflorence">@ryanflorence</a> specifically, anything that uses context will break. Seems unfair to the rest of us :(</p>&mdash; MICHAEL JACKSON (@mjackson) <a href="https://twitter.com/mjackson/status/779329979741904896">2016 年 9 月 23 日</a></blockquote>


<p></p>

<script async src="http://zhaozhiming.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p></p>

<blockquote class="twitter-tweet" data-lang="zh-cn"><p lang="en" dir="ltr"><a href="https://twitter.com/mjackson">@mjackson</a> <a href="https://twitter.com/iammerrick">@iammerrick</a> <a href="https://twitter.com/ryanflorence">@ryanflorence</a> The thing here is that React Redux doesn’t rely on context updating correctly. It knows React is broken.</p>&mdash; Dan Abramov (@dan_abramov) <a href="https://twitter.com/dan_abramov/status/779335426377183232">2016 年 9 月 23 日</a></blockquote>


<script async src="http://zhaozhiming.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>让我们通过一个简单的 app 来模拟这个有冲突的问题：</p>

<script async src="http://zhaozhiming.github.io//jsfiddle.net/mweststrate/3ay25feh/embed/"></script>


<p>在 context 和 SCU 中产生问题的地方显而易见，当你按了“Red please!”按钮（在“Result”栏上面）时，按钮本身的颜色刷新了，但待办列表没有被更新。原因很简单，我们的 TodoList 组件是智能的，它知道当它没有接收到新的待办子项它就不需要重新渲染（最聪明的地方是继承了 PureCompnent，其重新实现了 shouldComponentUpdate方法）。</p>

<p>尽管如此，正因为这个最智能的地方（指继承了 PureCompnent，这个在大型应用是非常有必要的，因为它可以提供更好的性能），让 TodoList 中的 ThemedText 组件没有接收到更新了颜色的新 context！因为不管是 TodoList 或它的后代更新了，SCU 都返回 false。</p>

<p>{% img <a href="https://cdn-images-1.medium.com/max/1600/1*pnkWX7uEzCeY-7r5Ii_Y-A.png">https://cdn-images-1.medium.com/max/1600/1*pnkWX7uEzCeY-7r5Ii_Y-A.png</a> %}</p>

<p>更糟的是，我们不能在 TodoList 中手工修改 SCU，因为它是固定了的一个方法。因为 SCU 不能接收相关的 context 数据（颜色），它不能（也不该）被订阅到指定的context数据中，毕竟它本身不是一个theme-aware的组件。</p>

<p>总的来说，shouldComponentUpdate 返回 false 导致任何 context 更新不再传播到子组件中去，非常糟不是吗？我们可以修复这个问题吗？</p>

<h3>ShouldComponentUpdate 和 Context 可以一起工作！</h3>

<p>你注意到了问题只发生在我们更新 context 的时候吗？这个是解决问题的关键所在，只要确保你一直不更新 context就可以了，换句话说：</p>

<ul>
<li>Context 不应该改变，它应该不可变</li>
<li>组件应该在其构造时只接收 context 一次</li>
</ul>


<p>{% blockquote %}
或者，为了使其不同，我们不应该直接把 state 保存到 context 中，取而代之，我们应该像依赖注入系统一样使用 conext。
{% endblockquote %}</p>

<p>这意味着 SCU 不再干涉 context 需要传什么，因为不再需要传递新的 context 给子组件。棒极了！这解决了我们所有问题！</p>

<h3>通过基于 context 的依赖注入来和变更进行交流</h3>

<p>如果我们想要改变主题颜色，很简单，我们在适当的地方有一个依赖注入系统（DI），所以我们可以向下传递一个仓库来管理我们的主题并订阅它，我们绝不会传递一个新的仓库，但要确保仓库本身是有状态的，并且可以观察到组件的变化：</p>

<p>{% codeblock lang:js %}
// Theme 组件存储当前的主题状态，并允许组件订阅将来变化（的数据）
class Theme {
  constructor(color) {</p>

<pre><code>this.color = color
this.subscriptions = []
</code></pre>

<p>  }</p>

<p>  setColor(color) {</p>

<pre><code>this.color = color
this.subscriptions.forEach(f =&gt; f())
</code></pre>

<p>  }</p>

<p>  subscribe(f) {</p>

<pre><code>this.subscriptions.push(f)
</code></pre>

<p>  }
}</p>

<p>class ThemeProvider extends React.Component {
  constructor(p, c) {</p>

<pre><code>super(p, c)
// 主题提供者在它的整个生命周期中使用同样的主题对象
this.theme = new Theme(this.props.color)
</code></pre>

<p>  }</p>

<p>  // 必要时更新主题，更新的内容会传播给订阅的主键
  componentWillReceiveProps(next) {</p>

<pre><code>this.theme.setColor(next.color)
</code></pre>

<p>  }</p>

<p>  getChildContext() {</p>

<pre><code>return {theme: this.theme}
</code></pre>

<p>  }</p>

<p>  render() {</p>

<pre><code>return &lt;div&gt;{this.props.children}&lt;/div&gt;
</code></pre>

<p>  }
}
ThemeProvider.childContextTypes = {
  theme: React.PropTypes.object
}</p>

<p>class ThemedText extends React.Component {
  componentDidMount() {</p>

<pre><code>// 订阅未来改变的主题
this.context.theme.subscribe(() =&gt; this.forceUpdate())
</code></pre>

<p>  }
  render() {</p>

<pre><code>return &lt;div style={{color: this.context.theme.color}}&gt;
  {this.props.children}
&lt;/div&gt;
</code></pre>

<p>  }
}
ThemedText.contextTypes = {
  theme: React.PropTypes.object
}
{% endcodeblock %}</p>

<p>完整的可运行列表：</p>

<script async src="http://zhaozhiming.github.io//jsfiddle.net/mweststrate/pc327358/embed/"></script>


<p>注意到在这个示例里面颜色的改变已经正确了，但它仍然使用 PureComponent，而且重要组件 TodoList 和 ThemedText 的 API 并没有改变。</p>

<p>虽然我们的 ThemeProvider 的实现变得更复杂了，它创建了一个Theme 对象来保持了我们主题的状态，Theme对象同时也是一个事件发射器，这可以让像 ThemeText 一样的组件来订阅未来的变化，Theme 对象通过 ThemeProvider 在组件树中传递。context 仍然是用来做这个的，但只有刚开始的时候传递了 context，后面的更新都通过 Theme 自己来传播，并没有重新创建一个 context。</p>

<p>{% img <a href="https://cdn-images-1.medium.com/max/1600/1*ul_3UcymigXysL-JzgF8dQ.png">https://cdn-images-1.medium.com/max/1600/1*ul_3UcymigXysL-JzgF8dQ.png</a> %}</p>

<p>这个实现有点过于简单，更好的实现方式是需要在 componentWillUnmount 中清理事件监听器，并且应该使用 setState 来代替 forceUpdate，但好消息是你关注的内容已经有第三方库在开发了，它不会影响库的使用者，以后中间组件意外的 shouldComponentUpdate 实现将不再破坏库的行为。</p>

<h3>总结</h3>

<p>通过依赖注入系统而不是状态的容器来限制使用 context，我们可以同时构造基于 context 的库和正确行为的 shouldComponentUpdate，而不会被干涉和破坏消费者的 API，还有非常重要的一点是，在当前受限的 React context 系统中可以正常工作，只要你遵守这条简单的规则：</p>

<p>{% blockquote %}
Context 在每个组件中应该只被接收一次。
{% endblockquote %}</p>

<blockquote class="twitter-tweet" data-lang="zh-cn"><p lang="en" dir="ltr"><a href="https://twitter.com/ryanflorence">@ryanflorence</a> <a href="https://twitter.com/mweststrate">@mweststrate</a> <a href="https://twitter.com/dan_abramov">@dan_abramov</a> <a href="https://twitter.com/sebmarkbage">@sebmarkbage</a> huh. i never thought of context as a &quot;dependency&quot; before. i guess it is.</p>&mdash; MICHAEL JACKSON (@mjackson) <a href="https://twitter.com/mjackson/status/779375007579287552">2016 年 9 月 23 日</a></blockquote>


<script async src="http://zhaozhiming.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>最后的提醒：context 仍然是实验性的特性，你应该避免直接使用 context（看上面 Dan Abramov 的规则），作为代替使用抽象过的 context 库（看下面的一些例子），但如果你是一个库的作者，或者如果你在写一些很好的高阶组件来处理 context，坚持上面的解决方案将避免一些令人讨厌的意外。</p>

<p><strong>更新于 2016-9-29：</strong> <a href="https://medium.com/@ryanflorence">Ryan Florence</a> 刚发布了一个通用包，包含了上面讲的这个模式，所以你可以不用自己写这些代码了 <a href="https://github.com/ReactTraining/react-context-emission">react-context-emission</a>。</p>

<h3>奖励：使用 MobX observables 作为 context 来简化事情</h3>

<p>（如果你在使用或对 MobX 感兴趣那你对这一章也会感兴趣）</p>

<p>如果你使用 MobX，你完全可以跳过整个事件触发器这个东西，并且作为替代在 context 中使用仓库 observables，并通过使用 observer decorator 或高阶组件来订阅他们，这使得你不必自己管理数据的订阅。</p>

<script async src="http://zhaozhiming.github.io//jsfiddle.net/mweststrate/xpw6a5Ld/embed/"></script>


<p>实际上，更简单的方法是使用 MobX 中的 <a href="https://github.com/mobxjs/mobx-react#provider-and-inject">Provider / inject</a> 的机制，它是对 React conext 机制的一个抽象化后的结果。它移除了 contextTypes 声明和类似其他东西的代码，注意这个类似的概念可以在一些库比如 <a href="https://github.com/acdlite/recompose/blob/master/docs/API.md#withcontext">recompose</a> 或 <a href="https://github.com/gnoff/react-tunnel">react-tunnel</a> 中找到。</p>

<script async src="http://zhaozhiming.github.io//jsfiddle.net/mweststrate/b537yvcj/embed/"></script>


<p>它是很值得尝试的，注意看，虽然我们初始基于依赖注入解决方案的代码量是原始代码的 1.5 倍，但最终的解决方案的代码和原来有问题的实现方案代码一样多。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用AVA和Enzyme测试React组件（三）]]></title>
    <link href="http://zhaozhiming.github.io/blog/2016/03/29/use-ava-and-enzyme-to-test-react-component-part3/"/>
    <updated>2016-03-29T20:42:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2016/03/29/use-ava-and-enzyme-to-test-react-component-part3</id>
    <content type="html"><![CDATA[<p>{% img /images/post/2016/03/react.png %}</p>

<p><strong>React组件的测试要点</strong>：React组件要怎么测试，有哪些需要注意的地方，今天我们通过一些例子来说明。</p>

<!--more-->


<p></p>

<h2>render逻辑的测试</h2>

<p>React中存在逻辑的地方有一部分是在render方法中，React通过props或state的值可以render出不同的页面，所以我们可以通过设置不同的props值来测试是否能render出我们期望的页面。比如有下面这样的一个组件：</p>

<p>{% codeblock lang:js %}
class Footer extends Component {
  renderFooterButtons(completedCount, clearCompleted) {</p>

<pre><code>// 测试点1
if (completedCount &gt; 0) {
  return (
    &lt;button className="clear-completed" onClick={ () =&gt; clearCompleted() }&gt;Clear completed&lt;/button&gt;
  );
}
</code></pre>

<p>  }</p>

<p>  render() {</p>

<pre><code>const { todos, actions, onShow } = this.props;
const { clearCompleted } = actions;
const activeCount = todos.reduce((count, todo) =&gt; todo.completed ? count : count + 1, 0);
const completedCount = todos.length - activeCount;
return (
  &lt;footer className="footer"&gt;
    &lt;span className="todo-count"&gt;&lt;strong&gt;{activeCount}&lt;/strong&gt; item left&lt;/span&gt;
    &lt;ul className="filters"&gt;
      // 测试点2
      {[SHOW_ALL, SHOW_ACTIVE, SHOW_COMPLETED].map(filter =&gt;
        &lt;li key={filter}&gt;
          &lt;a className={classnames({ selected: filter === this.props.filter })}
            style={{ cursor: 'pointer' }}
            onClick={ () =&gt; onShow(filter) }&gt;{FILTER_TITLES[filter]}&lt;/a&gt;
        &lt;/li&gt;
      )}
    &lt;/ul&gt;
    {this.renderFooterButtons(completedCount, clearCompleted)}
  &lt;/footer&gt;
);
</code></pre>

<p>  }
}
{% endcodeblock %}</p>

<p>可以看到这个组件其实是比较简单的，在一个<code>footer</code>标签里面有个<code>span</code>和一个<code>ul</code>，<code>ul</code>里面有一些<code>li</code>，最下面是个<code>button</code>。</p>

<ul>
<li>在最上面有一个render button的方法，这个方法存在逻辑判断，如果completedCount大于0，则render一个button出来，否则不render button，这里是我们第一个测试点。测试代码如下，分别测试render和不render的情况：</li>
</ul>


<p>{% codeblock lang:js %}
const props = {
  todos: [], // 空的数组
  actions: {</p>

<pre><code>clearCompleted: sinon.spy(), // mock方法
</code></pre>

<p>  },
  onShow: sinon.spy(), // mock方法
  filter: &lsquo;SHOW_ALL&rsquo;,
};</p>

<p>test(&lsquo;do not render button&rsquo;, t => {
  const wrapper = shallow(<Footer {...props} />);
  t.is(wrapper.find(&lsquo;button&rsquo;).length, 0);
});</p>

<p>test(&lsquo;render button correctly&rsquo;, t => {
  const wrapper = shallow(<Footer {...props} />);
  wrapper.setProps({ todos: [{ completed: true }] });
  t.is(wrapper.find(&lsquo;button&rsquo;).length, 1);
});
{% endcodeblock %}</p>

<p>要让completedCount不大于0，只要给个空的todos集合就可以了，如果要大于0的话，则需要在todos里面添加一个<code>completed</code>为true的对象，这里需要搞清楚completedCount的声明逻辑。</p>

<ul>
<li>第二个测试点是map方法里面的逻辑，因为是从一个有3个元素的数组里面做map，所以可以校验是否确实render出来3个<code>li</code>，以及其中某个<code>li</code>链接的class和文本内容。</li>
</ul>


<p>{% codeblock lang:js %}
test(&lsquo;render 3 li correctly&rsquo;, t => {
  const wrapper = shallow(<Footer {...props} />);
  wrapper.setProps({ todos: [{ completed: true }] });
  t.is(wrapper.find(&lsquo;li&rsquo;).length, 3);
  t.is(wrapper.find(&lsquo;a.selected&rsquo;).length, 1);
  t.is(wrapper.find(&lsquo;a.selected&rsquo;).text(), &lsquo;All&rsquo;);
});
{% endcodeblock %}</p>

<p>可以看到通过enzyme的text方法可以很方便地得到<code>a</code>标签的文本内容。</p>

<p>这个组件其实还继续做测试，比如<code>span</code>里面的render逻辑等，但这里就不详细举例了。</p>

<h2>组件的事件逻辑</h2>

<p>除了在render方法中有逻辑以外，在组件的事件中也会存在逻辑，要测试这部分代码，我们需要模拟触发组件的事件。请看下面这个组件：</p>

<p>{% codeblock lang:js %}
class TodoInput extends Component {
  constructor(props, context) {</p>

<pre><code>super(props, context);
this.state = {
  text: this.props.text || '',
};
</code></pre>

<p>  }</p>

<p>  handleChange(e) {</p>

<pre><code>this.setState({ text: e.target.value });
</code></pre>

<p>  }</p>

<p>  handleBlur(e) {</p>

<pre><code>if (!this.props.newTodo) {
  this.props.onSave(e.target.value.trim());
}
</code></pre>

<p>  }</p>

<p>  render() {</p>

<pre><code>return (
  &lt;input className={
    classnames({
      edit: this.props.editing,
      'new-todo': this.props.newTodo,
    })}
    type="text"
    placeholder={this.props.placeholder}
    autoFocus="true"
    value={this.state.text}
    onBlur={this.handleBlur.bind(this)}
    onChange={this.handleChange.bind(this)}
  /&gt;
);
</code></pre>

<p>  }
}
{% endcodeblock %}</p>

<p>可以看到这个组件的render方法里面没有什么逻辑，只有一个<code>input</code>标签，但是在标签中存在了<code>change</code>和<code>blur</code>事件，组件的逻辑隐藏在对应的事件方法中。</p>

<ul>
<li>首先是对<code>change</code>事件的测试，我们可以看到<code>handleChange</code>方法其实是修改state里面text的值，所以测试代码可以这样写：</li>
</ul>


<p>{% codeblock lang:js %}
const props = {
  text: &lsquo;foo&rsquo;,
  placeholder: &lsquo;foo placeholder&rsquo;,
  editing: false,
  newTodo: false,
  onSave: sinon.spy(),
};</p>

<p>test(&lsquo;input change value correctly&rsquo;, t => {
  const wrapper = shallow(<TodoInput {...props} />);
  wrapper.find(&lsquo;input&rsquo;).simulate(&lsquo;change&rsquo;, { target: { value: &lsquo;bar&rsquo; } });
  t.is(wrapper.state(&lsquo;text&rsquo;), &lsquo;bar&rsquo;);
});
{% endcodeblock %}</p>

<p>通过调用<code>simulate</code>方法对<code>change</code>事件进行模拟，然后调用<code>state</code>方法对组件的state进行校验。</p>

<ul>
<li>接着我们测试<code>blur</code>事件，<code>handleBlur</code>方法先做判断，如果为真则调用props中的<code>onSave</code>方法，我们可以用sinon来mock onSave方法，校验其调用次数。</li>
</ul>


<p>{% codeblock lang:js %}
test(&lsquo;input blur correctly&rsquo;, t => {
  const wrapper = shallow(<TodoInput {...props} />);
  wrapper.find(&lsquo;input&rsquo;).simulate(&lsquo;blur&rsquo;, { target: { value: &lsquo;bar&rsquo; } });
  t.is(props.onSave.callCount, 1);
{% endcodeblock %}</p>

<p>模拟事件触发的方法差不多，都是传入事件名和所需的方法对象就可以了，这里校验<code>onSave</code>是否被调用了1次。</p>

<p>在写单元测试的时候，有一点要注意的是要避免过度测试，因为测试代码也是需要维护的，如果测试过多过细，那一旦生产代码有所改变，就可能会修改很多测试代码，需要开发人员需要在质量和开发效率上面做好均衡。</p>
]]></content>
  </entry>
  
</feed>
