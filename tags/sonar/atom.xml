<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: sonar | Hacker and Geeker's Way]]></title>
  <link href="http://zhaozhiming.github.io/tags/sonar/atom.xml" rel="self"/>
  <link href="http://zhaozhiming.github.io/"/>
  <updated>2018-04-18T08:44:40+08:00</updated>
  <id>http://zhaozhiming.github.io/</id>
  <author>
    <name><![CDATA[赵芝明]]></name>
    <email><![CDATA[kingzzm1982@sina.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[利用Sonar定制自定义JS扫描规则（三）——SSLR JavaScript Toolkit 使用说明]]></title>
    <link href="http://zhaozhiming.github.io/blog/2013/05/20/use-sonar-create-customer-js-verify-rule-part-3/"/>
    <updated>2013-05-20T11:20:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2013/05/20/use-sonar-create-customer-js-verify-rule-part-3</id>
    <content type="html"><![CDATA[<p>在上一篇blog中讲了在sonar中如何新增自定义的JS规则，这里面比较难的地方是XPath语句的编写，而要编写正确的XPath语句，首先要拿到语法的AST，下面我们就来介绍如何使用SSLR JavaScript Toolkit 工具来得到源代码的语法树。</p>

<!--more-->


<p>首先通过在<a href="http://repository.codehaus.org/org/codehaus/sonar-plugins/javascript/sslr-javascript-toolkit/1.3/sslr-javascript-toolkit-1.3.jar">这里</a>下载SSLR JavaScript Toolkit 工具，下载下来是一个jar包，在cmd窗口使用java -jar sslr-javascript-toolkit-1.3.jar打开这个工具，操作界面如下：<br/>
{% img  /images/post/02073536-58b547f5394041cdb795a717087eca35.png %}</p>

<p>左上方的窗口是用来输入你的源代码，右上方的窗口是来显示你的AST，最下面的窗口是来输入你的XPath规则。</p>

<p>我们现在左上方输入一些简单的javascript代码，然后点击 Parse Source Code按钮，可以得到源代码的语法树：</p>

<p>{% img  /images/post/02074124-ca30984af1704101962348b52d4a5f34.png %}</p>

<p>得到语法树后，我们也可以点击右边窗口的XML页面，得到的是语法树的XML文档。有了XML文档，就可以通过XPath轻松得到你想要的语句了。</p>

<p>举个例子：比如我想得到本地变量名，即var关键字后面的变量名，可以通过XPath的语法来查询。</p>

<p>在最下方的窗口输入XPath语法规则，点击Evaluate XPath按钮，如果语法正确，就会出现返回结果，并高亮选中你想要查询的代码，如下：</p>

<p>{% img  /images/post/02074943-45053229678b4effbec60cf2c363b076.png %}</p>

<p>如果语法错误，右边的窗口会给出提示，如果查询语句不正确，任何源代码都不会被选中。更多的XPath语法可以参考<a href="http://www.w3schools.com/xpath/">http://www.w3schools.com/xpath/</a>。<br/>
总结：sonar其实很早就支持了对JS的代码校验，但是你如果想自己定制校验规则，最简单的方式就是通过sonar的web接口增加XPath规则，这个需要在XPath语法上多花点力气，如果写出来的查询语法不正确，可以多试几遍，用SSLR JavaScript Toolkit 可以很方便的调试。最后祝大家都可以在sonar上配置自己的自定义规则。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[利用Sonar定制自定义JS扫描规则（二）——自定义JS扫描规则]]></title>
    <link href="http://zhaozhiming.github.io/blog/2013/05/19/use-sonar-create-customer-js-verify-rule-part-2/"/>
    <updated>2013-05-19T11:20:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2013/05/19/use-sonar-create-customer-js-verify-rule-part-2</id>
    <content type="html"><![CDATA[<p>在上一篇blog中，我们将sonar几个需要的环境都搭建好了，包括sonar的服务器，sonar runner，sonar的javascript插件。现在我们就来讲如何自定义JS扫描规则。</p>

<!--more-->


<p>
实际上有3种方法可以自定义代码的校验规则：</p>

<ul>
<li>直接在sonar的web接口中增加XPath规则；</li>
<li>通过插件的功能来增加自定义规则，比如checkstyle，pmd等插件是允许自定义规则的；</li>
<li>通过新增一个代码分析器来实现自定义规则；</li>
</ul>


<p>sonar官方推荐的方式是使用最简单的XPath方式来增加自定义规则，如果语言太复杂或者XPath无法查询其结构的，再使用自定义插件的方式，所以我们这里重点介绍的是使用XPath的方式。</p>

<h3>使用XPath增加自定义JS规则</h3>

<p>sonar为大部分流行的语言（C, C#, C++, Cobol, Flex, JavaScript, PL/I, PL/SQL, Python and VB.NET）提供了一个简洁的方式来增加代码规则。这些新增规则必须使用<a href="http://en.wikipedia.org/wiki/XPath">XPath</a>来实现，这样的话语言的每一部分都可以映射到<a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree">Abstract Syntax Tree</a>（AST）。对于每一种语言，SSLR Toolkit 工具提供了代码转AST的功能，该工具具体的使用在下面会介绍，这里是<a href="http://repository.codehaus.org/org/codehaus/sonar-plugins/javascript/sslr-javascript-toolkit/1.3/sslr-javascript-toolkit-1.3.jar">SSLR Javascript Toolkit</a>工具的下载。如果对XPath不熟悉，可以参考这里看一下例子<a href="http://www.w3schools.com/xpath/">http://www.w3schools.com/xpath/</a>。<br/>
1、首先使用管理员的角色登录sonar，然后去到Settings > Quality Profile页面，选择Js规则（如下图所示）。</p>

<p>{% img  /images/post/02070803-9bce5fab1bf543059071fafff2ae37d8.png %}</p>

<p>2、接着在Coding rules页面输入查询条件，找到XPath规则：</p>

<p>{% img  /images/post/02070943-c9a5b7732ea6478fba266555c308fc29.png %}</p>

<p>3、查询结果出来后，点击Copy rule连接来新增规则：</p>

<p>{% img  /images/post/02071054-da90a48498234fc19d34aff75c84a104.png %}</p>

<p>4、按照XPath的语法编写自己的规则：</p>

<p>{% img  /images/post/02071436-15c170e9f4eb4f6684d95df76fe6e628.png %}</p>

<p>如果对XPath不熟悉，建议先学习一些XPath的语法，下面给出3个javascript xpath的规则：</p>

<h5>不要使用document.write:</h5>

<p>{% codeblock lang:text %}
//callExpression/memberExpression[count(*) = 3 and primaryExpression[@tokenValue = &ldquo;document&rdquo;] and identifierName[@tokenValue = &ldquo;write&rdquo;]]
{% endcodeblock %}</p>

<h5>if/else语句后面必须接大括号：</h5>

<p>{% codeblock lang:text %}
//ifStatement/statement[not(block)]
{% endcodeblock %}</p>

<h5>本地变量名以XX开头：</h5>

<p>{% codeblock lang:text %}
//functionBody//variableDeclaration/IDENTIFIER[not(starts-with(@tokenValue,&lsquo;zzm&rsquo;))]
{% endcodeblock %}</p>

<p>5、创建好规则之后，把规则设置为active，将规则的级别调高一些就会自动变为active，然后重新跑一下规则分析，这样新增的规则就生效了。</p>

<p>{% img  /images/post/02072520-4308a5a558d04ded998bb54f452c71f7.png %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[利用Sonar定制自定义JS扫描规则（一）——sonar环境搭建]]></title>
    <link href="http://zhaozhiming.github.io/blog/2013/05/19/use-sonar-create-customer-js-verify-rule-part-1/"/>
    <updated>2013-05-19T11:20:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2013/05/19/use-sonar-create-customer-js-verify-rule-part-1</id>
    <content type="html"><![CDATA[<p>接触sonar已经有段时间了，最早是在一个项目组里面听到这个框架，后来在公司持续集成活动的推动下，也逐渐学习了sonar的具体功能。sonar集成了findbugs，pmd，checkstyle各种静态代码检查工具的功能，并且可以将各种扫描结果组合成一张张漂亮的报告，功能很是强大。下面介绍一下如何使用sonar来自定义javascrpit的扫描规则。</p>

<!--more-->


<p>虽然使用过很多次sonar，但都是在别人搭好的环境上使用的，自己还没有真正搭建过，这里首先介绍一下sonar环境的搭建。</p>

<h3>sonar环境搭建</h3>

<p>首先到sonar官网上下载其最新版本，我下的是3.5.1。下下来是一个zip包，直接将其解压到你想要安装的目录就好了。</p>

<h4>使用H2内存数据库</h4>

<p>sonar服务的启动是要有数据库来支持的，sonar本身自带了H2内存数据库，可以直接使用。在解压目录下的conf目录下，有一个sonar.properties的配置文件是来保存sonar的配置，如果你使用的是H2数据库的话，将配置文件中的下面部分代码注释去掉即可。</p>

<p>{% codeblock sonar.properties lang:properties %}</p>

<h1>sonar.jdbc.url:                            jdbc:h2:tcp://localhost:9092/sonar</h1>

<h1>sonar.jdbc.driverClassName:                org.h2.Driver</h1>

<p>{% endcodeblock %}</p>

<p>在解压目录下的extras\database\mysql目录，有2个mysql的sql文件，其中1个是创建sonar数据库和用户的脚本，可以参照这个脚本来创建H2的sonar相关数据库和用户。</p>

<h4>使用外部数据库（以mysql为例）</h4>

<p>sonar官网强烈建议，如果你的产品只是学习或者练习用的demo，可以使用内存数据库，否则请使用外部数据库。sonar支持大部分主流的数据库，比如mysql，oracle，postgresql，Microsoft SQLServer。</p>

<p>我们以mysql为例，首先安装mysql（安装mysql的过程就不再详细描述，网上有很多），这里要注意将数据库的字符集设置为UTF-8。安装完成之后，同样修改conf目录下的sonar.properties文件，将mysql部分的配置项打开。然后在mysql中将上面提到的那个创建sonar数据库和用户脚本施行一遍。</p>

<p>{% codeblock sonar.properties lang:properties %}</p>

<h1>&mdash;&mdash;&ndash; MySQL 5.x</h1>

<h1>Comment the embedded database and uncomment the following line to use MySQL</h1>

<h1>sonar.jdbc.url:                            jdbc:mysql://localhost:3306/sonar?useUnicode=true&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=true</h1>

<p>{% endcodeblock %}</p>

<h4>启动服务</h4>

<p>数据库配置完成之后，就可以来启动web服务了，去到解压目录下的bin目录，找到自己相关系统的目录，以64位windows系统为例，目录为：bin\windows-x86-64，运行该目录下的Startsonar.bat文件，如果启动没有报错的话，就可以在浏览器中输入：<code>http://localhost:9000</code>，查看sonar的主界面了。</p>

<h3>安装Sonar Runner</h3>

<p>上面搭建的只是sonar的服务平台，如果想用sonar来分析自己项目代码的话，可以有多种方式，比如ant、maven等，而sonar官网上推荐的是使用Sonar Runner来执行分析项目的操作。</p>

<p>首先去到sonar官网下载Sonar Runner的压缩包，和sonar的压缩包一样，先解压到你要安装的目录。然后增加SONAR_RUNNER_HOME这个环境变量，变量值为你runner的解压目录，然后将$SONAR_RUNNER_HOME$/bin的加到PATH变量后面（配置过java环境变量的同学都懂的）。这样就安装完成了，打开cmd验证一下，打出sonar-runner -h，如果出现下面的提示信息，即表示你的runner安装成功了。</p>

<p>{% codeblock lang:sh %}
usage: sonar-runner [options]</p>

<p>Options:
 -h,&mdash;help             Display help information
 -X,&mdash;debug            Produce execution debug output
 -D,&mdash;define <arg>     Define property
{% endcodeblock %}</p>

<p>安装完runner以后，在你的项目根目录下，增加sonar-project.properties文件，内容如下：</p>

<p>{% codeblock sonar.properties lang:properties %}</p>

<h1>required metadata</h1>

<p>sonar.projectKey=my:project
sonar.projectName=My project
sonar.projectVersion=1.0</p>

<h1>optional description</h1>

<p>sonar.projectDescription=Fake description</p>

<h1>path to source directories (required)</h1>

<p>sonar.sources=srcDir1,srcDir2</p>

<h1>path to test source directories (optional)</h1>

<p>sonar.tests=testDir1,testDir2</p>

<h1>path to project binaries (optional), for example directory of Java bytecode</h1>

<p>sonar.binaries=binDir</p>

<h1>optional comma-separated list of paths to libraries. Only path to JAR file is supported.</h1>

<p>sonar.libraries=path/to/library/<em>.jar,path/to/specific/library/myLibrary.jar,parent/</em>/*.jar</p>

<h1>The value of the property must be the key of the language.</h1>

<p>sonar.language=java</p>

<h1>Additional parameters</h1>

<p>sonar.my.property=value
{% endcodeblock %}</p>

<p>上面的配置项根据名字和说明大概知道是做什么用的了，填上自己项目中对应的值即可。然后打开cmd窗口，去到你的项目根目录下，执行sonar-runner命令，这样sonar就开始分析你的项目代码了，分析完成之后，在浏览器中刚才那个9000端口地址的网页中就可以看到你的项目了。</p>

<h3>安装Javascript插件</h3>

<p>使用管理员的角色登录sonar，根据这个路径进入更新中心：Settings > System > Update Center。在Available Plugins窗口找到javascript插件，点击其中的install按钮进行安装（如下图所示）。安装完后重启sonar服务器即可。</p>

<p>{% img /images/post/01202231-c4477ac31ac3411686f1a4b98ae3ece1.png %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在jenkins和sonar中集成jacoco(四)--在sonar中集成jacoco]]></title>
    <link href="http://zhaozhiming.github.io/blog/2012/12/02/use-jacoco-in-jenkins-and-sonar-part-4/"/>
    <updated>2012-12-02T14:46:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2012/12/02/use-jacoco-in-jenkins-and-sonar-part-4</id>
    <content type="html"><![CDATA[<p>首先要得到之前的单元测试和集成测试的覆盖率文件，还有对应的class文件以及单元测试的覆盖率报告，材料准备齐全之后，使用如下命令：</p>

<!--more-->


<p>{% codeblock build.xml lang:xml %}
<taskdef uri="antlib:org.sonar.ant" resource="org/sonar/ant/antlib.xml"></p>

<pre><code>    &lt;classpath path="${env.SONAR-ANT-TASK.JAR}"/&gt;
&lt;/taskdef&gt;

&lt;target name="sonar"&gt;
    &lt;sonar:sonar key="${sonar.project.key}" version="${sonar.project.version}" xmlns:sonar="antlib:org.sonar.ant"&gt;
        &lt;sources&gt;
            &lt;path location="${src.dir}" /&gt;
        &lt;/sources&gt;

        &lt;property key="sonar.projectName" value="jacoco_demo" /&gt;
        &lt;property key="sonar.sourceEncoding" value="UTF-8" /&gt;
        &lt;property key="sonar.dynamicAnalysis" value="reuseReports" /&gt;
        &lt;property key="sonar.surefire.reportsPath" value="${junit.dir}" /&gt;
        &lt;property key="sonar.core.codeCoveragePlugin" value="jacoco" /&gt;
        &lt;property key="sonar.jacoco.reportPath" value="${basedir}/ut.exec" /&gt;
        &lt;property key="sonar.jacoco.itReportPath" value="${basedir}/uat.exec" /&gt;

        &lt;tests&gt;
            &lt;path location="${src.test.dir}" /&gt;
        &lt;/tests&gt;

        &lt;binaries&gt;
            &lt;path location="${build.src.class}" /&gt;
            &lt;path location="${build.test.class}" /&gt;
        &lt;/binaries&gt;

        &lt;libraries&gt;
            &lt;path location="${build.lib.dir}" /&gt;
        &lt;/libraries&gt;
    &lt;/sonar:sonar&gt;
&lt;/target&gt;
</code></pre>

<p>{% endcodeblock %}</p>

<p>参数解释：</p>

<ul>
<li>sonar.dynamicAnalysis是指单元测试报告的生成方式，值为reuseReports是指给出生成好的单元测试报告路径。</li>
<li>sonar.surefire.reportsPath是指单元测试报告的路径。</li>
<li>sonar.core.codeCoveragePlugin是覆盖率插件，有jacoco,cobetura等。</li>
<li>sonar.jacoco.reportPath是单元测试覆盖率文件的路径。</li>
<li>sonar.jacoco.itReportPath是集成测试覆盖率文件的路径。</li>
</ul>


<p>更多参数可以参考这里：<a href="http://docs.codehaus.org/display/SONAR/Code+Coverage+by+Unit+Tests">单元测试</a>，<a href="http://docs.codehaus.org/display/SONAR/Code+Coverage+by+Integration+Tests">集成测试</a><br/>
在sonar 3.3的版本会自动将单元测试和集成测试的覆盖率合并，最后附上sonar上的覆盖率显示：</p>

<p>{% img /images/post/2012112914305954.png %}<br/>
{% img /images/post/2012112914311753.png %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在jenkins和sonar中集成jacoco(三)--使用jacoco收集集成测试的覆盖率]]></title>
    <link href="http://zhaozhiming.github.io/blog/2012/12/01/use-jacoco-in-jenkins-and-sonar-part-3/"/>
    <updated>2012-12-01T14:45:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2012/12/01/use-jacoco-in-jenkins-and-sonar-part-3</id>
    <content type="html"><![CDATA[<p>我们系统使用weblogic做服务器，集成测试框架使用的是junit+selenium。</p>

<p>首先，要把jacoco的jacocoagent.jar包放到部署应用的服务器上，接着在系统服务的JAVA_OPTIONS 后面添加如下参数：</p>

<!--more-->


<p>
{% codeblock lang:sh %}
-javaagent:[yourpath/]jacocoagent.jar=includes=com.xxx.xxx.*,output=tcpserver,address=xxx.xxx.xxx.xxx,port=xxxxx
{% endcodeblock %}</p>

<p>参数解释：</p>

<ol>
<li>前面的yourpath是放jacocoagent.jar文件的目录路径；</li>
<li>includes是指要收集哪些类（注意不要关写包名，最后要写.*)，不写的话默认是*，会收集应用服务上所有的类，包括服务器和其他中间件的类，一般要过滤；</li>
<li>output有4个值，分别是file,tcpserver,tcpclient,mbean，默认是file。使用file的方式只有在停掉应用服务的时候才能产生覆盖率文件，而使用tcpserver的方式可以在不停止应用服务的情况下下载覆盖率文件，后面会介绍如何使用dump方法来得到覆盖率文件。</li>
<li>address是ip， port是端口，这是使用tcpserver方式需要的2个参数，也是后面dump方法要用到的。（这里的address我只能使用服务器的ip，如果使用其他ip，服务启动时会报错。）</li>
</ol>


<p>更多参数可以参考<a href="http://www.eclemma.org/jacoco/trunk/doc/agent.html">java agent</a>。<br/>
配置完应用服务的JAVA_OPTIONS之后，启动服务器，然后可以开始跑你的集成测试，跑完之后，实际上jacocoagent已经将覆盖率数据记录下来了，我们可以使用下面的ant任务来dump出覆盖率文件：</p>

<p>{% codeblock build.xml lang:xml %}
　 <target name="downloadUatCoverageData"></p>

<pre><code>    &lt;jacoco:dump address="xxx.xxx.xxx.xxx" port="xxxx" reset="true" destfile="${basedir}/uat.exec" append="false"/&gt;
&lt;/target&gt;
</code></pre>

<p>{% endcodeblock %}</p>

<p>这里的address和port是刚才在JAVA_OPTIONS里面写的address和port的值，destfile是指生成的覆盖率文件路径。</p>

<p><strong>注意，这里虽然得到了集成测试的覆盖率文件，但是需要应用服务器上的类文件才能产出相应的覆盖率报告，如果类文件是其他JVM编译的，产出的报告覆盖率是0%。</strong></p>

<p>有2种方法可以得到覆盖率文件所需的class文件：</p>

<ol>
<li>将应用服务部署的包（ear或war或jar）包下载下来之后解压，即可得到对应的class文件；</li>
<li>在前面做单元测试之后，可以将class文件打成一个zip包，然后上传到服务器，最后在需要的时候去服务器上取。</li>
</ol>


<p>得到集成测试的覆盖率文件之后，结合之前取到的单元测试覆盖率文件，我们可以将2个文件合并，得到综合的覆盖率文件，命令如下：</p>

<p>{% codeblock build.xml lang:xml %}
　<target name="mergeCoverage"></p>

<pre><code>    &lt;jacoco:merge destfile="merged.exec"&gt;
        &lt;fileset dir="${basedir}" includes="*.exec"/&gt;
    &lt;/jacoco:merge&gt;
</code></pre>

<p>   </target>
{% endcodeblock %}</p>
]]></content>
  </entry>
  
</feed>
