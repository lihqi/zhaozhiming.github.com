<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: angularjs | Hacker and Geeker's Way]]></title>
  <link href="http://zhaozhiming.github.io/tags/angularjs/atom.xml" rel="self"/>
  <link href="http://zhaozhiming.github.io/"/>
  <updated>2016-12-13T11:25:35+08:00</updated>
  <id>http://zhaozhiming.github.io/</id>
  <author>
    <name><![CDATA[赵芝明]]></name>
    <email><![CDATA[kingzzm1982@sina.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[最近小项目的一些记录（二）]]></title>
    <link href="http://zhaozhiming.github.io/blog/2014/05/31/some-tips-in-my-recent-project-2/"/>
    <updated>2014-05-31T10:40:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2014/05/31/some-tips-in-my-recent-project-2</id>
    <content type="html"><![CDATA[<p><a href="http://zhaozhiming.github.io/blog/2014/05/31/some-tips-in-my-recent-project/">前一篇post</a>主要记录了Spring JPA和Hibernate的问题，接着记录其他一些工具遇到的问题。</p>

<!--more-->


<p></p>

<h2>Jsoup</h2>

<p><a href="https://github.com/jhy/jsoup">Jsoup</a>是一个比较火的Java解析Html工具，简单易用，功能强大，在github上有不少星星。</p>

<h3>使用Jsoup连接url时报403</h3>

<p>一般使用Jsoup连接url都不会有什么问题，正常的写法如下：</p>

<p>{% codeblock lang:java %}</p>

<pre><code>Jsoup.connect(url).get();
</code></pre>

<p>{% endcodeblock %}</p>

<p>但有些网站会获取用户的浏览器信息，而上面的写法是没有浏览器信息的，这个时候就会报403的错误，需要在连接时加上userAngent。</p>

<p>{% codeblock lang:java %}</p>

<pre><code>Jsoup.connect(url).userAgent("Mozilla").get();
</code></pre>

<p>{% endcodeblock %}</p>

<h3>Css Selector</h3>

<p>使用Jsoup来抓取网页信息，最简单的一种方式就是通过Css selector，这样可以让你少写很多代码。比如下面的一段html:</p>

<p>{% codeblock lang:html %}</p>

<pre><code>&lt;div id="main"&gt;
    &lt;div class="header"&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>

<p>{% endcodeblock %}</p>

<p>使用css selector可以这样简单的获得。</p>

<p>{% codeblock lang:java %}</p>

<pre><code>doc.select("#main div.header")
</code></pre>

<p>{% endcodeblock %}</p>

<h2>Velocity</h2>

<p>项目用到了Velocity来定制邮件模板，这样可以方便的修改邮件格式。在网上可以搜到很多关于Spring和Velocity集成的文章，但大部分是讲如何使用Velocity来生成页面的，而如何生成其他文件的说明比较少，下面我们就来看一下如何配置的。</p>

<ul>
<li><p>先配置velocityConfigurer的bean，这里定义了模板文件的路径，属性和编码等信息。
{% codeblock lang:xml %}
  <bean id="velocityConfigurer"
        class="org.springframework.web.servlet.view.velocity.VelocityConfigurer">
      <property name="resourceLoaderPath" value="WEB-INF/velocity" />
      <property name="velocityProperties">
          <props>
              <prop key="directive.foreach.counter.name">
                  loopCounter
              </prop>
              <prop key="directive.foreach.counter.initial.value">
                  0
              </prop>
              <prop key="input.encoding">UTF-8</prop>
              <prop key="output.encoding">UTF-8</prop>
          </props>
      </property>
  </bean>
{% endcodeblock %}</p></li>
<li><p>在需要使用的Sevice里面引入，这样就可以在service里面使用到Velocity的配置信息了。
{% codeblock lang:java %}
@Service
public class MailService {
  @Resource(name = &ldquo;velocityConfigurer&rdquo;)
  private VelocityConfigurer velocityConfigurer;
} <br/>
{% endcodeblock %}</p></li>
<li><p>使用Velocity的工具类来得到生成的文件信息。</p>

<ul>
<li>temple是模板文件的名称。</li>
<li>model是生成文件所需的参数。
{% codeblock lang:java %}
String content = VelocityEngineUtils.mergeTemplateIntoString(
          velocityConfigurer.getVelocityEngine(), temple,
          MAIL_ENCODING, model);
{% endcodeblock %}</li>
</ul>
</li>
</ul>


<h3>Angularjs</h3>

<p>Angularjs功能比较强大，使用它之后基本可以不用使用JQuery了，这里记录一下使用遇到的一个比较奇怪的问题。</p>

<ul>
<li>问题: 使用Angularjs发起一个post请求，带了几个请求的参数，后台接收请求时获取不到参数。开始的写法如下：</li>
</ul>


<p>{% codeblock lang:js %}</p>

<pre><code>var queryData = {
            "depGroup": $("#dep_group").val() || "",
            "website": $("#website").val() || "",
            "startDate": $("#start_date").val() || "",
            "endDate": $("#end_date").val() || ""
        };

$http.post('api/search', queryData).success(function (data) {
                $scope.blogs = data;
            });
</code></pre>

<p>{% endcodeblock %}</p>

<ul>
<li>接收不到参数的原因是angularjs把参数转成了json导致后台接收不到，需要在发起请求时将参数转换一下，修改后的代码如下：</li>
</ul>


<p>{% codeblock lang:js %}</p>

<pre><code>var postConfig = {
    headers: { 'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'},
    transformRequest: transform
};

$http.post('api/search', queryData，postConfig).success(function (data) {
                $scope.blogs = data;
</code></pre>

<p>{% endcodeblock %}</p>

<h3>Semantic-ui</h3>

<p>这个是我比较喜欢的一个css框架，这里要注意的地方是有些功能和Angularjs结合起来会发现不起作用，如果不起作用可以尝试使用<a href="https://github.com/caitp/angular-semantic">angular-semantic</a>这个工具看看能否解决问题。</p>

<ul>
<li>semantic-ui的表单规则和行为设置，简单的示例如下，需要设置规则(rules)和配置(setting即校验通过后的行为)。</li>
</ul>


<p>js代码:<br/>
{% codeblock lang:js %}</p>

<pre><code>var rules = {
    searchKeyword: {
        identifier: 'searchKeyword',
        rules: [
            {
                type: 'empty',
                prompt: '请输入查询关键字'
            }
        ]
    }
};

var setting = {
    onSuccess: function () {
        // 发http请求
    }
};

$('#searchForm').form(rules, setting);
</code></pre>

<p>{% endcodeblock %}</p>

<p>html代码:
{% codeblock lang:html %}</p>

<pre><code>&lt;div id="searchForm" class="ui form"&gt;
    &lt;div class="two fields"&gt;
        &lt;div class="field"&gt;
            &lt;div class="ui icon input"&gt;
                &lt;input id="searchKeyword" type="text" name="searchKeyword" placeholder="请输入查询关键字..."&gt;
                &lt;i class="search icon"&gt;&lt;/i&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;div class="field"&gt;
            &lt;div id="searchBtn" class="ui blue submit button"&gt;查询&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class="ui error message"&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>

<p>{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[最近小项目的一些记录（一）]]></title>
    <link href="http://zhaozhiming.github.io/blog/2014/05/31/some-tips-in-my-recent-project/"/>
    <updated>2014-05-31T09:09:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2014/05/31/some-tips-in-my-recent-project</id>
    <content type="html"><![CDATA[<p>最近花了2个星期的时间做了一个小网站，用来统计部门同事发布的博客情况。需求比较简单，做这个项目的时候就顺便把以前学到的东西整合到了一起，从前端到后台，从编码到部署（“全栈工程师”？呵呵），虽然事情比较琐碎但也学到了不少东西，下面就记录一下开发过程中遇到的一些问题。</p>

<!--more-->


<p></p>

<h2>技术栈</h2>

<p>这里先列举一下项目用到的一些技术，其实这些东西就是自己的工具箱，要慢慢丰富，要及时更新，这样才能做出来好东西。</p>

<ul>
<li>Spring4 MVC</li>
<li>Hibernate orm</li>
<li>Spring Data JPA</li>
<li>AngularJS(Javascript MVW Framework)</li>
<li>Semantic UI(CSS Framework)</li>
<li>Velocity(for mail)</li>
<li>Gradle</li>
<li>SAE(Sina App Engine)</li>
</ul>


<h2>Spring JPA</h2>

<p>项目遇到不少的问题都来自JPA，也有一部分原因是由于SAE的MySql数据库是读写分离的两个库，所以要配置多个数据源才能在上面正常读写数据。<br/>
JPA有个好处就是操作数据库时不用写太多代码，不用像以前一样写一个接口再写一个实现，只需要一个接口就可以完成基本的操作了，如果有特殊的操作则可以通过标签的方式来写sql。</p>

<h3>Spring JPA配置多个persistence-unit(或多个数据源）</h3>

<ul>
<li><p>首先增加JPA的多persistence-unit的管理Bean。
{% codeblock lang:xml %}
  <bean id="persistenceUnitManager"
        class="org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager">
      <property name="persistenceXmlLocation" value="classpath:META-INF/persistence.xml"/>
      <!--  comment dataSourceLooup to use jndi -->
      <property name="dataSourceLookup">
          <bean class="org.springframework.jdbc.datasource.lookup.BeanFactoryDataSourceLookup"/>
      </property>
  </bean>
{% endcodeblock %}</p></li>
<li><p>然后配置多套DataSource，EntityManagerFactory，TransactionManger和jpa:repository，这里要重点注意jps:repository的配置也要有多套，否则启动就会报<code>No unique bean of type [javax.persistence.EntityManagerFactory] is defined: expected single bean but found 2</code>的错误。
{% codeblock lang:xml %}
  <!--write persistence unit config-->
  <bean id="writeJpaVendor"
        class="org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter">
      <property name="showSql" value="true"/>
      <property name="generateDdl" value="true"/>
  </bean></p>

<p>  <bean id="writeDataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource " destroy-method="close">
      <property name="driverClass" value="com.mysql.jdbc.Driver"/>
      <property name="jdbcUrl" value="jdbc:mysql://localhost:3306/deblog"/>
      <property name="user" value="root"/>
      <property name="password" value="root"/>
      <property name="acquireIncrement" value="1"/>
      <property name="initialPoolSize" value="5"/>
      <property name="maxPoolSize" value="20"/>
      <property name="minPoolSize" value="5"/>
      <property name="maxStatements" value="100"/>
      <property name="testConnectionOnCheckout" value="true"/>
  </bean></p>

<p>  <bean id="writeEntityManagerFactory" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean">
      <property name="persistenceUnitManager" ref="persistenceUnitManager" />
      <property name="persistenceUnitName" value="mainPersistenceUnit"/>
      <property name="jpaVendorAdapter" ref="writeJpaVendor" />
      <property name="loadTimeWeaver">
          <bean class="org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver" />
      </property>
      <property name="jpaDialect">
          <bean class="org.springframework.orm.jpa.vendor.HibernateJpaDialect"/>
      </property>
  </bean></p>

<p>  <bean id="writeTransactionManager" class="org.springframework.orm.jpa.JpaTransactionManager">
      <property name="entityManagerFactory" ref="writeEntityManagerFactory"/>
      <qualifier value="writeEm" />
      <property name="jpaDialect">
          <bean class="org.springframework.orm.jpa.vendor.HibernateJpaDialect" />
      </property>
  </bean></p>

<p>  &lt;jpa:repositories base-package=&ldquo;com.github.dba.repo.write&rdquo;
                    entity-manager-factory-ref=&ldquo;writeEntityManagerFactory&rdquo;
                    transaction-manager-ref=&ldquo;writeTransactionManager&rdquo; /></p>

<p>  &lt;tx:annotation-driven transaction-manager=&ldquo;writeTransactionManager&rdquo;/>
{% endcodeblock %}</p></li>
<li><p>在persistence.xml文件中增加多个unit,这里以一个unit为例，多个的话只要persistence-unit的name不一样就可以了。下面的例子引用了之前的datasource的配置，可以不需要再配置一次jdbc信息。
{% codeblock lang:xml %}
  &lt;persistence-unit name=&ldquo;mainPersistenceUnit&rdquo; transaction-type=&ldquo;RESOURCE_LOCAL&rdquo;>
      <provider>org.hibernate.ejb.HibernatePersistence</provider>
      &lt;non-jta-data-source>writeDataSource&lt;/non-jta-data-source>
      <class>com.github.dba.model.Blog</class>
      <class>com.github.dba.model.DepGroup</class>
      <class>com.github.dba.model.DepMember</class>
      <class>com.github.dba.model.BlogView</class>
      <properties>
          <property name="javax.persistence.jdbc.driver" value="com.mysql.jdbc.Driver" />
          <property name="javax.persistence.jdbc.url" value="jdbc:mysql://localhost:3306/deblog" />
          <property name="javax.persistence.jdbc.user" value="root" />
          <property name="javax.persistence.jdbc.password" value="root" /></p>

<pre><code>      &lt;property name="hibernate.dialect" value="org.hibernate.dialect.MySQLDialect" /&gt;
      &lt;property name="hibernate.show_sql" value="true" /&gt;
      &lt;property name="hibernate.hbm2ddl.auto" value="update" /&gt;
  &lt;/properties&gt;
</code></pre>

<p>  &lt;/persistence-unit>
{% endcodeblock %}</p></li>
</ul>


<h3>Spring JPA动态查询</h3>

<ul>
<li>首先在model类中增加一个静态方法，用来生成本次查询的动态条件。

<ul>
<li>下面的例子假设depGroup, website, startDate, endDate都可能有值。</li>
<li>where中的"=&ldquo;,&rdquo;&lt;&ldquo;,&rdquo;>&ldquo;可以在CriteriaBuilder中找到相应的方法，还有比如like等。</li>
<li>如果是嵌套对象的话，比如Blog对象包含Author对象，要对比Author对象的值，则可以用这种方式来取值: <code>root.&lt;Author&gt;get("author").&lt;String&gt;get("groupName")</code>。</li>
</ul>
</li>
</ul>


<p>{% codeblock lang:java %}</p>

<pre><code>public static Specification&lt;Blog&gt; querySpecification(final String depGroup, final String website,
                                                     final String startDate, final String endDate) {
    return Specifications.where(new Specification&lt;Blog&gt;() {
        @Override
        public Predicate toPredicate(Root&lt;Blog&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) {
            Predicate predicate = cb.conjunction();

            if (!Strings.isNullOrEmpty(depGroup) &amp;&amp; !"*".equals(depGroup)) {
                predicate.getExpressions().add(
                        cb.equal(root.&lt;Author&gt;get("author").&lt;String&gt;get("groupName"), depGroup));
            }

            if (!Strings.isNullOrEmpty(website) &amp;&amp; !"*".equals(website)) {
                predicate.getExpressions().add(
                        cb.equal(root.&lt;String&gt;get("website"), website));
            }

            if (!Strings.isNullOrEmpty(startDate)) {
                try {
                    long time = DbaUtil.parseTimeStringToLong(startDate, PAGE_DATE_FORMAT);
                    predicate.getExpressions().add(cb.ge(root.&lt;Long&gt;get("time"), time));
                } catch (ParseException e) {
                    throw new RuntimeException(format("%s parse to date error:", startDate));
                }
            }

            if (!Strings.isNullOrEmpty(endDate)) {
                try {
                    long time = DbaUtil.parseTimeStringToLong(endDate, PAGE_DATE_FORMAT);
                    predicate.getExpressions().add(cb.le(root.&lt;Long&gt;get("time"), time));
                } catch (ParseException e) {
                    throw new RuntimeException(format("%s parse to date error:", endDate));
                }
            }

            return predicate;
        }
    });
}
</code></pre>

<p>{% endcodeblock %}</p>

<ul>
<li>写好了动态查询条件后，就要把它放到查询语句里面了，比如要查询所有数据，示例如下，例子还加了一个对时间的排序条件。<br/>
{% codeblock lang:java %}
      List<Blog> blogs = blogReadRepository.findAll(
              Blog.querySpecification(depGroup, website, startDate, endDate),
              new Sort(Sort.Direction.DESC, &ldquo;time&rdquo;));
{% endcodeblock %}</li>
</ul>


<h3>嵌套对象</h3>

<p>这个可能跟JPA没有多大关系，更多是跟Hibernate有关，但都属于db层面的，就写在一起了。</p>

<p>比如有张表是Blog，这样用Hibernate-orm对应到程序就有一个Blog类，如果Blog属性比较多的话，后续就会变成了一个大类。我们想在数据库只对应一张表的情况下，可以对应到程序的多个类，比如Blog类下面有个Author的类，要怎么做呢？可以用<code>@Embedded</code>标签来解决这个问题。<br/>
{% codeblock lang:java %}
@Entity(name = &ldquo;blogs&rdquo;)
public class Blog {</p>

<pre><code>@Id
@GeneratedValue(strategy = GenerationType.AUTO)
private Long id;

@Embedded
private Author author;
</code></pre>

<p>}</p>

<p>@Embeddable
public class Author {</p>

<pre><code>@Basic
private String name;
</code></pre>

<p>}
{% endcodeblock %}<br/>
分离成多个对象的话，有个好处就是可以在不同的model添加不同的逻辑计算，避免把所有逻辑都放在一个类里面，这也是面向对象设计时要考虑的一个问题。但数据库始终只对应一张表，操作简单。</p>

<p>下一篇: <a href="http://zhaozhiming.github.io/blog/2014/05/31/some-tips-in-my-recent-project-2/">最近小项目的一些记录（二）</a></p>
]]></content>
  </entry>
  
</feed>
