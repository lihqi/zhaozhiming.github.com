<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: TPP | Hacker and Geeker's Way]]></title>
  <link href="http://zhaozhiming.github.io/tags/tpp/atom.xml" rel="self"/>
  <link href="http://zhaozhiming.github.io/"/>
  <updated>2018-04-18T08:44:40+08:00</updated>
  <id>http://zhaozhiming.github.io/</id>
  <author>
    <name><![CDATA[赵芝明]]></name>
    <email><![CDATA[kingzzm1982@sina.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用TPP来控制TDD的节奏做好单元测试]]></title>
    <link href="http://zhaozhiming.github.io/blog/2014/12/14/use-tpp-to-do-tdd/"/>
    <updated>2014-12-14T06:58:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2014/12/14/use-tpp-to-do-tdd</id>
    <content type="html"><![CDATA[<p>{% img /images/post/2014-12/tpp.jpeg %}</p>

<p>最近参加了一次编程活动，大家在一起讨论单元测试和TDD(测试驱动开发)，有人提到了<a href="http://en.wikipedia.org/wiki/Robert_Cecil_Martin">Uncle Bob</a>的TPP(Transformation Priority Premise)——变形动作的优先顺序，可以帮助我们控制好TDD的节奏。</p>

<!--more-->


<p>关于TPP的详细信息可以查看Uncle Bob的<a href="http://blog.8thlight.com/uncle-bob/2013/05/27/TheTransformationPriorityPremise.html">这篇博文</a>，核心的思想如下:</p>

<ul>
<li>({}–>nil) no code at all->code that employs nil</li>
<li>(nil->constant)</li>
<li>(constant->constant+) a simple constant to a more complex constant</li>
<li>(constant->scalar) replacing a constant with a variable or an argument</li>
<li>(statement->statements) adding more unconditional statements.</li>
<li>(unconditional->if) splitting the execution path</li>
<li>(scalar->array)</li>
<li>(array->container)</li>
<li>(statement->recursion)</li>
<li>(if->while)</li>
<li>(expression->function) replacing an expression with a function or algorithm</li>
<li>(variable->assignment) replacing the value of a variable.</li>
</ul>


<p>为了验证一下TPP是否有效，我用<a href="http://butunclebob.com/ArticleS.UncleBob.ThePrimeFactorsKata">PrimeFactorsKata</a>来做练习，然后使用go语言来写，这样可以顺便练练go的语法。</p>

<h2>({}–>nil) no code at all->code that employs nil</h2>

<p>首先我们写第一个测试，当传入<code>1</code>时返回一个空的集合，用最简单的代码实现功能，直接返回<code>nil</code>，这样就完成了从没有代码到<code>nil</code>的过程。<br/>
PS: 这里我使用了<a href="https://github.com/stretchr/testify"><code>stretchr/testify</code></a>这个单元测试第三方包，它的使用方法就跟Java的Junit一样简单。</p>

<p>{% codeblock prime_test.go lang:go %}
package prime</p>

<p>import (</p>

<pre><code>"github.com/stretchr/testify/assert"
"testing"
</code></pre>

<p>)</p>

<p>func Test_given_1_then_return_empty_list(t *testing.T) {</p>

<pre><code>assert.Equal(t, []int{}, Prime(1))
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>{% codeblock prime.go lang:go %}
package prime</p>

<p>func Prime(num int) []int {</p>

<pre><code>return nil
</code></pre>

<p>}
{% endcodeblock %}</p>

<h2>(nil->constant)</h2>

<p>执行测试我们发现测试案例是不通过的，所以我们需要让测试变绿，让方法返回一个空的集合。</p>

<p>{% codeblock prime.go lang:go %}
func Prime(num int) []int {</p>

<pre><code>return []int{}
</code></pre>

<p>}
{% endcodeblock %}</p>

<h2>(constant->constant+) a simple constant to a more complex constant</h2>

<h2>(unconditional->if) splitting the execution path</h2>

<p>接着我们写第二个测试，当传入<code>2</code>时返回只有<code>2</code>的集合，同时修改实现代码，让原来返回的空集合变成包含<code>2</code>的一个集合，同时加上判断，如果<code>num</code>小于2时还是返回空集合。</p>

<p>{% codeblock prime_test.go lang:go %}
func Test_given_2_then_return_2(t *testing.T) {</p>

<pre><code>assert.Equal(t, []int{2}, Prime(2))
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>{% codeblock prime.go lang:go %}
func Prime(num int) []int {</p>

<pre><code>if num &lt; 2 {
    return []int{}
}
return []int{2}
</code></pre>

<p>}
{% endcodeblock %}</p>

<h2>constant->scalar replacing a constant with a variable or an argument</h2>

<p>通过了前面2个测试之后，我们接着写第三个测试，要返回一个包含<code>3</code>的集合，需要将原来写死的常量<code>2</code>变成<code>num</code>。</p>

<p>{% codeblock prime_test.go lang:go %}
func Test_given_3_then_return_3(t *testing.T) {</p>

<pre><code>assert.Equal(t, []int{3}, Prime(3))
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>{% codeblock prime.go lang:go %}
func Prime(num int) []int {</p>

<pre><code>if num &lt; 2 {
    return []int{}
}
return []int{num}
</code></pre>

<p>}
{% endcodeblock %}</p>

<h2>(statement->statements) adding more unconditional statements</h2>

<p>继续增加测试，传入<code>4</code>返回包含<code>2</code>和<code>2</code>的集合，这次实现代码的改动比较大，基本算法已经出来了，使用<code>num</code>来对<code>2</code>求余数，然后同时添加除数和被除数，这个时候单元测试的效果就出来了，如果实现代码没有写对，以前的测试会失败，需要你不断修改，保证通过所有测试。</p>

<p>{% codeblock prime_test.go lang:go %}
func Test_given_4_then_return_2_2(t *testing.T) {</p>

<pre><code>assert.Equal(t, []int{2, 2}, Prime(4))
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>{% codeblock prime.go lang:go %}
func Prime(num int) []int {</p>

<pre><code>if num &lt; 2 {
    return []int{}
}

result := []int{}
mod := num % 2
if mod == 0 &amp;&amp; num &gt; 2 {
    result = append(result, 2)
    result = append(result, num/2)
} else {
    result = append(result, num)
}

return result
</code></pre>

<p>}
{% endcodeblock %}</p>

<h2>添加测试</h2>

<p>增加测试，传入<code>6</code>得到<code>2</code>和<code>3</code>的集合，实现代码没有改动。</p>

<p>{% codeblock prime_test.go lang:go %}
func Test_given_6_then_return_2_3(t *testing.T) {</p>

<pre><code>assert.Equal(t, []int{2, 3}, Prime(6))
</code></pre>

<p>}
{% endcodeblock %}</p>

<h2>(if->while)</h2>

<p>再增加一个参数<code>8</code>，返回<code>2-2-2</code>集合的测试，这个测试迫使我们的实现代码做循环，所以这是一个if到while的过程。</p>

<p>{% codeblock prime_test.go lang:go %}
func Test_given_8_then_return_2_2_2(t *testing.T) {</p>

<pre><code>assert.Equal(t, []int{2, 2, 2}, Prime(8))
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>{% codeblock prime.go lang:go %}
func Prime(num int) []int {</p>

<pre><code>if num &lt; 2 {
    return []int{}
}

result := []int{}
for div := 2; div &lt;= num; {
    if num%div == 0 {
        result = append(result, div)
        num /= div
    } else {
        div++
    }
}
return result
</code></pre>

<p>}
{% endcodeblock %}</p>

<h2>代码写完了吗？</h2>

<p>这个时候实际上我们的功能已经实现了，如果不放心我们就继续增加几个测试案例，结果验证都是通过的。</p>

<p>{% codeblock prime_test.go lang:go %}
func Test_given_9_then_return_3_3(t *testing.T) {</p>

<pre><code>assert.Equal(t, []int{3, 3}, Prime(9))
</code></pre>

<p>}</p>

<p>func Test_given_20_then_return_2_2_5(t *testing.T) {</p>

<pre><code>assert.Equal(t, []int{2, 2, 5}, Prime(20))
</code></pre>

<p>}</p>

<p>func Test_given_30_then_return_2_3_5(t *testing.T) {</p>

<pre><code>assert.Equal(t, []int{2, 3, 5}, Prime(30))
</code></pre>

<p>}</p>

<p>func Test_given_64_then_return_2_2_2_2_2_2(t *testing.T) {</p>

<pre><code>assert.Equal(t, []int{2, 2, 2, 2, 2, 2}, Prime(64))
</code></pre>

<p>}</p>

<p>func Test_given_10984_then_return_2_2_2_1373(t *testing.T) {</p>

<pre><code>assert.Equal(t, []int{2, 2, 2, 1373}, Prime(10984))
</code></pre>

<p>}
{% endcodeblock %}</p>

<h2>总结</h2>

<p>虽然看了Uncle Bob的TPP，但是觉得根据他的核心思想还是不容易控制TDD的节奏，实际上在做4-2-2的测试的时候我自己就想好了算法，如果没有想好算法要驱动出实际代码来比较难，可能还需要更多的练习才能达到TPP的效果吧。</p>
]]></content>
  </entry>
  
</feed>
