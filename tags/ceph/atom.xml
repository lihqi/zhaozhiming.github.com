<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: ceph | Hacker and Geeker's Way]]></title>
  <link href="http://zhaozhiming.github.io/tags/ceph/atom.xml" rel="self"/>
  <link href="http://zhaozhiming.github.io/"/>
  <updated>2015-12-20T21:02:37+08:00</updated>
  <id>http://zhaozhiming.github.io/</id>
  <author>
    <name><![CDATA[赵芝明]]></name>
    <email><![CDATA[kingzzm1982@sina.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[在Ubuntu12.04上安装Ceph Calamari]]></title>
    <link href="http://zhaozhiming.github.io/blog/2014/10/28/install-ceph-calamari-on-ubuntu/"/>
    <updated>2014-10-28T15:56:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2014/10/28/install-ceph-calamari-on-ubuntu</id>
    <content type="html"><![CDATA[<p>{% img /images/post/2014-10/calamari.png %}</p>

<p>Calamari是<a href="http://ceph.com/">Ceph</a>的一个监控和管理工具，它提供了一些定义好的REST API。Calamari包括服务端和客户端，服务端是使用Python的web框架<a href="https://www.djangoproject.com/">Django</a>开发的，提供了供客户端调用的REST API接口。客户端使用了<a href="http://nodejs.org/">NodeJS</a>,<a href="https://angularjs.org/">AngularJS</a>,<a href="http://getbootstrap.com/">Bootstrap3</a>，每个模块可以独立部署更新，其界面十分简洁清晰，几乎涵盖了所有监控要求。</p>

<p>下面介绍一下Calamari在Ubuntu上面的安装过程。</p>

<!--more-->


<h2>环境准备</h2>

<ul>
<li>安装VitrualBox和Vagrant，Vagrant的使用可以参照我之前的blog——<a href="http://zhaozhiming.github.io/blog/2014/10/02/ceph-install-with-vagrant-and-ansible">使用Vagrant和Ansible搭建Ceph环境</a>。</li>
<li>下载ubuntu12.04的box文件——<a href="https://vagrantcloud.com/discover/featured">box文件下载地址</a>，我们在虚拟机中安装calamari，不污染我们的本机环境。</li>
</ul>


<h2>生成Calamari安装文件</h2>

<h3>生成server安装文件</h3>

<ul>
<li>下载calamari工程</li>
</ul>


<p>{% codeblock lang:sh %}
$ mkdir calamari-node
$ cd calamari-node
$ git clone <a href="https://github.com/ceph/calamari.git">https://github.com/ceph/calamari.git</a>
$ git clone <a href="https://github.com/ceph/Diamond.git">https://github.com/ceph/Diamond.git</a>
{% endcodeblock %}</p>

<ul>
<li>使用vagrant生成server安装文件</li>
</ul>


<p>{% codeblock lang:sh %}
$ cd calamari/vagrant/precise-build</p>

<h1>首先要保证你的vagrant已经导入名字为precise的box</h1>

<p>$ vagrant up
&hellip;
&hellip;
Copying salt minion config to vm.
Checking if salt-minion is installed
salt-minion was not found.
Checking if salt-call is installed
salt-call was not found.
Bootstrapping Salt&hellip; (this may take a while)
Salt successfully configured and installed!
run_overstate set to false. Not running state.overstate.
run_highstate set to false. Not running state.highstate.</p>

<p>$ vagrant ssh
$ sudo salt-call state.highstate
&hellip;
&hellip;</p>

<h2>Summary</h2>

<p>Succeeded: 11</p>

<h2>Failed: 0</h2>

<p>Total: 11
{% endcodeblock %}</p>

<ul>
<li>这里的虚拟机将我们创建的根目录<code>calamari-node</code>和虚拟机中的<code>/git</code>目录关联起来了，我们可以通过在查看这2个目录中的任意一个来查看安装文件是否已经生成。</li>
</ul>


<p>{% codeblock lang:sh %}</p>

<h1>查看calamari-node目录</h1>

<p>$ cd calamari-node
$ ls -l
drwxr-xr-x  28 zhaozhiming  staff   952 Oct 20 16:16 Diamond
drwxr-xr-x  32 zhaozhiming  staff  1088 Oct 20 16:14 calamari
-rw-r&mdash;r&mdash;  1 zhaozhiming  staff  18883769 Oct 21 15:58 calamari-repo-precise.tar.gz
-rw-r&mdash;r&mdash;  1 zhaozhiming  staff  16417474 Oct 21 15:58 calamari-server_1.2.1-68-gfdeb0f7_amd64.deb
-rw-r&mdash;r&mdash;  1 zhaozhiming  staff    307478 Oct 21 15:58 diamond_3.4.67_all.deb</p>

<h1>查看虚拟机的/git目录</h1>

<p>$ cd calamari-node/calamari/vagrant/precise-build
$ vagrant ssh
$ cd /git
$ ls -l
drwxr-xr-x  28 zhaozhiming  staff   952 Oct 20 16:16 Diamond
drwxr-xr-x  32 zhaozhiming  staff  1088 Oct 20 16:14 calamari
-rw-r&mdash;r&mdash;  1 zhaozhiming  staff  18883769 Oct 21 15:58 calamari-repo-precise.tar.gz
-rw-r&mdash;r&mdash;  1 zhaozhiming  staff  16417474 Oct 21 15:58 calamari-server_1.2.1-68-gfdeb0f7_amd64.deb
-rw-r&mdash;r&mdash;  1 zhaozhiming  staff    307478 Oct 21 15:58 diamond_3.4.67_all.deb
{% endcodeblock %}</p>

<ul>
<li>从上面可以看到安装文件已经生成好了，2个deb文件分别是server和监控服务的安装文件，tar.gz文件是安装服务所需的依赖包安装文件集合，如果是连网安装的话，这个tar.gz文件不需要用到。</li>
</ul>


<h3>生成client安装文件</h3>

<ul>
<li>下载calamari-client工程</li>
</ul>


<p>{% codeblock lang:sh %}
$ cd calamari-node
$ git clone <a href="https://github.com/ceph/calamari-clients.git">https://github.com/ceph/calamari-clients.git</a>
{% endcodeblock %}</p>

<ul>
<li>使用vagrant生成client安装文件</li>
</ul>


<p>{% codeblock lang:sh %}
$ cd calamari-client/vagrant/precise-build/
$ vagrant up
&hellip;
&hellip;
Copying salt minion config to vm.
Checking if salt-minion is installed
salt-minion was not found.
Checking if salt-call is installed
salt-call was not found.
Bootstrapping Salt&hellip; (this may take a while)
Salt successfully configured and installed!
run_overstate set to false. Not running state.overstate.
run_highstate set to false. Not running state.highstate.</p>

<p>$ vagrant ssh
$ sudo salt-call state.highstate
&hellip;
&hellip;</p>

<h2>Summary</h2>

<p>Succeeded: 13</p>

<h2>Failed: 0</h2>

<p>Total: 13
{% endcodeblock %}</p>

<ul>
<li>查看生成的安装文件，可以看到有1个deb文件和一个tar.gz文件，ubuntu的话直接使用deb文件进行安装就可以了，tar.gz文件不需要。</li>
</ul>


<p>{% codeblock lang:sh %}
$ cd calamari-node
$ ls -l
drwxr-xr-x  28 zhaozhiming  staff   952 Oct 20 16:16 Diamond
drwxr-xr-x  32 zhaozhiming  staff  1088 Oct 20 16:14 calamari
drwxr-xr-x  22 zhaozhiming  staff      748 Oct 20 16:46 calamari-clients
-rw-r&mdash;r&mdash;  1 zhaozhiming  staff  18883769 Oct 21 15:58 calamari-repo-precise.tar.gz
-rw-r&mdash;r&mdash;  1 zhaozhiming  staff  16417474 Oct 21 15:58 calamari-server_1.2.1-68-gfdeb0f7_amd64.deb
-rw-r&mdash;r&mdash;  1 zhaozhiming  staff    307478 Oct 21 15:58 diamond_3.4.67_all.deb
-rw-r&mdash;r&mdash;   1 zhaozhiming  staff  1711253 Oct 21 12:38 calamari-clients-build-output.tar.gz
-rw-r&mdash;r&mdash;   1 zhaozhiming  staff  1705364 Oct 21 12:38 calamari-clients_1.2.1.1-29-g3790c24_all.deb
{% endcodeblock %}</p>

<h2>安装Calamari</h2>

<ul>
<li>创建一个ubuntu的虚拟机来安装calamari，首先在根目录下创建一个Vagrantfile文件。</li>
</ul>


<p>{% codeblock lang:sh %}
$ cd calamari-node
$ touch Vagrantfile
{% endcodeblock %}</p>

<ul>
<li>Vagrantfile文件内容如下，注意要使用绑定好的IP。</li>
</ul>


<p>{% codeblock lang:ruby %}</p>

<h1>&ndash;<em>&ndash; mode: ruby &ndash;</em>&ndash;</h1>

<h1>vi: set ft=ruby :</h1>

<h1>Vagrantfile API/syntax version. Don&rsquo;t touch unless you know what you&rsquo;re doing!</h1>

<p>VAGRANTFILE_API_VERSION = &ldquo;2&rdquo;</p>

<p>Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|
  config.vm.box = &ldquo;precise64&rdquo;</p>

<p>  config.vm.define &ldquo;manager&rdquo; do |manager|</p>

<pre><code>manager.vm.hostname = "manager-env"
manager.vm.network :private_network, ip: "192.168.26.10"
manager.vm.provider :virtualbox do |vb|
  vb.memory = 512
end
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<ul>
<li>启动虚拟机并登陆</li>
</ul>


<p>{% codeblock lang:sh %}
$ vagrant up
$ vagrant ssh
{% endcodeblock %}</p>

<ul>
<li>在虚拟机上安装salt</li>
</ul>


<p>{% codeblock lang:sh %}
$ sudo apt-get install python-software-properties
$ sudo add-apt-repository ppa:saltstack/salt
$ sudo apt-get update
$ sudo apt-get install salt-master
$ sudo apt-get install salt-minion
{% endcodeblock %}</p>

<ul>
<li>在虚拟机上安装所需依赖包</li>
</ul>


<p>{% codeblock lang:sh %}
$ sudo apt-get update &amp;&amp; sudo apt-get install -y apache2 libapache2-mod-wsgi libcairo2 supervisor python-cairo libpq5 postgresql
{% endcodeblock %}</p>

<ul>
<li>安装calamari</li>
</ul>


<p>{% codeblock lang:sh %}
$ cd /vagrant
$ sudo dpkg -i calamari-server<em>.deb calamari-clients</em>.deb
{% endcodeblock %}</p>

<ul>
<li>初始化calamari服务，这里会要求你输入用户名、邮箱、密码，这个用户名密码是在浏览器访问calamari服务需要的。</li>
</ul>


<p>{% codeblock lang:sh %}
$ sudo calamari-ctl initialize
[INFO] Loading configuration..
[INFO] Starting/enabling salt&hellip;
[INFO] Starting/enabling postgres&hellip;
[INFO] Initializing database&hellip;
[INFO] Initializing web interface&hellip;
[INFO] You will now be prompted for login details for the administrative user account. This is the account you will use to log into the web interface once setup is complete.
Username (leave blank to use &lsquo;root&rsquo;):
Email address: <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#x3a;&#107;&#x61;&#114;&#x61;&#x6e;&#46;&#x73;&#105;&#x6e;&#x67;&#104;&#64;&#99;&#115;&#x63;&#46;&#x66;&#105;">&#107;&#97;&#x72;&#97;&#x6e;&#46;&#115;&#x69;&#110;&#x67;&#104;&#x40;&#x63;&#115;&#99;&#x2e;&#x66;&#x69;</a>
Password:
Password (again):
Superuser created successfully.
[INFO] Starting/enabling services&hellip;
[INFO] Restarting services&hellip; &ndash; See more at: <a href="http://ceph.com/category/calamari/#sthash.qUtbU0mX.dpuf">http://ceph.com/category/calamari/#sthash.qUtbU0mX.dpuf</a>
{% endcodeblock %}</p>

<ul>
<li>登陆浏览器，输入虚拟机的ip(比如<a href="http://192.168.26.10">http://192.168.26.10</a>)，可以看到如下页面。</li>
</ul>


<p>{% img /images/post/2014-10/calamari-login.png %}</p>

<ul>
<li>输入刚才设置的用户名密码后，可以看到calamari提示你进行ceph集群配置。</li>
</ul>


<p>{% img /images/post/2014-10/calamari-first.png %}</p>

<h2>Ceph集群配置监控服务</h2>

<h3>配置ceph集群</h3>

<ul>
<li>登陆其中一台ceph集群机器(这里假设ceph集群都是ubuntu环境)，安装监控服务。</li>
</ul>


<p>{% codeblock lang:sh %}
$ sudo dpkg -i diamond_3.4.67_all.deb #deb文件是之前生成server安装文件时一起生成的，需要将其先考到ceph集群机器上
{% endcodeblock %}</p>

<ul>
<li>创建默认的监控配置文件</li>
</ul>


<p>{% codeblock lang:sh %}
$ sudo mv /etc/diamond/diamond.conf.example /etc/diamond/diamond.conf
{% endcodeblock %}</p>

<ul>
<li>安装salt-minion服务</li>
</ul>


<p>{% codeblock lang:sh %}
$ sudo apt-get install python-software-properties
$ sudo add-apt-repository ppa:saltstack/salt
$ sudo apt-get update
$ sudo apt-get install salt-minion
{% endcodeblock %}</p>

<ul>
<li>在<code>/etc/hosts</code>文件中增加calamari服务器的映射关系</li>
</ul>


<p>{% codeblock /etc/hosts lang:sh %}
&hellip;
&hellip;
192.168.26.10 ceph-calamari
{% endcodeblock %}</p>

<ul>
<li>修改salt-minion的配置文件<code>/etc/salt/minion</code>，将master指向calamari服务器</li>
</ul>


<p>{% codeblock /etc/salt/minion lang:sh %}
&hellip;
master: ceph-calamari
&hellip;
{% endcodeblock %}</p>

<ul>
<li>重启服务</li>
</ul>


<p>{% codeblock lang:sh %}
$ sudo service salt-minion restart<br/>
$ sudo service diamond restart
{% endcodeblock %}</p>

<ul>
<li>在所有的ceph集群机器上重复以上的步骤。</li>
</ul>


<h3>在calamari服务上添加ceph集群机器</h3>

<ul>
<li>查看salt-key</li>
</ul>


<p>{% codeblock lang:sh %}
$ sudo salt-key -L
Accepted Keys:
Unaccepted Keys:
ceph-mon0
ceph-mon1
ceph-mon2
ceph-osd0
ceph-osd1
ceph-osd2
Rejected Keys:
{% endcodeblock %}</p>

<ul>
<li>添加ceph集群机器到calamari</li>
</ul>


<p>{% codeblock lang:sh %}
$ sudo salt-key -A
The following keys are going to be accepted:
Unaccepted Keys:
ceph-mon0
ceph-mon1
ceph-mon2
ceph-osd0
ceph-osd1
ceph-osd2
Proceed? [n/Y] y
Key for minion ceph-mon0 accepted.
Key for minion ceph-mon1 accepted.
Key for minion ceph-mon2 accepted.
Key for minion ceph-osd0 accepted.
Key for minion ceph-osd1 accepted.
Key for minion ceph-osd2 accepted.
{% endcodeblock %}</p>

<ul>
<li>再次查看salt-key，可以看到所有节点都已添加。</li>
</ul>


<p>{% codeblock lang:sh %}
$ sudo salt-key -L
Accepted Keys:
ceph-mon0
ceph-mon1
ceph-mon2
ceph-osd0
ceph-osd1
ceph-osd2
Unaccepted Keys:
Rejected Keys:
{% endcodeblock %}</p>

<ul>
<li>在浏览器中再次登陆calamari服务，可以看到已经能监控ceph集群的信息。</li>
</ul>


<p>{% img /images/post/2014-10/calamari.png %}</p>

<p>{% img /images/post/2014-10/calamari-page1.png %}</p>

<p>{% img /images/post/2014-10/calamari-page2.png %}</p>

<p>{% img /images/post/2014-10/calamari-page3.png %}</p>

<h2>参考资料</h2>

<ul>
<li>文档1：<a href="http://calamari.readthedocs.org/en/latest/operations/index.html">http://calamari.readthedocs.org/en/latest/operations/index.html</a></li>
<li>文档2：<a href="http://calamari.readthedocs.org/en/latest/operations/index.html">http://ceph.com/category/calamari/</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Vagrant和Ansible搭建Ceph环境]]></title>
    <link href="http://zhaozhiming.github.io/blog/2014/10/02/ceph-install-with-vagrant-and-ansible/"/>
    <updated>2014-10-02T22:03:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2014/10/02/ceph-install-with-vagrant-and-ansible</id>
    <content type="html"><![CDATA[<p>{% img /images/post/2014-9/ceph-install.jpg %}</p>

<h2><a href="http://ceph.com/">Ceph</a>简介</h2>

<p>Ceph是一个高性能，高可用，高扩展的分布式对象存储框架和文件系统，而且是一个免费开源的项目。</p>

<p>但是Ceph的环境搭建起来比较麻烦，最简单的环境也需要2台VM(虚拟机，1台做mon和osd，另外一台做gateway)，而且按照官方文档上面的指南进行安装，经常报各种莫名其妙的问题，现在给大家介绍一个简单的方法来进行Ceph环境的搭建。下面先介绍几个要用到的工具。</p>

<!--more-->


<h2><a href="https://www.vagrantup.com/">Vagrant</a></h2>

<p>{% img /images/post/2014-9/vagrant.png %}</p>

<p>以前使用VM情况是这样的:</p>

<ul>
<li>下载操作系统的iso镜像</li>
<li>通过VM管理工具(VMWare，VirtualBox等)将iso镜像转换为VM</li>
<li>登陆到VM进行操作</li>
</ul>


<p>整个过程复杂而且漫长，但是使用了Vagrant之后就非常方便了，一个命令就可以搞定VM的安装，ssh到VM也无需输入用户名密码，还可以查看所有VM的状态等。</p>

<h3>Box</h3>

<p>vagrant通过box来生成VM，box可以理解是一个制作好的VM，这意味着你搭建完自己的开发环境后，也可以将其制作成一个box，供团队其他成员使用。</p>

<p>box的容量非常小，比如Ubuntu12.04的一个iso镜像一般要500多M，制作成VM可能要10G左右，而一个ubuntu12.04的box只有300多M。Vagrant的box可以在<a href="https://vagrantcloud.com/discover/featured">这里</a>下载，除了有各种OS(ubuntu, windosw, CentOS等)的VM外，还有Virtualbox和VMWare各自对应的box，不过要使用VMWare的box，需要安装插件和到购买相关的<a href="https://www.vagrantup.com/VMware">License</a>，毕竟VMWare不是免费的软件。</p>

<p>下载了box后，执行下面命令就可以添加box了，如果直接输入box名称并发现本地没有box的话，会自动下载box文件。(<code>PS: Vagrant默认使用Virtualbox作为虚拟器软件，所以在安装Vagrant还需要先安装Virtualbox。</code>)</p>

<p>{% codeblock lang:sh %}
//添加本地box文件
$ vagrant box add /your/box/path/xxx.box
//添加指定名称的box，没有的话会自动下载box文件
$ vagrant box add hashicorp/precise32
//列出所有的box
$ vagrant box list
{% endcodeblock %}</p>

<h3>Vagrant基本操作</h3>

<p>Vagrant的操作非常简单，现在介绍几个常用的操作指令。(<code>PS: 下面的大部分命令后面可以跟VM名称，不跟的话是对所有的VM进行操作。</code>)</p>

<ul>
<li>vagrant status: 展示VM的信息。</li>
<li>vagrant up: 启动VM。</li>
<li>vagrant ssh [VM]: ssh到某个VM上，无需输入用户名和密码。</li>
<li>vagrant halt: 关闭VM。</li>
<li>vagrant destroy: 销毁VM，如果你的VM被你玩残了，销毁它然后重新启动一个就可以了，很方便。</li>
</ul>


<h3>Vagrant共享</h3>

<p>使用<code>vagrant ssh</code>到VM后，可以看到根目录下有个<code>/vagrant</code>文件夹，这个是VM和工程间的共享目录，在这个文件夹里面存放东西，可以在存放Vagrantfile的目录里面看到，反之亦然，在VM里面也可以读取到工程下的文件。</p>

<h3>Vagrantfile</h3>

<p>初始化vagrant工程后可以看到一个<code>Vagrantfile</code>的文件，这个是配置VM的文件，可以看下面的例子:</p>

<p>{% codeblock lang:ruby %}
VAGRANTFILE_API_VERSION = &ldquo;2&rdquo;</p>

<p>Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|
  config.VM.box = &ldquo;hashicorp/precise64&rdquo;</p>

<p>  config.VM.define :rgw do |rgw|</p>

<pre><code>rgw.VM.network :private_network, ip: "192.168.42.2"
rgw.VM.host_name = "ceph-rgw"
rgw.VM.provider :virtualbox do |vb|
  vb.customize ["modifyVM", :id, "--memory", "192"]
end
rgw.VM.provider :VMware_fusion do |v|
  v.VMx['memsize'] = '192'
end
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>这个Vagrantfile指定了box的名称，然后创建了一个名称为<code>rgw</code>的VM，指定了VM的ip、hostname、内存大小。</p>

<p>关于vagrant就介绍到这里，想要了解更多信息可以查看<a href="https://www.vagrantup.com/">vagrant官网</a>。</p>

<h2><a href="http://www.ansible.com/home">Ansible</a></h2>

<p>{% img /images/post/2014-9/ansible.jpg %}</p>

<p>Ansible是一个开源的远程机器管理软件，可以批量操作多台远程服务器。(<code>PS: Ansible只适合操作Linux和Unix机器，如果是Windows系统是不可以的。</code>)</p>

<h3>安装</h3>

<p>要安装Ansible需要先安装Python2.6/7，然后可以通过easy_install或pip进行下载安装。</p>

<p>{% codeblock lang:sh %}
sudo esay_install ansible</p>

<h1>or</h1>

<p>sudo pip install ansible
{% endcodeblock %}</p>

<h3>使用示例</h3>

<p>创建一个文件夹，在文件夹里面创建一个hosts文件，hosts格式如下:</p>

<p>{% codeblock lang:sh %}</p>

<h1>hosts</h1>

<p><a href="http://ceph.com/">ceph</a>
192.168.42.2
192.168.42.101
192.168.42.201
{% endcodeblock %}</p>

<p>可以看到hosts文件里面有几个远程机器的ip(这里是虚拟机)，远程机器可以分组，通过中括号里面的组名来划分。</p>

<p>然后执行下面的命令执行简单的命令。</p>

<p>{% codeblock lang:sh %}
$ ansible all -a &lsquo;who&rsquo;
ceph-mon0 | success | rc=0 >>
ceph     pts/0        2014-10-02 08:54 (192.168.42.60)</p>

<p>ceph-osd0 | success | rc=0 >>
ceph     pts/0        2014-10-02 08:54 (192.168.42.60)</p>

<p>ceph-osd1 | success | rc=0 >>
ceph     pts/0        2014-10-02 08:54 (192.168.42.60)
{% endcodeblock %}</p>

<p>从输出信息上可以看到这几台远程机器都成功执行了<code>who</code>命令，不过如果要成功执行上面的命令，还需要先在执行机和远程机上面设置无密码ssh连接。</p>

<h3>无密码ssh连接</h3>

<p>假设有2台机器，机器A和机器B，现在想让机器A<code>ssh</code>机器B的时候不需要输入用户和密码，操作如下。</p>

<ul>
<li>在机器B上创建一个用户，并配置好，下面命令的<code>username</code>指自己要创建的用户名。</li>
</ul>


<p>{% codeblock lang:sh %}
$ sudo useradd -d /home/{username} -m {username}
$ sudo passwd {username}</p>

<h1>输入密码</h1>

<p>$ echo &ldquo;{username} ALL = (root) NOPASSWD:ALL&rdquo; | sudo tee /etc/sudoers.d/{username}
$ sudo chmod 0440 /etc/sudoers.d/{username}
{% endcodeblock %}</p>

<ul>
<li>在机器A上生成密钥，并发送给机器B。</li>
</ul>


<p>{% codeblock lang:sh %}
$ ssh-keygen</p>

<p>Generating public/private key pair.
Enter file in which to save the key (/ceph-admin/.ssh/id_rsa):
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /ceph-admin/.ssh/id_rsa.
Your public key has been saved in /ceph-admin/.ssh/id_rsa.pub.</p>

<p>$ ssh-copy-id {username}@{机器B}
{% endcodeblock %}</p>

<ul>
<li>到这里就可以不用输入密码进行ssh了，如果想连用户名也不想输入的话，需要机器A在<code>.ssh</code>文件下创建一个<code>config</code>文件，在里面添加如下内容。</li>
</ul>


<p>{% codeblock lang:sh %}
Host 机器B
   Hostname 机器B
   User {username}
{% endcodeblock %}</p>

<h3>playbook</h3>

<p>ansible还可以通过一个playbook脚本进行远程机器的操作，playbook的示例如下:</p>

<p>{% codeblock playbook.yml lang:yaml %}</p>

<h1>playbook.yml</h1>

<hr />

<ul>
<li>hosts: all
remote_user: ceph
tasks:

<ul>
<li>name: whoami
shell: &lsquo;whoami > whoami.rst&rsquo;
{% endcodeblock %}</li>
</ul>
</li>
</ul>


<p>创建完playbook文件后执行如下命令可以看到执行结果。</p>

<p>{% codeblock lang:sh %}
$ ansible-playbook playbook.yml</p>

<p>PLAY [all] ********************************************************************</p>

<p>GATHERING FACTS ***************************************************************
ok: [ceph-mon0]
ok: [ceph-osd1]
ok: [ceph-osd0]</p>

<p>TASK: [whoami] ****************************************************************
changed: [ceph-mon0]
changed: [ceph-osd0]
changed: [ceph-osd1]</p>

<p>PLAY RECAP ********************************************************************
ceph-mon0                  : ok=2    changed=1    unreachable=0    failed=0 <br/>
ceph-osd0                  : ok=2    changed=1    unreachable=0    failed=0 <br/>
ceph-osd1                  : ok=2    changed=1    unreachable=0    failed=0 <br/>
{% endcodeblock %}</p>

<p>这时可以在远程机器的用户目录上可以看到新产生了一个<code>whoami.rst</code>的文件。</p>

<p>关于ansible就介绍到这里，想要了解更多信息可以查看<a href="http://docs.ansible.com/">ansible的文档</a>。</p>

<h2><a href="https://github.com/ceph/ceph-ansible">Ceph-ansible</a></h2>

<p>这个github项目主要是利用了上面介绍的2个工具，使用vagrant来创建ceph需要的服务器VM，然后将ceph的环境搭建通过ansible的playbook脚本执行。</p>

<h3>执行步骤</h3>

<ul>
<li>下载ceph-ansible项目;</li>
</ul>


<p>{% codeblock lang:sh %}
$ git clone <a href="https://github.com/ceph/ceph-ansible.git">https://github.com/ceph/ceph-ansible.git</a>
{% endcodeblock %}</p>

<ul>
<li>一行命令就可以完成环境搭建，完成后ceph的环境是: 3个mon，3个osd，1个rgw;</li>
</ul>


<p>{% codeblock lang:sh %}
$ vagrant up
&hellip;
&hellip;
&hellip;
mon0                       : ok=16   changed=11   unreachable=0    failed=0
mon1                       : ok=16   changed=10   unreachable=0    failed=0
mon2                       : ok=16   changed=11   unreachable=0    failed=0
osd0                       : ok=19   changed=7    unreachable=0    failed=0
osd1                       : ok=19   changed=7    unreachable=0    failed=0
osd2                       : ok=19   changed=7    unreachable=0    failed=0
rgw                        : ok=20   changed=17   unreachable=0    failed=0
{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ceph认证原理]]></title>
    <link href="http://zhaozhiming.github.io/blog/2014/09/13/ceph-authentication-theory/"/>
    <updated>2014-09-13T09:11:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2014/09/13/ceph-authentication-theory</id>
    <content type="html"><![CDATA[<p>{% img /images/post/2014-9/rados-arch.png %}</p>

<p>为识别用户和防范攻击，ceph提供了cephx来进行用户和后台进程认证。</p>

<!--more-->


<h2>原理介绍</h2>

<p>Cephx使用共享密钥的方式进行认证，意思是客户端和monitor集群都有一份客户端的密钥。它提供了一个相互认证的机制，集群确定用户拥有密钥，而用户确定集群拥有密钥的备份。</p>

<p>Ceph不提供统一的认证接口给对象存储，所以客户端必须直接跟OSD交互。为了保护数据，ceph提供了cephx认证系统，用来对用户在客户端的操作进行认证。Cephx认证协议与<a href="http://en.wikipedia.org/wiki/Kerberos_(protocol)">Kerberos</a>相类似。</p>

<p>用户调用客户端连接monitor。跟Kerberos不同，每个monitor都可以进行认证，所以没有单点和性能瓶颈的问题。Monitor返回一个类似Kerberos的数据结构，包含了一个session key来访问ceph服务。Session key是通过加密用户自己的密钥来生成的，所以只有该用户能请求monitor服务。然后客户端使用session key向monitor发起请求，monitor于是提供给客户端一个ticket来使客户端和OSD进行认证。Monitor和OSD共享密钥，所以客户端可以使用Monitor提供的ticket来和OSD进行交互。跟Kerberos一样，cephx的ticket会过期，所以攻击者不能使用过期的ticket或session key来做不正当的事情。这种认证形式将阻止攻击者通过修改用户已泄露信息的方式，或者伪造消息进行通讯访问的方式来进行攻击，只要用户的密钥不要在失效前泄露就没有什么问题。</p>

<p>使用cephx时，管理员需要先创建user。在下面的图表中，client.admin用户调用<code>ceph auth get-or-create-key</code>的命令来生成用户名和密钥，ceph的auth子系统来生成用户名和密钥，保存一份密钥在monitor并将用户的密钥传回给client.admin用户。这使得客户端和monitor共享了一份密钥。</p>

<p>{% img /images/post/2014-9/rados-auth-1.png %}</p>

<p>为了能通过monitor的认证，客户端将用户名传给monitor，然后monitor产生一个session key并且通过密钥将其加密，并使之与用户名关联。然后monitor将加密session key回传给客户端，客户端再通过共享密钥进行解密，从而获取到seesion key。session key标示当前用户的当前回话。然后客户端再发起请求要求一个代表用户会话密钥的ticket，monitor产生ticket并通过用户密钥进行加密，并将其回传给客户端。客户端对ticket进行解密，以后客户端向OSD或MDS发起请求时，就用它来对请求进行签名。</p>

<p>{% img /images/post/2014-9/rados-auth-2.png %}</p>

<p>cephx协议验证客户端和Ceph服务器之间的通信。在初始化认证之后，在客户端和服务器间的每一条信息，都会使用ticket进行签名，这样monitor，OSD和MDS服务就可以使用他们的共享密钥进行验证。</p>

<p>{% img /images/post/2014-9/rados-auth-3.png %}</p>

<p>认证提供的保护是在ceph客户端和服务器之间。认证不能超过客户端，比如用户从一台远程服务器上访问cpeh客户端，ceph的认证就不能适用于远程主机和客户端了。</p>

<h2>生成存储集群的keyring</h2>

<ul>
<li>生成client.admin的key</li>
</ul>


<p>{% codeblock lang:sh %}
ceph auth get-or-create client.admin mon &lsquo;allow <em>&rsquo; mds &lsquo;allow </em>&rsquo; osd &lsquo;allow *&rsquo; -o /etc/ceph/ceph.client.admin.keyring
{% endcodeblock %}</p>

<p><code>注意：这个操作会覆盖原有的ceph.client.admin.keyring文件，请谨慎操作。</code></p>

<ul>
<li>创建monitor的keyring</li>
</ul>


<p>{% codeblock lang:sh %}
ceph-authtool &mdash;create-keyring /tmp/ceph.mon.keyring &mdash;gen-key -n mon. &mdash;cap mon &lsquo;allow *&rsquo;
{% endcodeblock %}</p>

<ul>
<li>复制monitor的keyring文件到每个monitor的data目录</li>
</ul>


<p>{% codeblock lang:sh %}
cp /tmp/ceph.mon.keyring /var/lib/ceph/mon/ceph-a/keyring
{% endcodeblock %}</p>

<ul>
<li>为每个OSD产生keyring，id是OSD的编号</li>
</ul>


<p>{% codeblock lang:sh %}
ceph auth get-or-create osd.{$id} mon &lsquo;allow rwx&rsquo; osd &lsquo;allow *&rsquo; -o /var/lib/ceph/osd/ceph-{$id}/keyring
{% endcodeblock %}</p>

<ul>
<li>为每个MDS产生keyring，id是MDS编号</li>
</ul>


<p>{% codeblock lang:sh %}
ceph auth get-or-create mds.{$id} mon &lsquo;allow rwx&rsquo; osd &lsquo;allow <em>&rsquo; mds &lsquo;allow </em>&rsquo; -o /var/lib/ceph/mds/ceph-{$id}/keyring
{% endcodeblock %}</p>

<ul>
<li>在ceph.conf的global中增加认证开关</li>
</ul>


<p>{% codeblock lang:properties %}
auth cluster required = cephx
auth service required = cephx
auth client required = cephx
{% endcodeblock %}</p>

<ul>
<li>重启存储服务</li>
</ul>


<h2>认证配置</h2>

<ul>
<li>auth cluster required：[cephx | none]:如果打开，表示存储集群（mon,osd,mds）相互之间需要通过keyring认证。</li>
<li>auth service required：[cephx | none]:如果打开，表示客户端（比如gateway）到存储集群（mon,osd,mds）需要通过keyring认证。</li>
<li>auth client required：[cephx | none]:如果打开，表示存储集群（mon,osd,mds）到客户端（比如gateway）需要通过keyring认证。</li>
</ul>


<h2>Rados gateway创建keyring</h2>

<p>需要使用一台管理节点的机器来生成keyring文件，管理节点是使用ceph-deploy才有的机器，我理解没有管理节点的话，使用mon或osd的机器可以创建keyring。</p>

<ul>
<li>创建文件并增加权限</li>
</ul>


<p>{% codeblock lang:sh %}
sudo ceph-authtool &mdash;create-keyring /etc/ceph/ceph.client.radosgw.keyring
sudo chmod +r /etc/ceph/ceph.client.radosgw.keyring
{% endcodeblock %}</p>

<ul>
<li>使用ceph-authtool在keyring文件中生成随机密码</li>
</ul>


<p>{% codeblock lang:sh %}
sudo ceph-authtool /etc/ceph/ceph.client.radosgw.keyring -n client.radosgw.gateway &mdash;gen-key
{% endcodeblock %}</p>

<ul>
<li>在keyring中增加存储集群的操作权限；</li>
</ul>


<p>{% codeblock lang:sh %}
sudo ceph-authtool -n client.radosgw.gateway &mdash;cap osd &lsquo;allow rwx&rsquo; &mdash;cap mon &lsquo;allow rwx&rsquo; /etc/ceph/ceph.client.radosgw.keyring
{% endcodeblock %}</p>

<ul>
<li>将gateway的key添加到存储集群（-k不知道是什么参数）</li>
</ul>


<p>{% codeblock lang:sh %}
sudo ceph -k /etc/ceph/ceph.client.admin.keyring auth add client.radosgw.gateway -i /etc/ceph/ceph.client.radosgw.keyring
{% endcodeblock %}</p>

<ul>
<li>将生成的keyring文件上传到gateway的机器</li>
</ul>


<p>{% codeblock lang:sh %}
sudo scp /etc/ceph/ceph.client.radosgw.keyring  ceph@{hostname}:/home/ceph
ssh {hostname}
sudo mv ceph.client.radosgw.keyring /etc/ceph/ceph.client.radosgw.keyring
{% endcodeblock %}</p>

<ul>
<li>在ceph.conf中配置gateway的keyring文件路径</li>
</ul>


<p>{% codeblock lang:properties %}
[client.radosgw.{instance-name}]
host = {host-name}
keyring = /etc/ceph/ceph.client.radosgw.keyring
rgw socket path = /var/run/ceph/ceph.radosgw.{instance-name}.fastcgi.sock
log file = /var/log/ceph/client.radosgw.{instance-name}.log
{% endcodeblock %}</p>
]]></content>
  </entry>
  
</feed>
