<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: design pattern | Hacker and Geeker's Way]]></title>
  <link href="http://zhaozhiming.github.io/tags/design-pattern/atom.xml" rel="self"/>
  <link href="http://zhaozhiming.github.io/"/>
  <updated>2016-12-13T11:25:35+08:00</updated>
  <id>http://zhaozhiming.github.io/</id>
  <author>
    <name><![CDATA[赵芝明]]></name>
    <email><![CDATA[kingzzm1982@sina.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[单例模式的5种形式]]></title>
    <link href="http://zhaozhiming.github.io/blog/2012/12/20/5-type-of-singleton-pattern/"/>
    <updated>2012-12-20T17:53:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2012/12/20/5-type-of-singleton-pattern</id>
    <content type="html"><![CDATA[<p>有过编程经验的朋友都知道设计模式中的单例模式，最近又重新看了一遍设计模式，今天将单例模式的几种形式介绍一下：</p>

<!--more-->


<p></p>

<h3>1、懒汉形式（延迟加载）</h3>

<p>{% codeblock Singleton.java lang:java %}
public class Singleton{</p>

<pre><code>private static Singleton singleton;

private Singleton() {
}

public synchronized static Single newInstance() {
    if (singleton== null) {
        singleton= new Singleton();
    }
    return singleton;
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>这个是标准的单例模式，通过newInstance里面的判断来进行延迟加载单例对象，这里加了synchronized关键字可以避免多线程问题，但会影响程序性能。</p>

<h3>2、饿汉形式（贪婪加载）</h3>

<p>{% codeblock Singleton.java lang:java %}
public class Singleton {</p>

<pre><code>private static Singleton singleton= new Singleton();

private singleton() {
}

public static Singleton newInstance() {
    return singleton;
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>在单例对象声明的时候就直接初始化对象，可以避免多线程问题，但是如果对象初始化比较复杂，会导致程序初始化缓慢。</p>

<h3>3、双重检查加锁</h3>

<p>{% codeblock Singleton.java lang:java %}
public class Singleton {</p>

<pre><code>private volatile static Singleton singleton;

private Singleton() {
}

public static Singleton newInstance() {
    if (singleton == null) {
        synchronized (Singleton.class) {
            if (singleton == null) {
                singleton = new Singleton();
            }
        }
    }
    return singleton;
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>这个是懒汉形式的加强版，将synchronized关键字移到了newInstance方法里面，同时将singleton对象加上volatile关键字，这种方式既可以避免多线程问题，又不会降低程序的性能。但volatile关键字也有一些性能问题，不建议大量使用。</p>

<h3>4、Lazy initialization holder class</h3>

<p>{% codeblock Singleton.java lang:java %}
public class Singleton {</p>

<pre><code>private static class SingletonHolder {
    private static Singleton singleton = new Singleton();
}

private Singleton() {
}

public static Singleton newInstance() {
    return SingletonHolder.singleton;
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>这里创建了一个内部静态类，通过内部类的机制使得单例对象可以延迟加载，同时内部类相当于是外部类的静态部分，所以可以通过jvm来保证其线程安全。这种形式比较推荐。</p>

<h3>5、枚举</h3>

<p>{% codeblock Singleton.java lang:java %}
public enum Singleton {</p>

<pre><code>singleton
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>单因素的枚举类已经实现了单例，这种方法更加简单。</p>
]]></content>
  </entry>
  
</feed>
