<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: wechat | Hacker and Geeker's Way]]></title>
  <link href="http://zhaozhiming.github.io/tags/wechat/atom.xml" rel="self"/>
  <link href="http://zhaozhiming.github.io/"/>
  <updated>2015-12-20T21:02:37+08:00</updated>
  <id>http://zhaozhiming.github.io/</id>
  <author>
    <name><![CDATA[赵芝明]]></name>
    <email><![CDATA[kingzzm1982@sina.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[微信公众账号开发part2——用户消息接收]]></title>
    <link href="http://zhaozhiming.github.io/blog/2015/02/04/wechat-public-account-dev-part-2/"/>
    <updated>2015-02-04T16:03:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2015/02/04/wechat-public-account-dev-part-2</id>
    <content type="html"><![CDATA[<p>{% img /images/post/2015-2/wechat_part2.jpg %}</p>

<p>上一篇写了如何通过微信开发者认证，今天来讲下如何接收用户的消息，我们以接收用户的订阅消息为例。</p>

<!--more-->


<p></p>

<h2>微信用户消息格式</h2>

<p>在开发者文档的<a href="http://mp.weixin.qq.com/wiki/2/5baf56ce4947d35003b86a9805634b1e.html">接收事件推送</a>文档中，说明了用户订阅消息的请求实体，内容如下:</p>

<p>{% codeblock lang:xml %}
<xml></p>

<pre><code>&lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;
&lt;FromUserName&gt;&lt;![CDATA[FromUser]]&gt;&lt;/FromUserName&gt;
&lt;CreateTime&gt;123456789&lt;/CreateTime&gt;
&lt;MsgType&gt;&lt;![CDATA[event]]&gt;&lt;/MsgType&gt;
&lt;Event&gt;&lt;![CDATA[subscribe]]&gt;&lt;/Event&gt;
</code></pre>

<p></xml>
{% endcodeblock %}</p>

<ul>
<li>ToUserName: 开发者微信号</li>
<li>FromUserName: 用户微信账号的OpenID</li>
<li>CreateTime: 消息发送时间，秒数</li>
<li>MsgType: 消息类型，事件消息为event</li>
<li>Event: 事件类型，订阅消息为subscribe</li>
</ul>


<h2>消息真实性验证</h2>

<p>{% blockquote 微信公众平台开发者文档 <a href="http://mp.weixin.qq.com/wiki/4/2ccadaef44fe1e4b0322355c2312bfa8.html">http://mp.weixin.qq.com/wiki/4/2ccadaef44fe1e4b0322355c2312bfa8.html</a> 验证消息真实性 %}
每次开发者接收用户消息的时候，微信也都会带上前面三个参数（signature、timestamp、nonce）访问开发者设置的URL，开发者依然通过对签名的效验判断此条消息的真实性。效验方式与首次提交验证申请一致。
{% endblockquote %}</p>

<p>所以每个订阅消息的http请求都会带有（signature、timestamp、nonce）这3个参数和上面的xml请求实体，服务端可以选择是否校验消息的真实性，建议校验，这样会比较安全。</p>

<h2>接收消息后的响应内容</h2>

<p>了解了消息请求的入参后，还需要知道我们处理请求后，需要返回什么样的内容给用户，这个在开发者文档里面好像没有提及，参考各方资料后知道需要返回一段xml内容，格式如下:</p>

<p>{% codeblock lang:xml %}
<xml></p>

<pre><code>&lt;Content&gt;感谢您关注我的公众账号[愉快]&lt;/Content&gt;
&lt;CreateTime&gt;1423022113&lt;/CreateTime&gt;
&lt;FromUserName&gt;zzm&lt;/FromUserName&gt;
&lt;FuncFlag&gt;0&lt;/FuncFlag&gt;
&lt;MsgType&gt;text&lt;/MsgType&gt;
&lt;ToUserName&gt;zzm&lt;/ToUserName&gt;
</code></pre>

<p></xml>
{% endcodeblock %}</p>

<ul>
<li>ToUserName: <code>用户微信账号的OpenID</code></li>
<li>FromUserName: <code>开发者微信号</code></li>
<li>CreateTime: 消息发送时间，秒数</li>
<li>FuncFlag: 这个暂时不知道是什么，默认值为0</li>
<li>MsgType: 消息类型，文档消息可以为text和其他，这里我们以最简单的text文本消息为例</li>
<li>Content: 返回给订阅用户的消息内容，可以加表情</li>
</ul>


<p>PS: ToUserName和FromUserName这2个参数和请求的xml实体要相反，这个也比较好理解，用户发了条消息过来，你要发个消息回去，ToUserName就变成了用户，FromUserName变成了你自己的公众账号了。</p>

<h2>服务端开发</h2>

<ul>
<li>了解了http请求的入参和出参，我们可以来开发我们的API了，<code>talk is cheap, show me code</code>。</li>
</ul>


<p>{% codeblock MainController.java lang:java %}</p>

<pre><code>//这里我们定义跟之前认证api相同的url，但方法是POST
@RequestMapping(value = "/index", method = RequestMethod.POST)
public
@ResponseBody
//3个校验消息真实性的参数，还有一个request实体body，里面是xml文本
ResponseEntity&lt;String&gt; receive(@RequestParam("signature") String signature,
                               @RequestParam("timestamp") String timestamp,
                               @RequestParam("nonce") String nonce,
                               @RequestBody String body) throws Exception {
    log.info("receive message start");
    log.info(String.format("signature:%s, timestamp:%s, nonce:%s", signature, timestamp, nonce));

    //先校验消息的真实性，如果校验失败，则返回400
    if (!wechatAuth(signature, timestamp, nonce)) {
        log.info("wechat auth failed");
        return new ResponseEntity&lt;String&gt;("wechat auth failed.", HttpStatus.BAD_REQUEST);
    }

    log.info(String.format("body:%s", body));
    //我们定义了一个util来解析xml，将其转换为一个object
    TextMessage requestMessage = XmlUtil.toTextMessage(body);
    log.info(String.format("requestMessage:%s", requestMessage));

    TextMessage textMessage = null;
    String msgType = requestMessage.getMsgType();
    String toUserName = requestMessage.getToUserName();
    String fromUserName = requestMessage.getFromUserName();
    //判断消息类型，如果是event，且事件类型为subscribe，则新建一个文本消息
    if (MessageType.event.name().equals(msgType)) {
        if (EventType.subscribe.name().equals(requestMessage.getEvent())) {
            String message = "感谢您关注我的公众账号[愉快]";
            textMessage = new TextMessage(toUserName, fromUserName,
                    MessageType.text.name(), message, TimeUtil.currentSeconds());
        }
    }

    //将文本消息转换为xml文本
    String responseMessage = XmlUtil.toXml(textMessage);
    HttpHeaders responseHeaders = new HttpHeaders();
    //设置返回实体的编码，不设置的话可能会变成乱码
    responseHeaders.add("Content-Type", "text/html; charset=utf-8");
    log.info(String.format("response message: %s", responseMessage));
    log.info("receive message finish");
    return new ResponseEntity&lt;String&gt;(responseMessage, responseHeaders, HttpStatus.OK);
}
</code></pre>

<p>{% endcodeblock %}</p>

<ul>
<li>这里使用java原生的JAXB来解析xml。</li>
</ul>


<p>{% codeblock XmlUtil.java lang:java %}
import com.zzm.wechat.model.TextMessage;
import org.apache.commons.io.IOUtils;</p>

<p>import javax.xml.bind.JAXBContext;
import javax.xml.bind.Marshaller;
import javax.xml.bind.Unmarshaller;
import java.io.StringReader;
import java.io.StringWriter;</p>

<p>public class XmlUtil {</p>

<pre><code>public static String toXml(TextMessage textMessage) throws Exception {
    if (textMessage == null) return "";

    JAXBContext context = JAXBContext.newInstance(TextMessage.class);
    Marshaller m = context.createMarshaller();
    m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);
    m.setProperty(Marshaller.JAXB_FRAGMENT, true);

    StringWriter sw = new StringWriter();
    m.marshal(textMessage, sw);
    return sw.toString();
}

public static TextMessage toTextMessage(String xml) throws Exception {
    JAXBContext jaxbContext = JAXBContext.newInstance(TextMessage.class);
    Unmarshaller jaxbUnmarshaller = jaxbContext.createUnmarshaller();
    StringReader reader = new StringReader(xml);
    TextMessage textMessage = (TextMessage) jaxbUnmarshaller.unmarshal(reader);
    IOUtils.closeQuietly(reader);
    return textMessage;
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<ul>
<li>定义消息的model类，这里需要用到xml的一些annotation。</li>
</ul>


<p>{% codeblock XmlUtil.java lang:java %}
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;</p>

<p>//定义命名空间，如果不写的话，xml会以类名开头: <TextMessage>&hellip;</TextMessage>，写了就会以xml开头: <xml>&hellip;</xml>
@XmlRootElement(name = &ldquo;xml&rdquo;)
public class TextMessage {</p>

<pre><code>private String fromUserName;
private String toUserName;
private String msgType;
private int funcFlag = 0;
private String content;
private String event;
private long createTime;

public TextMessage() {
}

public TextMessage(String fromUserName, String toUserName, String msgType, String content, long createTime) {
    this.fromUserName = fromUserName;
    this.toUserName = toUserName;
    this.msgType = msgType;
    this.content = content;
    this.createTime = createTime;
}

public String getToUserName() {
    return toUserName;
}

//定义xml子项的名称，不写这个annotation的话，转换后的xml是: &lt;toUserName&gt;xxx&lt;/toUserName&gt;，首字母变小写了，会导致消息传输错误
@XmlElement(name = "ToUserName")
public void setToUserName(String toUserName) {
    this.toUserName = toUserName;
}

//other setter and getter

@Override
public String toString() {
    //...
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<ul>
<li><p>方法写完以后，同样的打包，部署SAE。</p></li>
<li><p>打开手机，关注你的公众账号后，就可以看到服务端传过来的消息内容了。</p></li>
</ul>


<p>{% img /images/post/2015-2/wechat_subscribe.png %}</p>

<p>我的公众账号是<code>赵芝明的公账号</code>，有兴趣的也可以加一下，以后这个公共账号的功能肯定会慢慢丰富的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微信公众账号开发part1——开发者验证]]></title>
    <link href="http://zhaozhiming.github.io/blog/2015/02/04/wechat-public-account-dev-part-1/"/>
    <updated>2015-02-04T13:51:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2015/02/04/wechat-public-account-dev-part-1</id>
    <content type="html"><![CDATA[<p>{% img /images/post/2015-2/wechat.jpg %}</p>

<p>最近在了解微信公众账号的开发，准备边学边写一些文章来记录学习的过程，主要是基于微信的开发者模式来进行公共账号的开发，服务器选择新浪云SAE，语言还是选择比较熟悉的JAVA。</p>

<!--more-->


<p></p>

<h2>基本准备</h2>

<ul>
<li>登陆微信公众平台网站: <code>https://mp.weixin.qq.com</code>，进行账号注册，具体可以参考<a href="http://segmentfault.com/blog/zetd/1190000000356021">青龙老贼的这篇文章</a>，虽然内容有点老跟现在的不大一样，但不影响参考。</li>
<li>在SAE上面新建一个JAVA应用，这里还是可以参照<a href="http://segmentfault.com/blog/zetd/1190000000356067">青龙老贼的文章</a>，跟里面不同的是我们要创建一个JAVA的应用，而不是PHP的。</li>
</ul>


<h2>修改开发者中心的配置</h2>

<ul>
<li>登陆进到微信公众平台后，点击左下角的开发者中心，再点击图中的修改配置按钮，就可以进到修改配置页面。</li>
</ul>


<p>{% img /images/post/2015-2/wechat_config_1.png %}</p>

<ul>
<li>填写配置项

<ul>
<li>输入你的SAE的应用URL，比如:<code>http://xxx.sinaapp.com</code>，不一定要写应用的基本URL，可以在上面加一些扩展，比如<code>http://xxx.sinaapp.com/xxx</code>，这个要看你的应用的restful怎么定了。</li>
<li>TOKEN随便输入一个字符串就可以，这个值后面是要配置到java应用里面的，可以理解为一个加密的密钥。</li>
<li>EncodingAESKey随机生成。</li>
<li>消息加解密方式暂时选择明文模式。</li>
</ul>
</li>
</ul>


<p>{% img /images/post/2015-2/wechat_config_2.png %}</p>

<h2>微信服务端开发</h2>

<ul>
<li><p>新建一个spring mvc工程，可以参照<a href="https://confluence.jetbrains.com/display/IntelliJIDEA/Getting+Started+with+Spring+MVC,+Hibernate+and+JSON">这个文章</a>，但我们暂时不需要数据库和页面，只需要定义restful接口就可以了。</p></li>
<li><p>新建Controller并定义认证的api，可以参考微信公众平台开发者文档里面的<a href="http://mp.weixin.qq.com/wiki/17/2d4265491f12608cd170a95559800f2d.html">接入指南</a>，里面有段php代码是指导服务端怎么开发的，我们要做的只是把它翻译成JAVA。</p></li>
</ul>


<p>{% codeblock MainController.java lang:java %}
import com.google.common.base.Joiner;
import com.google.common.collect.Lists;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;</p>

<p>import java.security.MessageDigest;
import java.util.ArrayList;
import java.util.Collections;
@Controller
public class MainController {</p>

<pre><code>private static final Log log = LogFactory.getLog(MainController.class);

//从配置文件获取的token值，就是刚才在修改配置项里面定义的那个Token
@Value("${token}")
private String token;

//定义一个GET请求，url为xxx/index
@RequestMapping(value = "/index", method = RequestMethod.GET, produces = "text/html;charset=UTF-8")
public
@ResponseBody
//接收新手指南里面提到的那4个参数
ResponseEntity&lt;String&gt; auth(@RequestParam("signature") String signature,
                            @RequestParam("timestamp") String timestamp,
                            @RequestParam("nonce") String nonce,
                            @RequestParam("echostr") String echostr) throws Exception {
    log.info("wechat auth start");
    log.info(String.format("signature:%s, timestamp:%s, nonce:%s, echostr:%s",
            signature, timestamp, nonce, echostr));

    //如果认证通过，原样返回echostr值，并返回200的response
    if (wechatAuth(signature, timestamp, nonce)) {
        log.info("wechat auth success");
        return new ResponseEntity&lt;String&gt;(echostr, HttpStatus.OK);
    }

    //如果失败，则返回400，并提示认证失败
    log.info("wechat auth failed");
    return new ResponseEntity&lt;String&gt;("wechat auth failed.", HttpStatus.BAD_REQUEST);
}

private boolean wechatAuth(String signature, String timestamp, String nonce) {
    //将这3个string放到一个list里
    ArrayList&lt;String&gt; strings = Lists.newArrayList(token, timestamp, nonce);
    log.info(String.format("before sort array:%s", strings));
    //按字母顺序做一下排序
    Collections.sort(strings);
    log.info(String.format("after sort array:%s", strings));

    //将list里面所有string组合成一个string，这里用到了guava的Joiner
    String groupString = Joiner.on("").join(strings);
    log.info(String.format("groupString string:%s", groupString));

    //用SHA1加密该string
    String result = sha1(groupString);
    log.info(String.format("sha1:%s", result));
    //加密后的值和signature进行比较，注意用java加密后都是字母都是大写的，而传过来的signature是小写字母，所以要大小写转换一下
    boolean compareResult = result.equals(signature.toUpperCase());
    log.info(String.format("compare result:%b", compareResult));
    return compareResult;
}

//类似php的sha1方法
private String sha1(String s) {
    try {
        // Create MD5 Hash
        MessageDigest digest = MessageDigest.getInstance("SHA-1");
        digest.update(s.getBytes());
        byte messageDigest[] = digest.digest();

        // Create Hex String
        StringBuilder hexString = new StringBuilder();
        for (byte aMessageDigest : messageDigest) {
            hexString.append(String.format("%02X", 0xFF &amp; aMessageDigest));
        }
        return hexString.toString();
    } catch (Exception e) {
        throw new RuntimeException("sha1 failed");
    }
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<ul>
<li>将工程打包成war，上传到SAE完成部署，启动应用</li>
</ul>


<h2>启用开发者模式</h2>

<ul>
<li>进到微信公众平台的开发者中心，点击服务器配置那一行后面的启用按钮，如果服务器正常启动的话，就可以看到启用成功的提示了。</li>
</ul>


<p>{% img /images/post/2015-2/wechat_start.png %}</p>

<p>更多代码可以看这里: <a href="https://github.com/zhaozhiming/wechat-blog%EF%BC%8C%E8%A7%89%E5%BE%97%E5%A5%BD%E7%9A%84%E8%AF%9D%E8%AF%B7Star%E4%B8%80%E4%B8%8B%E5%90%A7%EF%BC%8C%E8%B0%A2%E8%B0%A2">https://github.com/zhaozhiming/wechat-blog%EF%BC%8C%E8%A7%89%E5%BE%97%E5%A5%BD%E7%9A%84%E8%AF%9D%E8%AF%B7Star%E4%B8%80%E4%B8%8B%E5%90%A7%EF%BC%8C%E8%B0%A2%E8%B0%A2</a></p>
]]></content>
  </entry>
  
</feed>
