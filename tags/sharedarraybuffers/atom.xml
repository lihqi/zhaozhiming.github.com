<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: SharedArrayBuffers | Hacker and Geeker's Way]]></title>
  <link href="http://zhaozhiming.github.io/tags/sharedarraybuffers/atom.xml" rel="self"/>
  <link href="http://zhaozhiming.github.io/"/>
  <updated>2017-06-22T20:21:46+08:00</updated>
  <id>http://zhaozhiming.github.io/</id>
  <author>
    <name><![CDATA[赵芝明]]></name>
    <email><![CDATA[kingzzm1982@sina.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[在 Sharedarraybuffers 中使用 Atomics 来避免竞态条件]]></title>
    <link href="http://zhaozhiming.github.io/blog/2017/06/21/avoiding-race-conditions-in-sharedarraybuffers-with-atomics-zh/"/>
    <updated>2017-06-21T15:53:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2017/06/21/avoiding-race-conditions-in-sharedarraybuffers-with-atomics-zh</id>
    <content type="html"><![CDATA[<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_29.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_29.png</a>" width="400" height="350"></p>

<p>这是 3 篇文章中的第三篇：</p>

<ul>
<li><a href="http://zhaozhiming.github.io/blog/2017/06/20/a-crash-course-in-memory-management-zh/">内存管理速成教程</a></li>
<li><a href="http://zhaozhiming.github.io/blog/2017/06/20/a-cartoon-intro-to-arraybuffers-and-sharedarraybuffers-zh/">通俗漫画介绍 ArrayBuffers 和 SharedArrayBuffers</a></li>
<li>在 Sharedarraybuffers 中使用 Atomics 来避免竞态条件</li>
</ul>


<p>原文链接：<a href="https://hacks.mozilla.org/2017/06/avoiding-race-conditions-in-sharedarraybuffers-with-atomics/">Avoiding race conditions in SharedArrayBuffers with Atomics</a></p>

<!--more-->


<h1>在 Sharedarraybuffers 中使用 Atomics 来避免竞态条件</h1>

<p>在<a href="http://zhaozhiming.github.io/blog/2017/06/20/a-cartoon-intro-to-arraybuffers-and-sharedarraybuffers-zh/">上一篇文章</a> 中，我讲述了使用 SharedArrayBuffers 会导致竞态条件，这让 SharedArrayBuffers 使用困难，我们不希望应用开发人员直接使用 SharedArrayBuffers。</p>

<p>但在其他语言上有多线程开发经验的库开发人员可以使用新的底层 API 来创建高级别的工具，应用开发人员就可以使用这些工具而无需直接接触 SharedArrayBuffers 和 Atomics。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_15.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_15.png</a>" width="400" height="350"></p>

<p>尽管你可能不会直接同 SharedArrayBuffers 和 Atomics 打交道，但我觉得了解它们的工作原理还是比较有意思的，所以在这篇文章中，我将讲解它们会带来哪种类型的竞态条件，然后 Atomics 是如何帮助我们避开它们的。</p>

<p>但首先，什么是竞态条件？</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_13.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_13.png</a>" width="400" height="350"></p>

<h2>竞态条件：一个你之前可能看过的例子</h2>

<p>一个相当简单的竞态条件的例子就是，你在两个线程间共享一个变量。说具体一些，一个线程想要加载一个文件，另外一个线程想检查文件是否存在，它们共享了一个变量叫<code>fileExists</code>，通过它来进行通信。</p>

<p>开始时，<code>fileExists</code>被设置为 false。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_03.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_03.png</a>" width="400" height="350"></p>

<p>只要线程 2 的代码先运行，文件将会被加载。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_04.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_04.png</a>" width="400" height="350"></p>

<p>但如果线程 1 的代码先运行，那么它将给用户一个错误记录，说文件不存在。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_05.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_05.png</a>" width="400" height="350"></p>

<p>但文件是否存在不是问题所在，真正的问题是竞态条件。</p>

<p>即使是在单线程代码中，很多 JavaScript 开发人员也会遇到这类竞态条件。要了解为什么这是竞态，并不需要明白什么是多线程。</p>

<p>尽管如此，有些类型的竞态条件在单线程代码中不会出现，但在你进行共享内存的多线程编程时会出现。</p>

<h2>不同类型的竞态条件和 Atomics 如何辅助</h2>

<p>让我们来探索一些你在多线程代码中会遇到的不同类型的竞态条件，然后 Atomics 如何帮助我们避开它们。这里没有覆盖所有的竞态条件，但告诉了你关于为什么 API 会提供这些方法的一些想法。</p>

<p>在我们开始之前，我想要再次申明：你不应该直接使用 Atomics。编写多线程代码是公认的难题，相反地，你应该在你的多线程代码中使用可靠的库来和共享内存打交道。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_06.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_06.png</a>" width="400" height="350"></p>

<h2>单个操作中的竞态条件</h2>

<p>比方说我们有两个线程来递增相同的变量，你可能会认为不管哪个线程先执行，最终的结果都是一样的。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_07.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_07.png</a>" width="400" height="350"></p>

<p>尽管在源码中，递增一个变量看起来是一个单步操作，但在编译后的代码中，它并不是一个单步操作。</p>

<p>在 CPU 层面，递增变量分为三个指令，那是因为计算机既有长期内存也有短期内存（我在<a href="https://hacks.mozilla.org/2017/02/a-crash-course-in-assembly/">另外一篇文章</a> 讲过它们是如何工作的）。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_08.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_08.png</a>" width="400" height="350"></p>

<p>所有线程都共享长期内存，但线程间不共享短期内存（注册者）。</p>

<p>每个线程需要从内存中取到值并放入到短期内存中，然后在短期内存中执行运算，然后把结果从短期内存写回到长期内存。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_09.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_09.png</a>" width="400" height="350"></p>

<p>如果线程 1 的所有操作都先发生，然后线程 2 的所有操作接着发生，那么我们将得到期望的结果。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_10.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_10.png</a>" width="400" height="350"></p>

<p>但如果它们交叉进行，线程 2 放入它的注册者中的值不是内存中同步运行后的结果，这意味着线程 2 没有考虑线程 1 的计算结果，它放弃了线程 1 将自己的值写入到内存的结果。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_11.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_11.png</a>" width="400" height="350"></p>

<p>原子操作做的就是把这些计算机觉得是多步的操作作为单步操作，并让计算机也把它们看成是单步操作。</p>

<p>这就是为什么它们叫做原子操作，因为它们执行一个操作，通常这个操作会有多个指令（指令可以暂停和恢复），让所有指令看似瞬间发生，就好像它是一条指令，就像一个不可分割的原子。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_12.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_12.png</a>" width="400" height="350"></p>

<p>使用原子操作，递增变量的代码看起来有点不一样。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_13.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_13.png</a>" width="400" height="350"></p>

<p>现在我们使用<code>Atomics.add</code>，递增变量的多个步骤将不会在线程间相互交叉，相反，一个线程在完成它的原子操作前不会让其他线程先开始，等本身线程操作执行完了后再让其他线程执行自己的原子操作。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_14.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_14.png</a>" width="400" height="350"></p>

<p>Atomics 的方法帮助避免这类竞态：</p>

<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/add">Atomics.add</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/sub">Atomics.sub</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/and">Atomics.and</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/or">Atomics.or</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/xor">Atomics.xor</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/exchange">Atomics.exchange</a></li>
</ul>


<p>你会发现这个列表相当有限，甚至没有包括乘除操作，虽然库开发人员可以创建类似的原子操作。</p>

<p>开发人员可以使用<code>Atomics.compareExchange</code>来做到这点，通过这个方法，你可以从 SharedArrayBuffer 中取到一个值，然后执行操作，如果你是第一个检出的，就没有其他线程会更新它，执行完了再把它写回到 SharedArrayBuffer 里面；如果其他线程更新了它，那么你可以获取最新的值，然后再操作一次。</p>

<h2>在多操作中的竞态条件</h2>

<p>Atomic 的操作可以帮助你在“单步操作”中避免竞态条件，但有时候你需要改变一个对象的多个值（通过多操作的方式），同时不希望在同一时刻有其他人来更新这个对象。基本上，这意味着每次对象的改变，对象本身相对其他线程来说是锁定并且不可访问的。</p>

<p>Atomics 对象没有提供工具来直接处理这个问题，但它提供了库开发人员可以用来解决这个问题的工具，库开发人员可以创建一个锁。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_15.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_15.png</a>" width="400" height="350"></p>

<p>如果代码想要锁住数据，它必须要有数据的锁，然后它可以用锁来防住其他线程，只有当锁可以用的时候才可以对数据进行访问和更新。</p>

<p>为了创建一个锁，库开发人员可以使用<code>Atomics.wait</code> 和 <code>Atomics.wake</code>，还有其他的方法比如<code>Atomics.compareExchange</code> 和<code>Atomics.store</code>。如果你想要了解这些方法是如何工作的，可以看一下<a href="https://github.com/lars-t-hansen/js-lock-and-condition">这个基本的锁实现</a>。</p>

<p>在这个例子中，线程 2 会要求数据的锁并把<code>locked</code>的值设为 true，这意味着在线程 2 解锁之前线程 1 不能访问数据。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_16.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_16.png</a>" width="400" height="350"></p>

<p>如果线程 1 想要访问数据，它会尝试获取锁，但因为锁已经被占用了，所以它获取不到，线程会等待（所以会有阻塞）直到锁可用。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_17.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_17.png</a>" width="400" height="350"></p>

<p>一旦线程 2 完成了，它会调用解锁操作，完了锁会通知那些一直在等待锁的线程们：我现在可以用了。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_18.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_18.png</a>" width="400" height="350"></p>

<p>然后线程会取到锁，为它自己能单独使用而将数据锁住。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_19.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_19.png</a>" width="400" height="350"></p>

<p>一个关于锁的库会使用 Atomics 对象多个不同的方法，但在这种情况下最重要的方法是：</p>

<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/wait">Atomics.wait</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/wake">Atomics.wake</a></li>
</ul>


<h2>指令重排序引起的竞态条件</h2>

<p>这是 Atomics 负责的第三种同步问题，这一个会让人惊讶。</p>

<p>你可能没有意识到这一点，但这是一个好机会（让你了解它），你写的代码没有按照你的预期顺序运行，编译器和 CPU 会重新排序代码让其跑得更快。</p>

<p>打个比方，假如说你要写代码来计算总数，你想要在总数计算完成后设置一个标示。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_20.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_20.png</a>" width="400" height="350"></p>

<p>为了编译这些代码，我们需要为每个变量决定使用哪个注册机，然后我们可以将源码翻译成指令给计算机看。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_21.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_21.png</a>" width="400" height="350"></p>

<p>到目前为止，所有事情都按预期进行。</p>

<p>如果你不理解计算机是如何在限制条件下工作的（和如何使用管道来执行代码），那么这看起来会不明显，第二行代码会在它执行之前稍微等一会。</p>

<p>大部分计算机会把执行指令的过程分成多个步骤，这样确保了 CPU 在不同区域都能保持一直忙碌，这样可以充分利用 CPU。</p>

<p>这里是一个指令的过程步骤示例：</p>

<ul>
<li>从内存中获取下个指令</li>
<li>计算出指令告诉我们要做什么（比如解码指令），然后从注册者中取到值</li>
<li>执行指令</li>
<li>把结果写回注册者</li>
</ul>


<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_22.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_22.png</a>" width="400" height="350"></p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_23.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_23.png</a>" width="400" height="350"></p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_24.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_24.png</a>" width="400" height="350"></p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_25.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_25.png</a>" width="400" height="350"></p>

<p>这就是一个指令是经过管道的过程。理想情况下，我们想要紧接着执行第二个命令，一旦我们进入第二步，我们就会去获取下个指令。</p>

<p>问题在于指令#1 和指令#2 之间会有依赖。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_26.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_26.png</a>" width="400" height="350"></p>

<p>我们可以暂停 CPU 直到指令#1 在注册机中更新完<code>subTotal</code>，但这会减慢速度。</p>

<p>为了让事情更有效率，大部分编译器和 CPU 将会重新排序代码，他们会寻找那些没有使用<code>subTotal</code>或<code>total</code>的指令，然后把它们移动到这两行代码中间。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_27.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_27.png</a>" width="400" height="350"></p>

<p>这可以让指令源源不断地移动通过管道。</p>

<p>因为第 3 行没有依赖第 1 或 2 行的值，所以编译器或者 CPU 计算出它重排序是安全的。当你在一个单线程中运行时，没有其他代码会看到这一部分值，直到整个函数执行完成。</p>

<p>但当你在另外一个处理器上有其他的线程在同时运行时，情况就不一样了。其它线程不用等方法完成后再去看这些变化，它可以在回写内存时马上看到它们，所以<code>isDone</code>标示在被告知总数前就被设置好了。</p>

<p>如果你想要用<code>isDone</code>来表示总数已经计算完成并准备用于其他线程，那么这种重排序将产生竞态条件。</p>

<p>Atomics 尝试解决其中的一些缺陷，当你使用一个 Atomic 写操作，就好比在代码的两部分中间放入一个栅栏。</p>

<p>Atomic 没有彼此间的重排序操作，也没有其他操作可以移动它们。实际上，有两个操作经常用于控制顺序：</p>

<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/load">Atomics.load</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/store">Atomics.store</a></li>
</ul>


<p>在同一方法的代码中，所有在<code>Atomics.store</code>上面的变量，它们的更新在其写回内存之前都会在<code>Atomics.store</code>完成之前完成，即使有非原子指令在彼此间重新排序，它们中任何一个指令也不能移动到<code>Atomics.store</code>下面去执行。</p>

<p>在同一方法的代码中，所有在<code>Atomics.load</code>下面的变量，它们的加载都会在<code>Atomics.load</code>完成之后完成，同样地，即使有非原子指令在彼此间重新排序，它们中任何一个指令也不能移动到<code>Atomics.load</code>上面去执行。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_28.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_28.png</a>" width="400" height="350"></p>

<p>注意，我在这里展示的 while 循环叫做自旋锁，它的效率是非常低的。如果它在主线程中，它可能会让你的应用挂起，你肯定不会在真实代码中使用它。</p>

<p>再次申明，在应用代码中不要直接使用这些方法，相反地，库会用它们来创建锁。</p>

<h2>总结</h2>

<p>共享内存的多线程编程是困难的，有很多种不同类型的竞态条件的坑等着你去踩。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_29.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/03_29.png</a>" width="400" height="350"></p>

<p>这就是为什么不要在你的应用代码中直接用 SharedArrayBuffers 和 Atomics，你应该依赖那些有多线程开发经验的开发者开发出来的库，他们花了很多时间在研究内存模型。</p>

<p>现在离 SharedArrayBuffer 和 Atomics 的到来还有点早，这些库也还没创建出来，但这些新的 API 提供了基础功能来创建它们。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[通俗漫画介绍 ArrayBuffers 和 SharedArrayBuffers]]></title>
    <link href="http://zhaozhiming.github.io/blog/2017/06/20/a-cartoon-intro-to-arraybuffers-and-sharedarraybuffers-zh/"/>
    <updated>2017-06-20T22:44:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2017/06/20/a-cartoon-intro-to-arraybuffers-and-sharedarraybuffers-zh</id>
    <content type="html"><![CDATA[<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_15.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_15.png</a>" width="400" height="350"></p>

<p>这是 3 篇文章中的第二篇：</p>

<ul>
<li><a href="http://zhaozhiming.github.io/blog/2017/06/20/a-crash-course-in-memory-management-zh/">内存管理速成教程</a></li>
<li>通俗漫画介绍 ArrayBuffers 和 SharedArrayBuffers</li>
<li><a href="http://zhaozhiming.github.io/blog/2017/06/21/avoiding-race-conditions-in-sharedarraybuffers-with-atomics-zh/">在 Sharedarraybuffers 中使用 Atomics 来避免竞态条件</a></li>
</ul>


<p>原文链接：<a href="https://hacks.mozilla.org/2017/06/a-cartoon-intro-to-arraybuffers-and-sharedarraybuffers/">A cartoon intro to ArrayBuffers and SharedArrayBuffers</a></p>

<!--more-->


<h1>通俗漫画介绍 ArrayBuffers 和 SharedArrayBuffers</h1>

<p>在<a href="http://zhaozhiming.github.io/blog/2017/06/20/a-crash-course-in-memory-management-zh/">上一篇文章中</a>，我解释了像 JavaScript 这样的内存管理语言如何操作内存，我也解释了像 C 语言这样的手动内存管理语言如何工作的。</p>

<p>为什么当我们讨论 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer">ArrayBuffers</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer">SharedArrayBuffers</a> 时这部分内容很重要呢？</p>

<p>这是因为 ArrayBuffers 提供了一种让你可以手动操作数据的方式，即使你是使用像 JavaScript 这种内存自动管理的语言。</p>

<p>为什么你将来会去做这件事（指内存管理）？</p>

<p>正如上一篇文章所说的，这是自动内存管理的一个权衡，它方便开发人员，但增加了开销，某些情况下，这种开销会导致性能问题。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_01.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_01.png</a>" width="400" height="350"></p>

<p>举个例子，当你要在 JS 中创建一个变量，引擎必须猜测这个变量是哪种类型，如何在内存中展示。因为这种猜测，JS 引擎通常会为变量预留比实际占用的更多的空间，依赖于变量，内存槽容量可能比实际需要的要大 2 到 8 倍，这将导致很多内存的浪费。</p>

<p>另外，某些创建和使用 JS 对象的模式可能让垃圾回收难以进行，如果你可以手动管理内存，你就可以在工作中选择一个正确分配和释放内存的策略。</p>

<p>大部分情况下，这不会有什么问题。大部分系统性能不会如此敏感，以致要你使用手动内存管理，而且通常情况下，手动管理内存甚至可能让程序变得更慢。</p>

<p>但有时候你需要处理一些底层的工作来让你的代码运行得尽可能的快，ArrayBuffers 和 SharedArrayBuffers 给你另外一个选择。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_02.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_02.png</a>" width="400" height="350"></p>

<h2>那么 ArrayBuffer 是如何工作的？</h2>

<p>基本上它就像 JavaScript 中的其他数组，但是你不能在里面放任何类型的数据，比如字符串和对象，你只能在里面放二进制字节（可以用来表示数字的那个东西）。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_03.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_03.png</a>" width="400" height="350"></p>

<p>有件事情我必须在这里澄清，实际上你不能直接添加二进制字节到 ArrayBuffer，ArrayBuffer 本身不知道这个字节应该多大，不同类型的数字应该如何转换成字节。</p>

<p>ArrayBuffer 本身只是一个 0 和 1 存放在一行里面的一个集合，ArrayBuffer 不知道第一个和第二个元素在数组中该如何分配。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_04.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_04.png</a>" width="400" height="350"></p>

<p>为了能提供上下文，为了能真正分解数据并放入到盒子中，我们需要将其封装在一个叫做 view 的东西里面。这些在数据上的 view 可以被添加进确定类型的数组，而且我们有很多种确定类型的数据可以使用。</p>

<p>例如，你可以使用一个 Int8 的确定类型数组来分离存放 8 位二进制字节。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_05.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_05.png</a>" width="400" height="350"></p>

<p>或者你可以使用一个无符号的 Int16 数组来分离存放 16 位二进制字节，这样如果是一个无符号的整数也能处理。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_06.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_06.png</a>" width="400" height="350"></p>

<p>你甚至可以在相同基础的 buffer 上使用不同的 view，同样的操作不同的 view 会给你不同的结果。</p>

<p>比如，如果我们在这个 ArrayBuffer 中从 Int8 view 里获取了元素 0 和 1，在 Uint16 view 中元素 0 会返回给我们不同的值，尽管它们包含的是完全相同的二进制字节。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_07.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_07.png</a>" width="400" height="350"></p>

<p>在这种方式中，ArrayBuffer 基本上扮演了一个原生内存的角色，它模拟了像 C 语言才有的那种直接访问内存的方式。</p>

<p>你可能想知道为什么我们不让程序直接访问内存，而是添加了这种抽象层。直接访问内存将导致一些安全漏洞，我会在以后的文章中解释。</p>

<h2>那么什么是 SharedArrayBuffer？</h2>

<p>为了解释 SharedArrayBuffers，我需要解释一点关于并行运行代码和 JavaScript 的知识。</p>

<p>你可以并行运行代码让你的代码跑的更快，或者让其更快地相应用户事件。为了做到这点，你需要分离你的工作。</p>

<p>在一个典型的 app 中，所有工作都在一个单独独立的主线程中被照看着，我以前讲过这个。主线程就像一个全栈开发，它负责 JavaScript，DOM 结构和页面布局。</p>

<p>如果你能减少主线程的工作量，不管是什么事情都对工作负载有帮助，在某些情况下，ArrrayBuffer 可以减少主线程的工作量。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_08.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_08.png</a>" width="400" height="350"></p>

<p>但是有些时候减少主线程的工作负载是不够的，有时候你需要一些援助，你需要分离工作。</p>

<p>在大部分编程语言中，通常分离工作的方式就是使用一种叫做线程的东西，基本上这就像有多个人在做同一个项目。如果你的任务都比较独立，你就可以将任务分配给不同的线程，这样所有线程都可以在相同的时间内独立完成任务。</p>

<p>在 JavaScript 中，你可以使用一个叫做 web worker 的东西来做这件事情，这些 web worker 跟你在其他语言中用到的线程有些许差别，它们默认不共享内存。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_09.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_09.png</a>" width="400" height="350"></p>

<p>这意味着如果你想要共享一些数据给其他线程，你需要复制它们，方法 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage"><code>postMessage</code></a> 可以做到这点。</p>

<p>postMessage 获取你放进去的任何数据，序列化它们，再将其发送给其他 web worker，然后其他 web worker 反序列数据再将其放入到内存。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_10.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_10.png</a>" width="400" height="350"></p>

<p>这是一个非常慢的过程。</p>

<p>某些类型的数据，像 ArrayBuffer，你能做的操作叫做转移内存，这意味着移动指定的内存块让其他 web worker 可以访问数据。<br/>
但第一个 web worker 就不能再访问移动后的数据了。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_11.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_11.png</a>" width="400" height="350"></p>

<p>在某些情况下这可以工作，但大部分情况是你需要高性能的并行方式，你真正需要的是拥有可以共享的内存。</p>

<p>这就是需要 SharedArrayBuffers 的原因。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_12.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_12.png</a>" width="400" height="350"></p>

<p>通过 SharedArrayBuffer，不管是 web worker，还是线程，都可以从相同的内存块中读写数据。</p>

<p>这意味着你不会有使用 postMessage 时的交流开销和延迟。所有 web worker 都可以立即访问数据。</p>

<p>在同一时刻所有线程都访问同一数据会有些危险，可能引起一个叫竞态条件的问题。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_13.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_13.png</a>" width="400" height="350"></p>

<p>我将在<a href="http://zhaozhiming.github.io/blog/2017/06/21/avoiding-race-conditions-in-sharedarraybuffers-with-atomics-zh/">下一篇文章</a> 中解释。</p>

<h2>SharedArrayBuffers 当前的现状是怎样的？</h2>

<p>SharedArrayBuffers 不久将会出现在所有主流浏览器中。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_14.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_14.png</a>" width="400" height="350"></p>

<p>它们已经在 Safari（在 Safari 10.1）里了，Firefox 和 Chrome 将在他们的 7/8 月的发布中引进它们，而且 Edge 也将在秋季的 Windows 更新中引进它们。</p>

<p>不过即使它们在所有主流浏览器中都可用，我们也不希望应用开发人员直接使用它们。实际上，我们推荐不用它们，你应该使用最高级别的抽象封装。</p>

<p>我们希望 JavaScript 库开发人员来创建对应的库来让你更方便和安全地使用 SharedArrayBuffers。</p>

<p>另外，一旦 SharedArrayBuffers 内置到平台中，WebAssembly 就可以使用它们来实现线程支持。一旦到位，你就可以使用像 Rust 那样的并发抽象技术，Rust 的主要目标之一就是让你无所畏惧地使用并发编程。</p>

<p>在<a href="http://zhaozhiming.github.io/blog/2017/06/21/avoiding-race-conditions-in-sharedarraybuffers-with-atomics-zh/">下一篇文章</a>中，我们将介绍这些库作者使用的工具（Atomics），他们用来构建抽象层同时避免竞态条件。</p>

<p><img class="<a" src="href="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_15.png">https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/06/02_15.png</a>" width="400" height="350"></p>
]]></content>
  </entry>
  
</feed>
