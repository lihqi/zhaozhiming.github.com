<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: spring | Hacker and Geeker's Way]]></title>
  <link href="http://zhaozhiming.github.io/tags/spring/atom.xml" rel="self"/>
  <link href="http://zhaozhiming.github.io/"/>
  <updated>2016-05-31T21:00:13+08:00</updated>
  <id>http://zhaozhiming.github.io/</id>
  <author>
    <name><![CDATA[赵芝明]]></name>
    <email><![CDATA[kingzzm1982@sina.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[如何在Spring中配置Websocket]]></title>
    <link href="http://zhaozhiming.github.io/blog/2015/05/11/spring-websocket-config/"/>
    <updated>2015-05-11T09:41:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2015/05/11/spring-websocket-config</id>
    <content type="html"><![CDATA[<p>{% img /images/post/2015-5/websockets.png %}</p>

<p>Websocket是HTML5的一项新技术，可以让服务端和客户端进行实时的通信，主要的使用场景有: 实时的聊天系统，对实时性要求比较高的游戏，或者金融行业对股票市场数据的及时获取等。在Spring3的时候就已经有了对Websocket的支持，不过需要一些高版本的web容器来运行，比如Tomcat7.0.47+，Jetty9等。</p>

<!--more-->


<p></p>

<p>在Spring的官网上有关于Websocket的示例工程，<a href="https://spring.io/guides/gs/messaging-stomp-websocket/">https://spring.io/guides/gs/messaging-stomp-websocket/</a>，里面简单介绍了如何通过Spring-boot来进行Websocket系统的构建。我们的例子将基于这个例子进行修改，但是是使用传统的Spring的方式进行配置。</p>

<h2>依赖包</h2>

<p>首先我们需要添加相关的依赖包:</p>

<ul>
<li>Websocket需要servlet3.1的版本</li>
<li>spring-websocket和spring-messaging是Spring关于Websocket的组件</li>
<li>使用Jackson进行json数据的处理</li>
</ul>


<p>{% codeblock build.gradle lang:groovy %}
String springVersion = &ldquo;4.1.4.RELEASE&rdquo;
String jacksonDatabindVersion = &ldquo;2.5.0&rdquo;
String jacksonVersion = &ldquo;1.9.13&rdquo;
dependencies {</p>

<pre><code>//websocket
compile("javax.websocket:javax.websocket-api:1.1")
compile("javax.servlet:javax.servlet-api:3.1.0")

//spring
compile("org.springframework:spring-messaging:" + springVersion)
compile("org.springframework:spring-websocket:" + springVersion)

//json
compile "com.fasterxml.jackson.core:jackson-databind:" + jacksonDatabindVersion
compile "org.codehaus.jackson:jackson-mapper-asl:" + jacksonVersion
compile "org.codehaus.jackson:jackson-core-asl:" + jacksonVersion
</code></pre>

<p>}
{% endcodeblock %}</p>

<h2>xml配置（类配置）</h2>

<p>我们有两种方式进行Websocket的配置，一种是通过xml文件的方式，在这里我们定义了websocket的配置信息，这样服务器往客户端发送消息就可以通过<code>/topic/xx</code>来发送，客户端则可以通过<code>/app/hello</code>来发送消息到服务端。</p>

<p>{% codeblock lang:xml %}
&lt;beans xmlns=&ldquo;<a href="http://www.springframework.org/schema/beans">http://www.springframework.org/schema/beans</a>&rdquo;</p>

<pre><code>   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:websocket="http://www.springframework.org/schema/websocket"
   xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
    http://www.springframework.org/schema/websocket http://www.springframework.org/schema/websocket/spring-websocket.xsd"&gt;

...... // other configurations

&lt;websocket:message-broker application-destination-prefix="/app"&gt;
    &lt;websocket:stomp-endpoint path="/hello"&gt;
        &lt;websocket:sockjs/&gt;
    &lt;/websocket:stomp-endpoint&gt;
    &lt;websocket:simple-broker prefix="/topic"/&gt;
&lt;/websocket:message-broker&gt;
</code></pre>

<p></beans>
{% endcodeblock %}</p>

<p>另外一种方式是通过类的方式，代码如下，功能与上面的xml配置相同:</p>

<p>{% codeblock WebSocketConfig.java lang:java %}
import org.springframework.context.annotation.Configuration;
import org.springframework.messaging.simp.config.MessageBrokerRegistry;
import org.springframework.web.socket.config.annotation.AbstractWebSocketMessageBrokerConfigurer;
import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;
import org.springframework.web.socket.config.annotation.StompEndpointRegistry;</p>

<p>@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig extends AbstractWebSocketMessageBrokerConfigurer {</p>

<pre><code>@Override
public void configureMessageBroker(MessageBrokerRegistry config) {
    config.enableSimpleBroker("/topic");
    config.setApplicationDestinationPrefixes("/app");
}

@Override
public void registerStompEndpoints(StompEndpointRegistry registry) {
    registry.addEndpoint("/hello").withSockJS();
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<h2>消息类和Controller定义</h2>

<p>Controller定义:</p>

<p>{% codeblock WebSocketConfig.java lang:java %}
import com.zzm.wechat.model.Greeting;
import com.zzm.wechat.model.HelloMessage;
import org.springframework.messaging.handler.annotation.MessageMapping;
import org.springframework.messaging.handler.annotation.SendTo;
import org.springframework.stereotype.Controller;</p>

<p>@Controller
public class GreetingController {</p>

<pre><code>@MessageMapping("/hello")
@SendTo("/topic/greetings")
public Greeting greeting(HelloMessage message) throws Exception {
    Thread.sleep(3000); // simulated delay
    return new Greeting("Hello, " + message.getName() + "!");
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>消息model的定义:</p>

<p>{% codeblock WebSocketConfig.java lang:java %}
public class Greeting {</p>

<pre><code>private String content;

public Greeting(String content) {
    this.content = content;
}

public String getContent() {
    return content;
}
</code></pre>

<p>}</p>

<p>public class HelloMessage {</p>

<pre><code>private String name;

public String getName() {
    return name;
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>在web.xml中设置controller的url前缀，这样可以避免一些页面的url被controller拦截。</p>

<p>{% codeblock web.xml lang:xml %}</p>

<pre><code>&lt;servlet&gt;
    &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/api/*&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>

<p>{% endcodeblock %}</p>

<h2>客户端页面</h2>

<p>首先下载<code>stomp.js</code>和<code>sockjs.js</code>，然后编写一个html页面进行客户端websocket的连接，并实现发送消息和接收消息的功能。我们使用SockJS的方式来创建Websocket连接，注意url要加上domain名称(这里是<code>server</code>)和<code>api</code>前缀。</p>

<p>{% codeblock demo.html lang:html %}
&lt;!DOCTYPE html>
<html>
<head></p>

<pre><code>&lt;title&gt;Hello WebSocket&lt;/title&gt;
&lt;script src="resources/sockjs-0.3.4.js"&gt;&lt;/script&gt;
&lt;script src="resources/stomp.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
    var stompClient = null;

    function setConnected(connected) {
        document.getElementById('connect').disabled = connected;
        document.getElementById('disconnect').disabled = !connected;
        document.getElementById('conversationDiv').style.visibility = connected ? 'visible' : 'hidden';
        document.getElementById('response').innerHTML = '';
    }

    function connect() {
        var socket = new SockJS('/server/api/hello');
        stompClient = Stomp.over(socket);
        stompClient.connect({}, function(frame) {
            setConnected(true);
            console.log('Connected: ' + frame);
            stompClient.subscribe('/topic/greetings', function(greeting){
                showGreeting(JSON.parse(greeting.body).content);
            });
        });
    }

    function disconnect() {
        if (stompClient != null) {
            stompClient.disconnect();
        }
        setConnected(false);
        console.log("Disconnected");
    }

    function sendName() {
        var name = document.getElementById('name').value;
        stompClient.send("/app/hello", {}, JSON.stringify({ 'name': name }));
    }

    function showGreeting(message) {
        var response = document.getElementById('response');
        var p = document.createElement('p');
        p.style.wordWrap = 'break-word';
        p.appendChild(document.createTextNode(message));
        response.appendChild(p);
    }
&lt;/script&gt;
</code></pre>

<p></head>
<body onload="disconnect()">
<noscript><h2 style="color: #ff0000">Seems your browser doesn&rsquo;t support Javascript! Websocket relies on Javascript being enabled. Please enable</p>

<pre><code>Javascript and reload this page!&lt;/h2&gt;&lt;/noscript&gt;
</code></pre>

<div>
    <div>
        <button id="connect" onclick="connect();">Connect</button>
        <button id="disconnect" disabled="disabled" onclick="disconnect();">Disconnect</button>
    </div>
    <div id="conversationDiv">
        <label>What is your name?</label><input type="text" id="name" />
        <button id="sendName" onclick="sendName();">Send</button>
        <p id="response"></p>
    </div>
</div>


<p></body>
</html>
{% endcodeblock %}</p>

<p>运行结果：</p>

<p>{% img /images/post/2015-5/websocket-run.png %}</p>

<p>浏览器console信息:</p>

<p>{% codeblock lang:sh %}
Disconnected
chrome-extension://fhhdlnnepfjhlhilgmeepgkhjmhhhjkh/js/detector.js:505 detector
chrome-extension://fhhdlnnepfjhlhilgmeepgkhjmhhhjkh/js/detector.js:506 Object
stomp.js:130 Opening Web Socket&hellip;
stomp.js:130 Web Socket Opened&hellip;
stomp.js:130 >>> CONNECT
accept-version:1.1,1.0
heart-beat:10000,10000</p>

<p>&lt;&lt;&lt; CONNECTED
version:1.1
heart-beat:0,0</p>

<p>connected to server undefined
demo.html:22 Connected: CONNECTED
heart-beat:0,0
version:1.1</p>

<blockquote><blockquote><blockquote><p>SUBSCRIBE
id:sub-0
destination:/topic/greetings</p>

<p>SEND
destination:/app/hello
content-length:14</p></blockquote></blockquote></blockquote>

<p>{&ldquo;name&rdquo;:&ldquo;zzm&rdquo;}
&lt;&lt;&lt; MESSAGE
destination:/topic/greetings
content-type:application/json;charset=UTF-8
subscription:sub-0
message-id:3657pj5u-0
content-length:25</p>

<p>{&ldquo;content&rdquo;:&ldquo;Hello, zzm!&rdquo;}
{% endcodeblock %}</p>

<h2>gradle运行jetty9</h2>

<p>gradle内置的Jetty版本是Jetty6，由于版本较低不支持websocket，所以我们测试的话需要打包并部署到Jetty9或Tomcat7.0.47+上，但我们可以通过其他gradle插件来把我们的本地服务运行到Jetty9上。这里介绍2个插件，<a href="https://github.com/akhikhl/gretty">Gretty</a>和<a href="https://github.com/bmuschko/gradle-cargo-plugin">Cargo</a>。</p>

<h4>Gretty</h4>

<p>在<code>build.gradle</code>中添加如下脚本:</p>

<p>{% codeblock build.gradle lang:groovy %}
buildscript {</p>

<pre><code>repositories {
    maven {
        url "http://maven.oschina.net/content/groups/public/"
    }
}

dependencies {
    classpath 'org.akhikhl.gretty:gretty:+'
}
</code></pre>

<p>}</p>

<p>apply plugin: &lsquo;org.akhikhl.gretty&rsquo;
// apply plugin: &lsquo;jetty&rsquo; 注意要注释掉原来的jetty插件</p>

<p>gretty {</p>

<pre><code>httpPort = 9898 // 指定web服务的http端口
servletContainer = 'jetty9' // 这里可以指定tomcat,jetty的几个版本
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>然后运行<code>gradle appRun</code>即可。</p>

<h4>Cargo</h4>

<p>在<code>build.gradle</code>中添加如下脚本，注意要先下载jetty9的安装包并解压:</p>

<p>{% codeblock build.gradle lang:groovy %}
buildscript {</p>

<pre><code>repositories {
    maven {
        url "http://maven.oschina.net/content/groups/public/"
    }
}

dependencies {
    classpath 'com.bmuschko:gradle-cargo-plugin:2.1'
}
</code></pre>

<p>}</p>

<p>apply plugin: &lsquo;com.bmuschko.cargo&rsquo;
cargo {</p>

<pre><code>containerId = 'jetty9x'
port = 9898
local {
    homeDir = file('/Users/zhaozhiming/tools/jetty-distribution-9.2.10.v20150310')
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>然后运行<code>gradle war CargoRunLocal</code>，注意首先要打出war包，然后插件会自动部署war包到Jetty9的安装目录下，这种方式不大灵活，比如一些页面的修改都需要重新部署才能进行测试。</p>

<p>最后附上Spring关于Websocket的文档链接，请见<a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html">这里</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Spring-data进行Redis操作]]></title>
    <link href="http://zhaozhiming.github.io/blog/2015/04/12/spring-data-redis/"/>
    <updated>2015-04-12T15:15:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2015/04/12/spring-data-redis</id>
    <content type="html"><![CDATA[<p>{% img /images/post/2015-4/spring-redis.jpg %}</p>

<p><a href="http://redis.io/">Redis</a>相信大家都听说过，它是一个开源的key-value缓存数据库，有很多Java的客户端支持，比较有名的有Jedis，JRedis等（见<a href="http://redis.io/clients#java">这里</a>）。当然我们可以使用客户端的原生代码实现redis的操作，但实际上在spring中就已经集成了这些客户端的使用，下面我们就以Jedis为例来介绍一下Spring中关于Redis的配置。</p>

<!--more-->


<p></p>

<h2>下载相关依赖包</h2>

<p>首先要下载spring和redis相关的依赖包，最新的jedis版本是2.6.2，还需要下载jackson的包，这个后面会介绍为什么需要，以gradle脚本示例如下。</p>

<p>{% codeblock build.gradle lang:sh %}</p>

<pre><code>compile("redis.clients:jedis:" + jedisVersion)
compile "org.springframework.data:spring-data-redis:" + springDataRedisVersion

//json
compile "com.fasterxml.jackson.core:jackson-databind:" + jacksonDatabindVersion
compile "org.codehaus.jackson:jackson-mapper-asl:" + jacksonVersion
compile "org.codehaus.jackson:jackson-core-asl:" + jacksonVersion
</code></pre>

<p>{% endcodeblock %}</p>

<h2>spring配置jedis</h2>

<p>在spring的xml配置文件中，做如下配置。</p>

<p>{% codeblock lang:xml %}</p>

<pre><code>&lt;!-- 配置redis池，依次为最大实例数，最大空闲实例数，(创建实例时)最大等待时间，(创建实例时)是否验证 --&gt;
&lt;bean id="jedisPoolConfig" class="redis.clients.jedis.JedisPoolConfig"&gt;
    &lt;property name="maxTotal" value="${redis.maxTotal}"/&gt;
    &lt;property name="maxIdle" value="${redis.maxIdle}"/&gt;
    &lt;property name="maxWaitMillis" value="${redis.maxWaitMillis}"/&gt;
    &lt;property name="testOnBorrow" value="${redis.testOnBorrow}"/&gt;
&lt;/bean&gt;

&lt;!-- redis连接配置，依次为主机ip，端口，是否使用池，(usePool=true时)redis的池配置 --&gt;
&lt;bean id="jedisFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory"&gt;
    &lt;property name="hostName" value="${redis.host}"/&gt;
    &lt;property name="port" value="${redis.port}"/&gt;
    &lt;property name="usePool" value="true"/&gt;
    &lt;property name="poolConfig" ref="jedisPoolConfig"/&gt;
&lt;/bean&gt;

&lt;!-- redis模板配置 --&gt;
&lt;bean id="redisTemplate" class="org.springframework.data.redis.core.RedisTemplate"&gt;
    &lt;property name="connectionFactory" ref="jedisFactory"/&gt;
    &lt;property name="defaultSerializer"&gt;
        &lt;bean class="org.springframework.data.redis.serializer.StringRedisSerializer"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>

<p>{% endcodeblock %}</p>

<h2>序列化</h2>

<p>在spring中进行redis存储，如果没有对key和value进行序列化，保存到redis中会出现乱码。注意看上面的redis模板配置，有个配置项是defaultSerializer，这里表示redis中的key和value遇到需要序列化的时候，都默认使用StringRedisSerializer这个类来进行序列化。如果不指定序列化的话，内容会带乱码。</p>

<p>spring-data-redis的序列化类有下面这几个:</p>

<ul>
<li>GenericToStringSerializer: 可以将任何对象泛化为字符串并序列化</li>
<li>Jackson2JsonRedisSerializer: 跟JacksonJsonRedisSerializer实际上是一样的</li>
<li>JacksonJsonRedisSerializer: 序列化object对象为json字符串</li>
<li>JdkSerializationRedisSerializer: 序列化java对象</li>
<li>StringRedisSerializer: 简单的字符串序列化</li>
</ul>


<p>一般如果key-value都是string的话，使用StringRedisSerializer就可以了，如果需要保存对象为json的话推荐使用JacksonJsonRedisSerializer，它不仅可以将对象序列化，还可以将对象转换为json字符串并保存到redis中，但需要和jackson配合一起使用。</p>

<h2>简单的redis操作</h2>

<p>代码示例如下，使用redis进行set和get操作。</p>

<p>{% codeblock MyUserRepository.java lang:java %}
@Repository
public class MyUserRepository {</p>

<pre><code>//直接使用autowire就可以引用到配置文件中的redis-template
@Autowired
private RedisTemplate&lt;String, MyUser&gt; template;

private ValueOperations&lt;String, MyUser&gt; operations;

@PostConstruct
public void init() {
    //这里设置value的序列化方式为JacksonJsonRedisSerializer  
    template.setValueSerializer(new JacksonJsonRedisSerializer&lt;&gt;(MyUser.class));
    operations = template.opsForValue();
}

public void set(String key, MyUser value) {
    operations.set(key, value);
}

public MyUser get(String key) {
    return operations.get(key);
}
</code></pre>

<p>}</p>

<p>// model
public class MyUser {</p>

<pre><code>private String username;
private int age;
// ... setter and getter
</code></pre>

<p>}</p>

<p>// 在Controller中调用
@Controller
public class MainController {</p>

<pre><code>@Autowired
private MyUserRepository myUserRepository;

@RequestMapping(value = "/test", method = RequestMethod.GET)
public
@ResponseBody
ResponseEntity&lt;?&gt; test() throws Exception {
    MyUser user = new MyUser("zhaozhiming", 100);
    String key = "my:user:zhaozhiming";
    myUserRepository.set(key, user);
    MyUser myUser = myUserRepository.get(key);
    log.debug(String.format("my user:%s", myUser));
    String result = mapper.writeValueAsString(user);
    return new ResponseEntity&lt;&gt;(result, HttpStatus.OK);
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>调用set方法后，可以在日志中看到get后的MyUser对象。</p>

<p>{% codeblock lang:sh %}
 &ndash; my user:MyUser{age=100, username=&lsquo;zhaozhiming&rsquo;}
{% endcodeblock %}</p>

<p>也可以在redis里面看到保存后的json字符串了。</p>

<p>{% img /images/post/2015-4/redis_result.png %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Spring Security进行LDAP认证]]></title>
    <link href="http://zhaozhiming.github.io/blog/2014/12/18/use-spring-security-to-ldap-authentication/"/>
    <updated>2014-12-18T08:56:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2014/12/18/use-spring-security-to-ldap-authentication</id>
    <content type="html"><![CDATA[<p>{% img /images/post/2014-12/spring-security.jpeg %}</p>

<p>这里介绍一下如何是用Spring Security来做LDAP的认证，LDAP服务器只存放了用户的用户名和密码，没有角色等其他权限，所以这里介绍的是最简单的用户名密码认证。</p>

<!--more-->


<h2>下载spring-security相关JAR包</h2>

<p>下面是gradle的脚本配置，需要下载spring-security和ldap相关的JAR包。</p>

<p>{% codeblock build.gradle lang:groovy %}
String springSecurityVersion = &ldquo;3.2.5.RELEASE&rdquo;</p>

<p>dependencies {</p>

<pre><code>...//other spring jars

//security
compile "org.springframework.security:spring-security-core:" + springSecurityVersion
compile "org.springframework.security:spring-security-web:" + springSecurityVersion
compile "org.springframework.security:spring-security-config:" + springSecurityVersion
compile "org.springframework.security:spring-security-ldap:" + springSecurityVersion
compile "org.springframework.ldap:spring-ldap-core:2.0.2.RELEASE"
</code></pre>

<p>}
{% endcodeblock %}</p>

<h2>配置web.xml</h2>

<p>在web.xml配置<code>filter</code>，修改内容如下。</p>

<p>{% codeblock web.xml lang:xml %}
<filter>
   &lt;filter-name>springSecurityFilterChain&lt;/filter-name>
  &lt;filter-class>org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class>
</filter>
&lt;filter-mapping>
   &lt;filter-name>springSecurityFilterChain&lt;/filter-name>
   &lt;url-pattern>/*&lt;/url-pattern>
&lt;/filter-mapping></p>

<p><listener>
   &lt;listener-class>org.springframework.web.context.ContextLoaderListener&lt;/listener-class>
</listener></p>

<p>&lt;context-param>
   &lt;param-name>contextConfigLocation&lt;/param-name>
   &lt;param-value>classpath:spring-security.xml&lt;/param-value>
&lt;/context-param>
{% endcodeblock %}</p>

<h2>创建spring-security.xml</h2>

<p>在web.xml里面指定了Application启动时需要加载spring-security.xml文件，我们的LDAP认证主要就配置在这个文件里面。</p>

<p>{% codeblock spring-security.xml lang:xml %}
&lt;beans xmlns=&ldquo;<a href="http://www.springframework.org/schema/beans">http://www.springframework.org/schema/beans</a>&rdquo;
   xmlns:s=&ldquo;<a href="http://www.springframework.org/schema/security">http://www.springframework.org/schema/security</a>&rdquo; xmlns:context=&ldquo;<a href="http://www.springframework.org/schema/context">http://www.springframework.org/schema/context</a>&rdquo;
   xmlns:xsi=&ldquo;<a href="http://www.w3.org/2001/XMLSchema-instance">http://www.w3.org/2001/XMLSchema-instance</a>&rdquo;
   xsi:schemaLocation=&ldquo;<a href="http://www.springframework.org/schema/beans">http://www.springframework.org/schema/beans</a> <a href="http://www.springframework.org/schema/beans/spring-beans-4.0.xsd">http://www.springframework.org/schema/beans/spring-beans-4.0.xsd</a></p>

<pre><code>   http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd
http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security-3.2.xsd"&gt;
</code></pre>

<p>   &lt;context:property-placeholder location=&ldquo;classpath:app.properties&rdquo; />  //1</p>

<p>   &lt;s:http pattern=&ldquo;/resources/**&rdquo; security=&ldquo;none&rdquo; />  //2
   &lt;s:http pattern=&ldquo;/login.html&rdquo; security=&ldquo;none&rdquo; />    //2</p>

<p>   &lt;s:http use-expressions=&ldquo;true&rdquo;></p>

<pre><code>  &lt;s:intercept-url pattern="/**" access="isAuthenticated()" /&gt;  //3
  &lt;s:form-login login-page="/login.html"                        //4
     authentication-failure-url="/login.html?error=true"        //5   
     username-parameter="j_username" password-parameter="j_password"/&gt; //6
  &lt;s:anonymous /&gt;
  &lt;s:logout logout-success-url="/login.html?logout=true" /&gt;  //7
</code></pre>

<p>   &lt;/s:http></p>

<p>   &lt;s:ldap-server url=&ldquo;${ldap_server}&rdquo; manager-dn=&ldquo;${ldap_user}&rdquo;//8</p>

<pre><code>  manager-password="${ldap_password}" /&gt;
</code></pre>

<p>   &lt;s:authentication-manager></p>

<pre><code>  &lt;s:ldap-authentication-provider
     user-dn-pattern="${ldap_user_dn_pattern}" /&gt;  //9
</code></pre>

<p>   &lt;/s:authentication-manager></p>

<p></beans>
{% endcodeblock %}</p>

<ol>
<li>指定properties文件，下面的ldap信息都是从properties文件里面取得。</li>
<li>配置哪些资源和url不需要做认证，比如一些图片，js和css文件等，还有我们的login页面，如果把login页面也拦截的话，就做不了认证了。</li>
<li>指定其他url(<code>/**</code>)都需要做认证，isAuthenticated方法表示认证通过了才能访问该url。</li>
<li>指定登陆页面的地址，这里是相对路径，如果不指定login-page，认证时会自动调用spring-security的一个默认登陆页面。</li>
<li>指定认证失败后的url，这里我们使用同一个login页面，只是在url后面加上查询参数作为认证失败的标示。</li>
<li>指定login页面2个作用域，用户名和密码，需要和页面录入框的name相同。</li>
<li>指定登出/注销成功后的页面，这里我们还是使用login页面，在url后面加上logout参数作为标示。</li>
<li>ldap服务器的配置信息，包括url, manager-dn和manager-password。</li>
<li>配置ldap的user-dn-pattern。</li>
</ol>


<p>下面是app.properties的内容。</p>

<p>{% codeblock app.properties lang:properties %}</p>

<h1>Ldap</h1>

<p>ldap_server=ldap://your.ldap.server.com.:12356
ldap_user=cn=yourname,cn=Users,dc=ldap,dc=server,dc=com
ldap_password=123456
ldap_user_dn_pattern=uid={0},ou=staff,ou=people,o=ldap.server.com
{% endcodeblock %}</p>

<h2>创建登陆页面</h2>

<p>创建用户登陆的Form，method为<code>post</code>，action为<code>j_spring_security_check</code>，用户录入框的name为<code>j_username</code>，密码录入框的name为<code>j_password</code>，这2个值与之前spring-security.xml里面配置的要保持一致。</p>

<p>{% codeblock login.html lang:html %}
<form name="LoginForm" method="post" action="j_spring_security_check"></p>

<pre><code>&lt;div style="display: block;"&gt;
    &lt;div&gt;
        &lt;h1&gt;
            &lt;span class="ui-icon add"&gt;&lt;/span&gt;用户登录
        &lt;/h1&gt;
    &lt;/div&gt;
    &lt;div class="content"&gt;
        &lt;div id="error" style="display: none; color: #c9302c" align="center"&gt;
            &lt;h3&gt;认证失败，请重新登录&lt;/h3&gt;
        &lt;/div&gt;
        &lt;div id="logout" style="display: none; color: #02547f" align="center"&gt;
            &lt;h3&gt;已成功登出&lt;/h3&gt;
        &lt;/div&gt;

        &lt;ul&gt;
            &lt;li&gt;&lt;label&gt;
                &lt;span&gt;用户名&lt;/span&gt;
                &lt;input type="text" name="j_username"&gt;
            &lt;/label&gt;&lt;/li&gt;
            &lt;li&gt;&lt;label&gt;
                &lt;span&gt;密码&lt;/span&gt;
                &lt;input type="password" name="j_password"&gt;
            &lt;/label&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
    &lt;div&gt;
        &lt;button type="submit" name="logon" value="Logon"&gt;登录&lt;/button&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>

<p></form>
{% endcodeblock %}</p>

<p>相关的js代码如下:
{% codeblock lang:js %}
function getParameterByName(name) {</p>

<pre><code>name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
var regex = new RegExp("[\\?&amp;]" + name + "=([^&amp;#]*)"),
    results = regex.exec(location.search);
return results === null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
</code></pre>

<p>}</p>

<p>if(getParameterByName(&ldquo;error&rdquo;)) {</p>

<pre><code>$("#error").show();
</code></pre>

<p>}</p>

<p>if(getParameterByName(&ldquo;logout&rdquo;)) {</p>

<pre><code>$("#logout").show();
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>如果需要的话，可以配置自己的logout页面，只需要一个Form就可以了，方法为<code>post</code>，action为<code>j_spring_security_logout</code>，只要提交了这个Form就可以成功登出了。</p>

<p>{% codeblock logout.html lang:html %}
<form action="j_spring_security_logout" method="post" id="logoutForm"></form>
{% endcodeblock %}</p>

<p>更多Spring Security的信息请查阅: <a href="http://docs.spring.io/spring-security/site/docs/3.2.x/reference/htmlsingle/">Spring Security Reference</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何在Spring4中配置Mybatis]]></title>
    <link href="http://zhaozhiming.github.io/blog/2014/11/15/spring4-and-mybatis/"/>
    <updated>2014-11-15T21:09:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2014/11/15/spring4-and-mybatis</id>
    <content type="html"><![CDATA[<p>{% img /images/post/2014-11/mybatis-spring.png %}</p>

<p><a href="http://spring.io/">Spring4</a>已经不支持Ibatis了，但Ibatis的升级版<a href="http://mybatis.github.io/mybatis-3/zh/index.html">Mybatis</a>封装了支持Spring4的组件<a href="http://mybatis.github.io/spring/zh/">mybatis-spring</a>，通过使用它们可以让你在Spring4中轻松地使用Mybatis。</p>

<!--more-->


<h2>gradle 设置</h2>

<p>现在基本上新兴的java项目包括android都使用<a href="http://www.gradle.org/">gradle</a>来做构建工具，gradle相比<a href="http://ant.apache.org/">ant</a>来讲多了定义好的task，不需要每次都copy-paste相同的task到构建文件中，而相比<a href="http://maven.apache.org/">maven</a>来说gradle比较灵活，可以像ant那样写简单的命令来进行copy或者mv等操作，总的来讲，gradle是集ant和maven优点于一身的新时代的构建工具。</p>

<p>要在工程中引入Mybatis的组件，需要现在gradle的构建文件中增加Mybatis的依赖包。</p>

<p>{% codeblock build.gradle lang:groovy %}
dependencies {</p>

<pre><code>compile 'org.mybatis:mybatis:3.2.8'
compile 'org.mybatis:mybatis-spring:1.2.2'
</code></pre>

<p>}
{% endcodeblock %}</p>

<h2>在spring中配置Mybatis</h2>

<p>引入依赖包之后，需要在spring的配置文件中进行Mybatis的配置。</p>

<ul>
<li>首先我们定义一个datasource，使用C3PO数据库连接池来进行管理。</li>
</ul>


<p>{% codeblock spring.xml lang:xml %}</p>

<pre><code>&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource " destroy-method="close"&gt;
    &lt;property name="driverClass" value="com.mysql.jdbc.Driver"/&gt;
    &lt;property name="jdbcUrl" value="jdbc:mysql://192.168.36.10:3306/pebms"/&gt;
    &lt;property name="user" value="root"/&gt;
    &lt;property name="password" value="root"/&gt;
    &lt;property name="acquireIncrement" value="1"/&gt;
    &lt;property name="initialPoolSize" value="5"/&gt;
    &lt;property name="maxPoolSize" value="20"/&gt;
    &lt;property name="minPoolSize" value="5"/&gt;
    &lt;property name="maxStatements" value="100"/&gt;
    &lt;property name="testConnectionOnCheckout" value="true"/&gt;
&lt;/bean&gt;
</code></pre>

<p>{% endcodeblock %}</p>

<ul>
<li>接着定义Mybatis的SessionFactory。

<ul>
<li>dataSource: 我们之前定义的数据源</li>
<li>transactionFactory: 事务管理配置</li>
<li>configLocation: Mybatis的具体文件地址</li>
<li>mapperLocations: Mybatis的SQL映射文件</li>
</ul>
</li>
</ul>


<p>{% codeblock spring.xml lang:xml %}</p>

<pre><code>&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt;
    &lt;property name="dataSource" ref="dataSource" /&gt;
    &lt;property name="transactionFactory"&gt;
        &lt;bean class="org.apache.ibatis.transaction.managed.ManagedTransactionFactory" /&gt;
    &lt;/property&gt;
    &lt;property name="configLocation" value="classpath:sql-map-config.xml"/&gt;
    &lt;property name="mapperLocations" value="classpath:sql-mapping/farmer.xml" /&gt;
&lt;/bean&gt;
</code></pre>

<p>{% endcodeblock %}</p>

<ul>
<li>sql-map-config.xml简单示例如下，设置了缓存，延迟加载，超时时间等属性，更多的配置可以参照<a href="http://mybatis.github.io/mybatis-3/zh/configuration.html#setting">这里</a>。</li>
</ul>


<p>{% codeblock sql-map-config.xml lang:xml %}
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?>
&lt;!DOCTYPE configuration PUBLIC &ldquo;&ndash;//mybatis.org//DTD Config 3.0//EN&rdquo; &ldquo;<a href="http://mybatis.org/dtd/mybatis-3-config.dtd">http://mybatis.org/dtd/mybatis-3-config.dtd</a>&rdquo;>
<configuration></p>

<pre><code>&lt;settings&gt;
    &lt;setting name="cacheEnabled" value="true" /&gt;
    &lt;setting name="lazyLoadingEnabled" value="true" /&gt;
    &lt;setting name="multipleResultSetsEnabled" value="true" /&gt;
    &lt;setting name="useColumnLabel" value="true" /&gt;
    &lt;setting name="defaultExecutorType" value="REUSE" /&gt;
    &lt;setting name="defaultStatementTimeout" value="25000" /&gt;
&lt;/settings&gt;
</code></pre>

<p></configuration>
{% endcodeblock %}</p>

<ul>
<li>sql的映射文件简单示例如下。</li>
</ul>


<p>{% codeblock farmer.xml lang:xml %}
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo; ?>
&lt;!DOCTYPE mapper PUBLIC &ldquo;&ndash;//mybatis.org//DTD Mapper 3.0//EN&rdquo; &ldquo;<a href="http://mybatis.org/dtd/mybatis-3-mapper.dtd">http://mybatis.org/dtd/mybatis-3-mapper.dtd</a>&rdquo; >
<mapper namespace="com.farmer.baton.repo.FarmerMapper"></p>

<pre><code>&lt;insert id="add-new-farmer" parameterType="com.farmer.baton.model.Farmer"&gt;
  insert into farmers(id, name, age) values (
    #{id},
    #{name},
    #{age}
  )
&lt;/insert&gt;
</code></pre>

<p></mapper>
{% endcodeblock %}</p>

<ul>
<li>继续在spring.xml文件里进行Mybatis的配置，定义Mybatis的DAO(数据库访问对象)和事务控制，这里配置了DAO的包路径。</li>
</ul>


<p>{% codeblock spring.xml lang:xml %}</p>

<pre><code>&lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt;
    &lt;property name="basePackage" value="com.farmer.baton.repo" /&gt;
    &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" /&gt;
&lt;/bean&gt;

&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
    &lt;property name="dataSource" ref="dataSource" /&gt;
&lt;/bean&gt;
</code></pre>

<p>{% endcodeblock %}</p>

<h2>Mybatis responsitory编写</h2>

<p>在前面的spring里面配置了DAO的包路径，我们下面要做的东西就比较就简单了。</p>

<ul>
<li>先在DAO包路径下定义一个DAO接口，这里不需要实现具体的内容，具体的sql在我们的映射文件里面体现。</li>
</ul>


<p>{% codeblock FarmerRepository.java lang:java %}
package com.farmer.baton.repo;</p>

<p>import com.farmer.baton.model.Farmer;</p>

<p>import java.util.List;</p>

<p>public interface FarmerRepository {</p>

<pre><code>List&lt;Farmer&gt; findAll();
</code></pre>

<p>}</p>

<p>{% endcodeblock %}</p>

<ul>
<li>在xml映射文件里面实现findAll方法，这里要注意方法的签名必须和映射文件的sql的id一致，包括方法名和id一致，方法参数类型和sql的parameterType一致，方法返回类型和sql的resultType或resultMap类型一致。</li>
</ul>


<p>{% codeblock farmer.xml lang:xml %}
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo; ?>
&lt;!DOCTYPE mapper PUBLIC &ldquo;&ndash;//mybatis.org//DTD Mapper 3.0//EN&rdquo; &ldquo;<a href="http://mybatis.org/dtd/mybatis-3-mapper.dtd">http://mybatis.org/dtd/mybatis-3-mapper.dtd</a>&rdquo; >
<mapper namespace="com.farmer.baton.repo.FarmerRepository"></p>

<pre><code>&lt;resultMap id="baseResultMap" type="com.farmer.baton.model.Farmer"&gt;
    &lt;id column="id" property="id"/&gt;
    &lt;result column="name" property="name"/&gt;
    &lt;result column="age" property="age"/&gt;
&lt;/resultMap&gt;

&lt;select id="findAll" resultMap="baseResultMap"&gt;
    select id as id,
    name as name,
    age as age
    from farmers
&lt;/select&gt;
</code></pre>

<p></mapper>
{% endcodeblock %}</p>

<ul>
<li>写好Repository和映射SQL就可以了，程序在调用Repository方法的时候就会自动执行到相关的SQL。</li>
</ul>


<h2>事务控制</h2>

<ul>
<li>Mybatis的事务控制使用Spring的事务配置即可，配置如下:</li>
</ul>


<p>{% codeblock spring.xml lang:xml %}
&lt;beans xmlns:tx=&ldquo;<a href="http://www.springframework.org/schema/tx">http://www.springframework.org/schema/tx</a>&rdquo;</p>

<pre><code>    http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd"&gt;
...
&lt;tx:annotation-driven/&gt;
...
</code></pre>

<p>{% endcodeblock %}</p>

<ul>
<li>然后在调用Repository的方面前面加上Transactional标签，如下所示:</li>
</ul>


<p>{% codeblock FarmerService.java lang:java %}
@Service
public class FarmerService {</p>

<pre><code>@Autowired
private FarmerRepository farmerRepository;

@Transactional
public void updateTwoFarmers(Farmer farmer1, Farmer farmer2) {
    farmerRepository.updateZhangsan(farmer1);
    farmerRepository.updateWangwu(farmer2);
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<h2>Mybatis语法</h2>

<p>Mybatis的语法在功能上有了很大的改进，具体体现在SQL映射文件中。</p>

<ul>
<li>批量插入多条记录。</li>
</ul>


<p>{% codeblock lang:xml %}</p>

<pre><code>&lt;insert id="add-new-farmer" parameterType="com.farmer.baton.model.Farmer"&gt;
  insert into farmers(id, name, age) values 
  &lt;foreach collection="farmers" item="farmer" separator=","&gt;    
  (
    #{id},
    #{name},
    #{age}
  )
  &lt;/foreach&gt;
&lt;/insert&gt;
</code></pre>

<p>{% endcodeblock %}</p>

<p>{% codeblock FarmerRepository lang:java %}</p>

<pre><code>void addFarmers(@Param("farmers") List&lt;Farmer&gt; farmers);
</code></pre>

<p>{% endcodeblock %}</p>

<ul>
<li>多参数SQL映射</li>
</ul>


<p>{% codeblock lang:xml %}</p>

<pre><code>&lt;resultMap id="farmer" type="com.farmer.baton.model.Farmer"&gt;
    &lt;id column="id" property="id"/&gt;
    &lt;result column="name" property="name"/&gt;
    &lt;result column="age" property="age"/&gt;
&lt;/resultMap&gt;

&lt;select id="selectFarmersByNameAndAge" parameterType="map" resultMap="farmer"&gt;
  select id as id,
    name as name,
    age as age
    from farmers
    where name = #{name}
    and age = #{age}
&lt;/select&gt;
</code></pre>

<p>{% endcodeblock %}</p>

<p>{% codeblock FarmerRepository.java lang:java %}</p>

<pre><code>List&lt;Farmer&gt; selectFarmersByNameAndAge(@Param("name") String name, @Param("age") int age);
</code></pre>

<p>{% endcodeblock %}</p>

<ul>
<li>返回对象属性包含List</li>
</ul>


<p>{% codeblock lang:xml %}</p>

<pre><code>&lt;resultMap id="farmer" type="com.farmer.baton.model.Farmer"&gt;
    &lt;id column="id" property="id"/&gt;
    &lt;result column="name" property="name"/&gt;
    &lt;result column="age" property="age"/&gt;
    &lt;collection property="farmland" ofType="com.farmer.baton.model.Farmland"&gt;
        &lt;result column="size" property="size"/&gt;
    &lt;/collection&gt;
&lt;/resultMap&gt;

&lt;select id="selectFarmersAndFarmlands" resultMap="farmer"&gt;
  select id as id,
    name as name,
    age as age
    from farmers a 
    left outer join farmerlands b on a.id = b.farmer_id
&lt;/select&gt;
</code></pre>

<p>{% endcodeblock %}</p>

<p>{% codeblock FarmerRepository.java lang:java %}</p>

<pre><code>List&lt;Farmer&gt; selectFarmersAndFarmlands();
</code></pre>

<p>{% endcodeblock %}</p>

<p>{% codeblock Farmer.java lang:java %}</p>

<pre><code>private String name;
private int age;
private List&lt;Farmland&gt; farmlands;
</code></pre>

<p>{% endcodeblock %}</p>

<p>具体的Demo可以参考我的github工程<a href="https://github.com/zhaozhiming/spring4-mybatis">spring4-mybatis</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Robot Framework结合Spring进行uat测试]]></title>
    <link href="http://zhaozhiming.github.io/blog/2014/06/19/robot-framework-uat-test-with-spring/"/>
    <updated>2014-06-19T21:50:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2014/06/19/robot-framework-uat-test-with-spring</id>
    <content type="html"><![CDATA[<p>在做项目过程中，单元测试是大家经常接触的也是了解的比较多的，但单元测试有时候为了更快的运行，会mock掉数据库或者关联系统来执行测试，这样的话整体的功能就得不到验证，另外单元测试也无法进行页面比如html的测试，这个时候就需要进行UAT自动化测试了。</p>

<!--more-->


<p></p>

<p><a href="http://baike.baidu.com/view/1330235.htm?fromTaglist">UAT</a>，(User Acceptance Test),用户接受度测试，即验收测试，这种一般是手工测试，当然重复进行手动测试是一种选择，但如果手工测试很多的话每次执行就比较浪费时间和精力，而且也容易遗漏和出错，所以我们需要将手工测试进行自动化。</p>

<h2><a href="http://robotframework.org/">Robot Framework</a></h2>

<p>Robot是一个自动化测试框架，其可以使用的Lib很多，简单地安装即可使用，也可以自己通过Python和Java来开发自己需要的Lib包，不过现在robot的Lib已经比较多了，可以满足大部分的使用场景。</p>

<h4>安装</h4>

<p>Robot安装十分简单，但首先要安装Python环境（Python安装这里不介绍了，请自行google了解），然后执行以下语句进行安装。</p>

<p>{% codeblock lang:sh %}
sudo pip install robotframework
{% endcodeblock %}</p>

<p>安装完成后验证是否安装成功。</p>

<p>{% codeblock lang:sh %}
pybot &mdash;version
Robot Framework 2.8.5 (Python 2.7.3 on linux2)
{% endcodeblock %}</p>

<p>如果需要安装其他Lib包，同样是通过pip进行安装，下面以安装Selenium2Library为例。</p>

<p>{% codeblock lang:sh %}
sudo pip install robotframework_Selenium2Library
{% endcodeblock %}</p>

<h4>Robot脚本</h4>

<p>Robot安装完成后，就可以开始编写测试脚本了，下面是测试脚本和Resource文件的例子:</p>

<p>{% codeblock lang:robotframework create_recipient.robot%}
<strong><em> Settings </em></strong>
Library    Selenium2Library
Library    DatabaseLibrary
Resource   resource.robot
Test Setup      Open Browser  ${baseurl}/#/recipients  ${browser}
Test Teardown   Close Browser</p>

<p><strong><em> TestCases </em></strong>
create new recipient</p>

<pre><code>Given execute sql  delete from recipients where email='zhaozhiming003@gmail.com'
When create recipient
Then verify create recipient  添加用户成功
</code></pre>

<p>create exist recipient</p>

<pre><code>Given execute sql  delete from recipients where email='zhaozhiming003@gmail.com'
Given execute sql  insert into recipients(username,email) values('zhaozhiming','zhaozhiming003@gmail.com')
When create recipient
Then verify create recipient  添加用户失败
</code></pre>

<p><strong><em> Keywords </em></strong>
execute sql</p>

<pre><code>[Arguments]  ${sql}
Connect To Database Using Custom Params      cymysql    db='${dbname}',user='${dbuser}',passwd='${dbpassword}', host='${dbhost}',port=${dbport}
Execute Sql String    ${sql}
Disconnect from database
</code></pre>

<p>create recipient</p>

<pre><code>Input text    username    zhaozhiming
Input text    email    zhaozhiming003@gmail.com
click element  css=.submit
</code></pre>

<p>verify create recipient</p>

<pre><code>[Arguments]  ${expectContent}
sleep   2s
page should contain  ${expectContent}
</code></pre>

<p>{% endcodeblock %}</p>

<p>{% codeblock lang:robotframework resource.robot%}
<strong><em> Variables </em></strong>
${baseurl}  <a href="http://localhost:9898/oddemail">http://localhost:9898/oddemail</a>
${dbhost}  localhost
${dbport}  3306
${dbname}  oms
${dbuser}  root
${dbpassword}  root
${browser}  chrome
{% endcodeblock %}</p>

<ul>
<li><p>Settings下面是测试脚本需要引用的Lib包名，Resource文件，Setup和Teardown方法。</p>

<ul>
<li>Resource文件可以用来存放一些可以复用的变量，当然也可以将这一部分放到测试脚本中。</li>
<li>Setup和Teardow跟单元测试一样，是在跑每个Test Case之前和之后会做的事情。注意上面例子里面打开url指定了浏览器Chrome，如果不指定浏览器的话会默认用Firefox打开，如果想使用Chrome来进行web自动化测试的话，则需要下载Chrome驱动<a href="https://code.google.com/p/selenium/wiki/ChromeDriver">chromedriver</a>，下载完后将其解压并设置到PATH路径。</li>
</ul>
</li>
<li><p>TestCases设置了脚本里的测试案例，每个测试案例可以由Given，When，Then组成，每一行除开这几个关键字就是测试案例的步骤，在robot里面叫关键字，关键字可以带参数，可以把关键字理解为程序里面的方法。</p></li>
<li><p>Keywords就是在Test Case里面定义的关键字了，里面有是每个关键字具体的执行内容。</p>

<ul>
<li><code>execute sql</code>这个关键字的内容是连接数据库，执行sql，关闭数据库连接。</li>
<li><code>create recipient</code>这个关键字的内容是在页面输入用户名，输入邮箱地址，点击提交按钮。注意这里的页面元素是通过class来查找的，也可以通过id，tag或其他。</li>
<li><code>verify create recipient</code>这个关键字的内容是等待2秒，验证页面是否包含期望的内容。</li>
</ul>
</li>
</ul>


<p>可以看到Keyword的每个内容描述都很简单易懂，甚至还可以写中文，让不懂开发的人也知道你的测试案例是做什么的。</p>

<h4>执行脚本</h4>

<p>因为这个测试案例是对web页面进行测试，所以在执行测试案例之前需要先将应用服务启起来，服务启起来后，执行下面的 语句:</p>

<p>{% codeblock lang:sh%}
pybot /your/robot/scripts/path/create_recipient.robot
{% endcodeblock %}</p>

<p>执行完后会看到系统自动打开浏览器，输入url，自动填写输入框，并验证是否正确，最后会产生几个报告文件，如果测试案例失败，还会自动将失败的页面截图存成文件。</p>

<p>{% codeblock lang:sh%}
Output:  /home/kingzzm/projects/odde-mail-server/output.xml
Log:     /home/kingzzm/projects/odde-mail-server/log.html
Report:  /home/kingzzm/projects/odde-mail-server/report.html
{% endcodeblock %}</p>

<p>另外建议脚本存放到test目录下，建议目录结构如下:</p>

<p>{% img /images/post/2014-6/robot_script_local.png %}</p>

<h4>与Gradle集成</h4>

<p>每次跑robot测试都需要手动启一个web服务比较麻烦，可以考虑在Gradle中通过任务的方式来执行robot测试，在跑测试之前先通过gradle启一个本地应用，然后开始跑robot测试，跑完测试后通过Gradle停掉本地服务。<br/>
因为Gradle自带jetty容器，所以这一步实现起来也比较简单:</p>

<p>{% codeblock lang:groovy %}
[jettyRun, jettyStop]<em>.stopPort = 7654
[jettyRun, jettyStop]</em>.stopKey = &lsquo;oddemail&rsquo;</p>

<p>task uat(type:Exec, dependsOn: jettyRun) {</p>

<pre><code>commandLine '/usr/local/bin/pybot', 'src/test/uat/testcase'
doLast {
    jettyStop.execute()
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>以后需要跑uat测试就执行<code>gradle uat</code>这个命令就可以了，这样还可以结合jenkins进行uat自动化测试。</p>
]]></content>
  </entry>
  
</feed>
