<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: redis | Hacker and Geeker's Way]]></title>
  <link href="http://zhaozhiming.github.io/tags/redis/atom.xml" rel="self"/>
  <link href="http://zhaozhiming.github.io/"/>
  <updated>2017-01-17T22:18:15+08:00</updated>
  <id>http://zhaozhiming.github.io/</id>
  <author>
    <name><![CDATA[赵芝明]]></name>
    <email><![CDATA[kingzzm1982@sina.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用Spring-data进行Redis操作]]></title>
    <link href="http://zhaozhiming.github.io/blog/2015/04/12/spring-data-redis/"/>
    <updated>2015-04-12T15:15:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2015/04/12/spring-data-redis</id>
    <content type="html"><![CDATA[<p>{% img /images/post/2015-4/spring-redis.jpg %}</p>

<p><a href="http://redis.io/">Redis</a>相信大家都听说过，它是一个开源的key-value缓存数据库，有很多Java的客户端支持，比较有名的有Jedis，JRedis等（见<a href="http://redis.io/clients#java">这里</a>）。当然我们可以使用客户端的原生代码实现redis的操作，但实际上在spring中就已经集成了这些客户端的使用，下面我们就以Jedis为例来介绍一下Spring中关于Redis的配置。</p>

<!--more-->


<p></p>

<h2>下载相关依赖包</h2>

<p>首先要下载spring和redis相关的依赖包，最新的jedis版本是2.6.2，还需要下载jackson的包，这个后面会介绍为什么需要，以gradle脚本示例如下。</p>

<p>{% codeblock build.gradle lang:sh %}</p>

<pre><code>compile("redis.clients:jedis:" + jedisVersion)
compile "org.springframework.data:spring-data-redis:" + springDataRedisVersion

//json
compile "com.fasterxml.jackson.core:jackson-databind:" + jacksonDatabindVersion
compile "org.codehaus.jackson:jackson-mapper-asl:" + jacksonVersion
compile "org.codehaus.jackson:jackson-core-asl:" + jacksonVersion
</code></pre>

<p>{% endcodeblock %}</p>

<h2>spring配置jedis</h2>

<p>在spring的xml配置文件中，做如下配置。</p>

<p>{% codeblock lang:xml %}</p>

<pre><code>&lt;!-- 配置redis池，依次为最大实例数，最大空闲实例数，(创建实例时)最大等待时间，(创建实例时)是否验证 --&gt;
&lt;bean id="jedisPoolConfig" class="redis.clients.jedis.JedisPoolConfig"&gt;
    &lt;property name="maxTotal" value="${redis.maxTotal}"/&gt;
    &lt;property name="maxIdle" value="${redis.maxIdle}"/&gt;
    &lt;property name="maxWaitMillis" value="${redis.maxWaitMillis}"/&gt;
    &lt;property name="testOnBorrow" value="${redis.testOnBorrow}"/&gt;
&lt;/bean&gt;

&lt;!-- redis连接配置，依次为主机ip，端口，是否使用池，(usePool=true时)redis的池配置 --&gt;
&lt;bean id="jedisFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory"&gt;
    &lt;property name="hostName" value="${redis.host}"/&gt;
    &lt;property name="port" value="${redis.port}"/&gt;
    &lt;property name="usePool" value="true"/&gt;
    &lt;property name="poolConfig" ref="jedisPoolConfig"/&gt;
&lt;/bean&gt;

&lt;!-- redis模板配置 --&gt;
&lt;bean id="redisTemplate" class="org.springframework.data.redis.core.RedisTemplate"&gt;
    &lt;property name="connectionFactory" ref="jedisFactory"/&gt;
    &lt;property name="defaultSerializer"&gt;
        &lt;bean class="org.springframework.data.redis.serializer.StringRedisSerializer"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>

<p>{% endcodeblock %}</p>

<h2>序列化</h2>

<p>在spring中进行redis存储，如果没有对key和value进行序列化，保存到redis中会出现乱码。注意看上面的redis模板配置，有个配置项是defaultSerializer，这里表示redis中的key和value遇到需要序列化的时候，都默认使用StringRedisSerializer这个类来进行序列化。如果不指定序列化的话，内容会带乱码。</p>

<p>spring-data-redis的序列化类有下面这几个:</p>

<ul>
<li>GenericToStringSerializer: 可以将任何对象泛化为字符串并序列化</li>
<li>Jackson2JsonRedisSerializer: 跟JacksonJsonRedisSerializer实际上是一样的</li>
<li>JacksonJsonRedisSerializer: 序列化object对象为json字符串</li>
<li>JdkSerializationRedisSerializer: 序列化java对象</li>
<li>StringRedisSerializer: 简单的字符串序列化</li>
</ul>


<p>一般如果key-value都是string的话，使用StringRedisSerializer就可以了，如果需要保存对象为json的话推荐使用JacksonJsonRedisSerializer，它不仅可以将对象序列化，还可以将对象转换为json字符串并保存到redis中，但需要和jackson配合一起使用。</p>

<h2>简单的redis操作</h2>

<p>代码示例如下，使用redis进行set和get操作。</p>

<p>{% codeblock MyUserRepository.java lang:java %}
@Repository
public class MyUserRepository {</p>

<pre><code>//直接使用autowire就可以引用到配置文件中的redis-template
@Autowired
private RedisTemplate&lt;String, MyUser&gt; template;

private ValueOperations&lt;String, MyUser&gt; operations;

@PostConstruct
public void init() {
    //这里设置value的序列化方式为JacksonJsonRedisSerializer  
    template.setValueSerializer(new JacksonJsonRedisSerializer&lt;&gt;(MyUser.class));
    operations = template.opsForValue();
}

public void set(String key, MyUser value) {
    operations.set(key, value);
}

public MyUser get(String key) {
    return operations.get(key);
}
</code></pre>

<p>}</p>

<p>// model
public class MyUser {</p>

<pre><code>private String username;
private int age;
// ... setter and getter
</code></pre>

<p>}</p>

<p>// 在Controller中调用
@Controller
public class MainController {</p>

<pre><code>@Autowired
private MyUserRepository myUserRepository;

@RequestMapping(value = "/test", method = RequestMethod.GET)
public
@ResponseBody
ResponseEntity&lt;?&gt; test() throws Exception {
    MyUser user = new MyUser("zhaozhiming", 100);
    String key = "my:user:zhaozhiming";
    myUserRepository.set(key, user);
    MyUser myUser = myUserRepository.get(key);
    log.debug(String.format("my user:%s", myUser));
    String result = mapper.writeValueAsString(user);
    return new ResponseEntity&lt;&gt;(result, HttpStatus.OK);
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>调用set方法后，可以在日志中看到get后的MyUser对象。</p>

<p>{% codeblock lang:sh %}
 &ndash; my user:MyUser{age=100, username=&lsquo;zhaozhiming&rsquo;}
{% endcodeblock %}</p>

<p>也可以在redis里面看到保存后的json字符串了。</p>

<p>{% img /images/post/2015-4/redis_result.png %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis集群环境安装指南]]></title>
    <link href="http://zhaozhiming.github.io/blog/2014/05/11/redis-cluster-env-create/"/>
    <updated>2014-05-11T20:50:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2014/05/11/redis-cluster-env-create</id>
    <content type="html"><![CDATA[<p>{% img /images/post/2014-5/redis-cluster.jpg %}</p>

<h3>环境</h3>

<p>RHLinux-6.4-64-EN, 红帽6.4 64位，英文正式发布版。</p>

<!--more-->


<p></p>

<h3>Redis3.0.0</h3>

<ul>
<li>redis2.x版本还不支持集群，3.0版本将会支持，现在3.0版本还在开发中，现在是beta-3版本(截止2014-5-8)，但功能是可用的。</li>
<li>下载Redis3.0.0 beta-3版本，点击<a href="https://github.com/antirez/redis/archive/3.0.0-beta3.tar.gz">这里</a>下载。</li>
<li>Redis3的安装可以参照之前的<a href="http://10.42.173.13/zhaozhiming003/redis-poc/blob/master/doc/redis_install.md">单机安装指南</a>操作。</li>
</ul>


<h3>创建Redis集群实例</h3>

<ul>
<li>创建集群节点的文件夹，先创建cluster-test文件夹，再以端口为名称创建子文件夹。这里我们要创建6个Redis实例，3个作为master，3个作为slave。</li>
</ul>


<p>{% codeblock lang:bash %}
mkdir cluster-test
cd cluster-test
mkdir 7000 7001 7002 7003 7004 7005
{% endcodeblock %}</p>

<ul>
<li>在每个文件夹下面创建创建Redis配置文件，注意根据不同实例的端口号修改下面的配置文件，nodes.conf文件为Redis实例启动时自动生成。</li>
</ul>


<p>{% codeblock lang:bash %}
port 7000
cluster-enabled yes
cluster-config-file nodes.conf
cluster-node-timeout 5000
appendonly yes
{% endcodeblock %}</p>

<ul>
<li>开6个terminal窗口，分别启动这6个Redis实例。</li>
</ul>


<p>{% codeblock lang:bash %}
cd 7000
../redis-server ./redis.conf
{% endcodeblock %}</p>

<ul>
<li>当成功启动后，能看到每个terminal出现下面的字样，是因为node.conf文件不存在，所以给每个实例分配了一个新的ID。</li>
</ul>


<p>{% codeblock lang:bash %}
[82462] 26 Nov 11:56:55.329 * No cluster configuration found, I&rsquo;m 97a3a64667477371c4479320d683e4c8db5858b1
{% endcodeblock %}</p>

<h3>创建集群</h3>

<ul>
<li>现在Redis的6个实例都已经启动了，现在来开始创建集群。创建集群用到了一个ruby文件，放在redis3目录的src子目录下，找到后执行以下命令。这里的<code>-replicas 1</code>表示每个master配备1个slave，后面的参数就是6个实例的ip加端口，以空格隔开。</li>
</ul>


<p>{% codeblock lang:bash %}
cd redis-3.0.0-beta3/src
./redis-trib.rb create &mdash;replicas 1 127.0.0.1:7000 127.0.0.1:7001 \
127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005
{% endcodeblock %}</p>

<ul>
<li>执行命令后会提示你是否接受提示的配置信息，默认的是前3台作为master机器，后3台作为slave机器，输入<code>yes</code>，出现最后的信息表示集群已经创建好了。</li>
</ul>


<p>{% codeblock lang:bash %}
Creating cluster
Connecting to node 127.0.0.1:7000: OK
Connecting to node 127.0.0.1:7001: OK
Connecting to node 127.0.0.1:7002: OK
Connecting to node 127.0.0.1:7003: OK
Connecting to node 127.0.0.1:7004: OK
Connecting to node 127.0.0.1:7005: OK >>>
Performing hash slots allocation on 6 nodes&hellip;
Using 3 masters: 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002
127.0.0.1:7000 replica #1 is 127.0.0.1:7003
127.0.0.1:7001 replica #1 is 127.0.0.1:7004
127.0.0.1:7002 replica #1 is 127.0.0.1:7005
M: 9991306f0e50640a5684f1958fd754b38fa034c9 127.0.0.1:7000 slots:0-5460 (5461 slots) master
M: e68e52cee0550f558b03b342f2f0354d2b8a083b 127.0.0.1:7001 slots:5461-10921 (5461 slots) master
M: 393c6df5eb4b4cec323f0e4ca961c8b256e3460a 127.0.0.1:7002 slots:10922-16383 (5462 slots) master
S: 48b728dbcedff6bf056231eb44990b7d1c35c3e0 127.0.0.1:7003
S: 345ede084ac784a5c030a0387f8aaa9edfc59af3 127.0.0.1:7004
S: 3375be2ccc321932e8853234ffa87ee9fde973ff 127.0.0.1:7005
Can I set the above configuration? (type &lsquo;yes&rsquo; to accept): yes</p>

<p>Nodes configuration updated >>>
Sending CLUSTER MEET messages to join the cluster Waiting for the cluster to join&hellip; >>>
Performing Cluster Check (using node 127.0.0.1:7000)
M: ebbb890e899244e4a2a6303826a29543ebf9885d 127.0.0.1:7000
   slots:0-5460 (5461 slots) master
M: ebbb890e899244e4a2a6303826a29543ebf9885d 127.0.0.1:7001
   slots:5461-10922 (5462 slots) master
M: 73c22198cd1d0782ec24e3c9b03378030891c9a3 127.0.0.1:7002
   slots:10923-16383 (5461 slots) master
M: c785d85b95d7bdc28ec90384ab8a5885b289542c 127.0.0.1:7003
   slots: (0 slots) master
   replicates b949ea2d9c822ff069521a354b4ed48855ac6203
M: 570c472fe553ba3c9d0fb3ba16fcdb8579b4fc86 127.0.0.1:7004
   slots: (0 slots) master
   replicates ebbb890e899244e4a2a6303826a29543ebf9885d
M: f86667ec42cff41a5666162a912713173f5306d7 127.0.0.1:7005
   slots: (0 slots) master
   replicates 73c22198cd1d0782ec24e3c9b03378030891c9a3
[OK] All nodes agree about slots configuration.</p>

<blockquote><blockquote><blockquote><p>Check for open slots&hellip;
Check slots coverage&hellip;
[OK] All 16384 slots covered.
{% endcodeblock %}</p></blockquote></blockquote></blockquote>

<p>PS: 安装过程还发现RedHat系统上没有安装ruby，需要先安装ruby，而且公司机器还不能上网下载安装，只能通过离线的方式安装ruby，这里有离线安装的文档可以参考一下:<a href="https://rvm.io/rvm/offline">https://rvm.io/rvm/offline</a>。</p>

<h3>验证</h3>

<p>可以使用Redis3.0的redis-cli客户端进行验证，需要加上<code>-c</code>参数，表示集群的意思。</p>

<p>{% codeblock lang:bash %}
$ redis-cli -c -p 7000
redis 127.0.0.1:7000> set foo bar
&ndash;> Redirected to slot [12182] located at 127.0.0.1:7002
OK
redis 127.0.0.1:7002> set hello world
&ndash;> Redirected to slot [866] located at 127.0.0.1:7000
OK
redis 127.0.0.1:7000> get foo
&ndash;> Redirected to slot [12182] located at 127.0.0.1:7002
&ldquo;bar&rdquo;
redis 127.0.0.1:7000> get hello
&ndash;> Redirected to slot [866] located at 127.0.0.1:7000
&ldquo;world&rdquo;
{% endcodeblock %}</p>

<p>更多的资料可以参考这里：<a href="http://redis.io/topics/cluster-tutorial">http://redis.io/topics/cluster-tutorial</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Red Hat系统安装Redis]]></title>
    <link href="http://zhaozhiming.github.io/blog/2014/05/07/redis-install-guide-in-redhat/"/>
    <updated>2014-05-07T19:53:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2014/05/07/redis-install-guide-in-redhat</id>
    <content type="html"><![CDATA[<p>{% img /images/post/2014-5/redis.jpg %}</p>

<!--more-->


<p></p>

<h2>环境</h2>

<p>RHLinux-6.4-64-EN, 红帽6.4 64位，英文正式发布版</p>

<h2>安装</h2>

<p>安装很简单，先下载redis的压缩包，下载地址见<a href="http://redis.io/download">这里</a>，然后拷贝到你的linux机器，接着执行下面的命令。</p>

<p>{% codeblock lang:bash %}
$ tar xzf redis-2.6.14.tar.gz
$ cd redis-2.6.14
$ make
{% endcodeblock %}</p>

<h2>启动</h2>

<p>编译完后增加了src目录，执行src下面的redis-server脚本即可启动redis服务。</p>

<p>{% codeblock lang:bash %}
$ src/redis-server
{% endcodeblock %}</p>

<h2>调试</h2>

<p>执行src目录下的redis-cli脚本，这个是redis的客户端。</p>

<p>{% codeblock lang:bash %}
$ src/redis-cli
redis> set foo bar
OK
redis> get foo
&ldquo;bar&rdquo;
{% endcodeblock %}</p>

<h2>java调用</h2>

<ol>
<li>Redis比较出名的java客户端是jedis，先下载jedis的jar包，可以去maven库搜下jedis就可以下载到，源码是放在github上：<a href="https://github.com/xetorthio/jedis">https://github.com/xetorthio/jedis</a>。</li>
<li>简单写个main方法就可以调用。
{% codeblock lang:java %}
 public static void main(String[] args) {
     Jedis jedis = new Jedis(&ldquo;10.20.8.39&rdquo;); //redis服务器的ip，端口默认6379
     jedis.set(&ldquo;foo&rdquo;, &ldquo;bar&rdquo;);
     String value = jedis.get(&ldquo;foo&rdquo;);
     System.out.println(value);
 }
{% endcodeblock %}</li>
</ol>


<h2>后台进程</h2>

<p>之前的启动方式不是后台进程方式的，终端关了服务也就停了，可以使用下面的命令将Redis作为后台进程启动，并添加到系统启动命名中。</p>

<p>{% codeblock lang:bash %}
$ cd redis-2.6.14/utils
$./install_server
{% endcodeblock %}</p>

<p>执行命令后，会提示你回答几个问题，可以一路回车过去，选择默认设置。</p>

<p>{% codeblock lang:bash %}
Please select the redis port for this instance: [6379]
Selecting default: 6379
Please select the redis config file name [/etc/redis/6379.conf]
Selected default &ndash; /etc/redis/6379.conf
Please select the redis log file name [/var/log/redis_6379.log]
Selected default &ndash; /var/log/redis_6379.log
Please select the data directory for this instance [/var/lib/redis/6379]
Selected default &ndash; /var/lib/redis/6379
Please select the redis executable path [/usr/local/bin/redis-server]
&hellip;
{% endcodeblock %}</p>

<p>后续可以通过下面的方式启停服务。<br/>
1. /etc/init.d/redis_6379 start &mdash;启动<br/>
2. /etc/init.d/redis_6379 stop &mdash;服务<br/>
当然也可在/usr/local/bin目录下使用redis-server来启动。</p>

<p><strong>PS: 我在执行install_server脚本后，发现服务启动不起来，查看/etc/init.d/redis_6379这个文件发现里面的换行符号被替换成了<code>/n</code>符号，手动将这些符号替换成换行就可以了。</strong></p>

<h2>更多资料</h2>

<p>更多资料可以看这里：<a href="http://redis.io/">http://redis.io/</a></p>
]]></content>
  </entry>
  
</feed>
