<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: java | Hacker and Geeker's Way]]></title>
  <link href="http://zhaozhiming.github.io/tags/java/atom.xml" rel="self"/>
  <link href="http://zhaozhiming.github.io/"/>
  <updated>2015-09-23T11:54:46+08:00</updated>
  <id>http://zhaozhiming.github.io/</id>
  <author>
    <name><![CDATA[赵芝明]]></name>
    <email><![CDATA[kingzzm1982@sina.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[微信公众账号开发part2——用户消息接收]]></title>
    <link href="http://zhaozhiming.github.io/blog/2015/02/04/wechat-public-account-dev-part-2/"/>
    <updated>2015-02-04T16:03:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2015/02/04/wechat-public-account-dev-part-2</id>
    <content type="html"><![CDATA[<p>{% img /images/post/2015-2/wechat_part2.jpg %}</p>

<p>上一篇写了如何通过微信开发者认证，今天来讲下如何接收用户的消息，我们以接收用户的订阅消息为例。</p>

<!--more-->


<p></p>

<h2>微信用户消息格式</h2>

<p>在开发者文档的<a href="http://mp.weixin.qq.com/wiki/2/5baf56ce4947d35003b86a9805634b1e.html">接收事件推送</a>文档中，说明了用户订阅消息的请求实体，内容如下:</p>

<p>{% codeblock lang:xml %}
<xml></p>

<pre><code>&lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;
&lt;FromUserName&gt;&lt;![CDATA[FromUser]]&gt;&lt;/FromUserName&gt;
&lt;CreateTime&gt;123456789&lt;/CreateTime&gt;
&lt;MsgType&gt;&lt;![CDATA[event]]&gt;&lt;/MsgType&gt;
&lt;Event&gt;&lt;![CDATA[subscribe]]&gt;&lt;/Event&gt;
</code></pre>

<p></xml>
{% endcodeblock %}</p>

<ul>
<li>ToUserName: 开发者微信号</li>
<li>FromUserName: 用户微信账号的OpenID</li>
<li>CreateTime: 消息发送时间，秒数</li>
<li>MsgType: 消息类型，事件消息为event</li>
<li>Event: 事件类型，订阅消息为subscribe</li>
</ul>


<h2>消息真实性验证</h2>

<p>{% blockquote 微信公众平台开发者文档 <a href="http://mp.weixin.qq.com/wiki/4/2ccadaef44fe1e4b0322355c2312bfa8.html">http://mp.weixin.qq.com/wiki/4/2ccadaef44fe1e4b0322355c2312bfa8.html</a> 验证消息真实性 %}
每次开发者接收用户消息的时候，微信也都会带上前面三个参数（signature、timestamp、nonce）访问开发者设置的URL，开发者依然通过对签名的效验判断此条消息的真实性。效验方式与首次提交验证申请一致。
{% endblockquote %}</p>

<p>所以每个订阅消息的http请求都会带有（signature、timestamp、nonce）这3个参数和上面的xml请求实体，服务端可以选择是否校验消息的真实性，建议校验，这样会比较安全。</p>

<h2>接收消息后的响应内容</h2>

<p>了解了消息请求的入参后，还需要知道我们处理请求后，需要返回什么样的内容给用户，这个在开发者文档里面好像没有提及，参考各方资料后知道需要返回一段xml内容，格式如下:</p>

<p>{% codeblock lang:xml %}
<xml></p>

<pre><code>&lt;Content&gt;感谢您关注我的公众账号[愉快]&lt;/Content&gt;
&lt;CreateTime&gt;1423022113&lt;/CreateTime&gt;
&lt;FromUserName&gt;zzm&lt;/FromUserName&gt;
&lt;FuncFlag&gt;0&lt;/FuncFlag&gt;
&lt;MsgType&gt;text&lt;/MsgType&gt;
&lt;ToUserName&gt;zzm&lt;/ToUserName&gt;
</code></pre>

<p></xml>
{% endcodeblock %}</p>

<ul>
<li>ToUserName: <code>用户微信账号的OpenID</code></li>
<li>FromUserName: <code>开发者微信号</code></li>
<li>CreateTime: 消息发送时间，秒数</li>
<li>FuncFlag: 这个暂时不知道是什么，默认值为0</li>
<li>MsgType: 消息类型，文档消息可以为text和其他，这里我们以最简单的text文本消息为例</li>
<li>Content: 返回给订阅用户的消息内容，可以加表情</li>
</ul>


<p>PS: ToUserName和FromUserName这2个参数和请求的xml实体要相反，这个也比较好理解，用户发了条消息过来，你要发个消息回去，ToUserName就变成了用户，FromUserName变成了你自己的公众账号了。</p>

<h2>服务端开发</h2>

<ul>
<li>了解了http请求的入参和出参，我们可以来开发我们的API了，<code>talk is cheap, show me code</code>。</li>
</ul>


<p>{% codeblock MainController.java lang:java %}</p>

<pre><code>//这里我们定义跟之前认证api相同的url，但方法是POST
@RequestMapping(value = "/index", method = RequestMethod.POST)
public
@ResponseBody
//3个校验消息真实性的参数，还有一个request实体body，里面是xml文本
ResponseEntity&lt;String&gt; receive(@RequestParam("signature") String signature,
                               @RequestParam("timestamp") String timestamp,
                               @RequestParam("nonce") String nonce,
                               @RequestBody String body) throws Exception {
    log.info("receive message start");
    log.info(String.format("signature:%s, timestamp:%s, nonce:%s", signature, timestamp, nonce));

    //先校验消息的真实性，如果校验失败，则返回400
    if (!wechatAuth(signature, timestamp, nonce)) {
        log.info("wechat auth failed");
        return new ResponseEntity&lt;String&gt;("wechat auth failed.", HttpStatus.BAD_REQUEST);
    }

    log.info(String.format("body:%s", body));
    //我们定义了一个util来解析xml，将其转换为一个object
    TextMessage requestMessage = XmlUtil.toTextMessage(body);
    log.info(String.format("requestMessage:%s", requestMessage));

    TextMessage textMessage = null;
    String msgType = requestMessage.getMsgType();
    String toUserName = requestMessage.getToUserName();
    String fromUserName = requestMessage.getFromUserName();
    //判断消息类型，如果是event，且事件类型为subscribe，则新建一个文本消息
    if (MessageType.event.name().equals(msgType)) {
        if (EventType.subscribe.name().equals(requestMessage.getEvent())) {
            String message = "感谢您关注我的公众账号[愉快]";
            textMessage = new TextMessage(toUserName, fromUserName,
                    MessageType.text.name(), message, TimeUtil.currentSeconds());
        }
    }

    //将文本消息转换为xml文本
    String responseMessage = XmlUtil.toXml(textMessage);
    HttpHeaders responseHeaders = new HttpHeaders();
    //设置返回实体的编码，不设置的话可能会变成乱码
    responseHeaders.add("Content-Type", "text/html; charset=utf-8");
    log.info(String.format("response message: %s", responseMessage));
    log.info("receive message finish");
    return new ResponseEntity&lt;String&gt;(responseMessage, responseHeaders, HttpStatus.OK);
}
</code></pre>

<p>{% endcodeblock %}</p>

<ul>
<li>这里使用java原生的JAXB来解析xml。</li>
</ul>


<p>{% codeblock XmlUtil.java lang:java %}
import com.zzm.wechat.model.TextMessage;
import org.apache.commons.io.IOUtils;</p>

<p>import javax.xml.bind.JAXBContext;
import javax.xml.bind.Marshaller;
import javax.xml.bind.Unmarshaller;
import java.io.StringReader;
import java.io.StringWriter;</p>

<p>public class XmlUtil {</p>

<pre><code>public static String toXml(TextMessage textMessage) throws Exception {
    if (textMessage == null) return "";

    JAXBContext context = JAXBContext.newInstance(TextMessage.class);
    Marshaller m = context.createMarshaller();
    m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);
    m.setProperty(Marshaller.JAXB_FRAGMENT, true);

    StringWriter sw = new StringWriter();
    m.marshal(textMessage, sw);
    return sw.toString();
}

public static TextMessage toTextMessage(String xml) throws Exception {
    JAXBContext jaxbContext = JAXBContext.newInstance(TextMessage.class);
    Unmarshaller jaxbUnmarshaller = jaxbContext.createUnmarshaller();
    StringReader reader = new StringReader(xml);
    TextMessage textMessage = (TextMessage) jaxbUnmarshaller.unmarshal(reader);
    IOUtils.closeQuietly(reader);
    return textMessage;
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<ul>
<li>定义消息的model类，这里需要用到xml的一些annotation。</li>
</ul>


<p>{% codeblock XmlUtil.java lang:java %}
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;</p>

<p>//定义命名空间，如果不写的话，xml会以类名开头: <TextMessage>&hellip;</TextMessage>，写了就会以xml开头: <xml>&hellip;</xml>
@XmlRootElement(name = &ldquo;xml&rdquo;)
public class TextMessage {</p>

<pre><code>private String fromUserName;
private String toUserName;
private String msgType;
private int funcFlag = 0;
private String content;
private String event;
private long createTime;

public TextMessage() {
}

public TextMessage(String fromUserName, String toUserName, String msgType, String content, long createTime) {
    this.fromUserName = fromUserName;
    this.toUserName = toUserName;
    this.msgType = msgType;
    this.content = content;
    this.createTime = createTime;
}

public String getToUserName() {
    return toUserName;
}

//定义xml子项的名称，不写这个annotation的话，转换后的xml是: &lt;toUserName&gt;xxx&lt;/toUserName&gt;，首字母变小写了，会导致消息传输错误
@XmlElement(name = "ToUserName")
public void setToUserName(String toUserName) {
    this.toUserName = toUserName;
}

//other setter and getter

@Override
public String toString() {
    //...
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<ul>
<li><p>方法写完以后，同样的打包，部署SAE。</p></li>
<li><p>打开手机，关注你的公众账号后，就可以看到服务端传过来的消息内容了。</p></li>
</ul>


<p>{% img /images/post/2015-2/wechat_subscribe.png %}</p>

<p>我的公众账号是<code>赵芝明的公账号</code>，有兴趣的也可以加一下，以后这个公共账号的功能肯定会慢慢丰富的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微信公众账号开发part1——开发者验证]]></title>
    <link href="http://zhaozhiming.github.io/blog/2015/02/04/wechat-public-account-dev-part-1/"/>
    <updated>2015-02-04T13:51:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2015/02/04/wechat-public-account-dev-part-1</id>
    <content type="html"><![CDATA[<p>{% img /images/post/2015-2/wechat.jpg %}</p>

<p>最近在了解微信公众账号的开发，准备边学边写一些文章来记录学习的过程，主要是基于微信的开发者模式来进行公共账号的开发，服务器选择新浪云SAE，语言还是选择比较熟悉的JAVA。</p>

<!--more-->


<p></p>

<h2>基本准备</h2>

<ul>
<li>登陆微信公众平台网站: <code>https://mp.weixin.qq.com</code>，进行账号注册，具体可以参考<a href="http://segmentfault.com/blog/zetd/1190000000356021">青龙老贼的这篇文章</a>，虽然内容有点老跟现在的不大一样，但不影响参考。</li>
<li>在SAE上面新建一个JAVA应用，这里还是可以参照<a href="http://segmentfault.com/blog/zetd/1190000000356067">青龙老贼的文章</a>，跟里面不同的是我们要创建一个JAVA的应用，而不是PHP的。</li>
</ul>


<h2>修改开发者中心的配置</h2>

<ul>
<li>登陆进到微信公众平台后，点击左下角的开发者中心，再点击图中的修改配置按钮，就可以进到修改配置页面。</li>
</ul>


<p>{% img /images/post/2015-2/wechat_config_1.png %}</p>

<ul>
<li>填写配置项

<ul>
<li>输入你的SAE的应用URL，比如:<code>http://xxx.sinaapp.com</code>，不一定要写应用的基本URL，可以在上面加一些扩展，比如<code>http://xxx.sinaapp.com/xxx</code>，这个要看你的应用的restful怎么定了。</li>
<li>TOKEN随便输入一个字符串就可以，这个值后面是要配置到java应用里面的，可以理解为一个加密的密钥。</li>
<li>EncodingAESKey随机生成。</li>
<li>消息加解密方式暂时选择明文模式。</li>
</ul>
</li>
</ul>


<p>{% img /images/post/2015-2/wechat_config_2.png %}</p>

<h2>微信服务端开发</h2>

<ul>
<li><p>新建一个spring mvc工程，可以参照<a href="https://confluence.jetbrains.com/display/IntelliJIDEA/Getting+Started+with+Spring+MVC,+Hibernate+and+JSON">这个文章</a>，但我们暂时不需要数据库和页面，只需要定义restful接口就可以了。</p></li>
<li><p>新建Controller并定义认证的api，可以参考微信公众平台开发者文档里面的<a href="http://mp.weixin.qq.com/wiki/17/2d4265491f12608cd170a95559800f2d.html">接入指南</a>，里面有段php代码是指导服务端怎么开发的，我们要做的只是把它翻译成JAVA。</p></li>
</ul>


<p>{% codeblock MainController.java lang:java %}
import com.google.common.base.Joiner;
import com.google.common.collect.Lists;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;</p>

<p>import java.security.MessageDigest;
import java.util.ArrayList;
import java.util.Collections;
@Controller
public class MainController {</p>

<pre><code>private static final Log log = LogFactory.getLog(MainController.class);

//从配置文件获取的token值，就是刚才在修改配置项里面定义的那个Token
@Value("${token}")
private String token;

//定义一个GET请求，url为xxx/index
@RequestMapping(value = "/index", method = RequestMethod.GET, produces = "text/html;charset=UTF-8")
public
@ResponseBody
//接收新手指南里面提到的那4个参数
ResponseEntity&lt;String&gt; auth(@RequestParam("signature") String signature,
                            @RequestParam("timestamp") String timestamp,
                            @RequestParam("nonce") String nonce,
                            @RequestParam("echostr") String echostr) throws Exception {
    log.info("wechat auth start");
    log.info(String.format("signature:%s, timestamp:%s, nonce:%s, echostr:%s",
            signature, timestamp, nonce, echostr));

    //如果认证通过，原样返回echostr值，并返回200的response
    if (wechatAuth(signature, timestamp, nonce)) {
        log.info("wechat auth success");
        return new ResponseEntity&lt;String&gt;(echostr, HttpStatus.OK);
    }

    //如果失败，则返回400，并提示认证失败
    log.info("wechat auth failed");
    return new ResponseEntity&lt;String&gt;("wechat auth failed.", HttpStatus.BAD_REQUEST);
}

private boolean wechatAuth(String signature, String timestamp, String nonce) {
    //将这3个string放到一个list里
    ArrayList&lt;String&gt; strings = Lists.newArrayList(token, timestamp, nonce);
    log.info(String.format("before sort array:%s", strings));
    //按字母顺序做一下排序
    Collections.sort(strings);
    log.info(String.format("after sort array:%s", strings));

    //将list里面所有string组合成一个string，这里用到了guava的Joiner
    String groupString = Joiner.on("").join(strings);
    log.info(String.format("groupString string:%s", groupString));

    //用SHA1加密该string
    String result = sha1(groupString);
    log.info(String.format("sha1:%s", result));
    //加密后的值和signature进行比较，注意用java加密后都是字母都是大写的，而传过来的signature是小写字母，所以要大小写转换一下
    boolean compareResult = result.equals(signature.toUpperCase());
    log.info(String.format("compare result:%b", compareResult));
    return compareResult;
}

//类似php的sha1方法
private String sha1(String s) {
    try {
        // Create MD5 Hash
        MessageDigest digest = MessageDigest.getInstance("SHA-1");
        digest.update(s.getBytes());
        byte messageDigest[] = digest.digest();

        // Create Hex String
        StringBuilder hexString = new StringBuilder();
        for (byte aMessageDigest : messageDigest) {
            hexString.append(String.format("%02X", 0xFF &amp; aMessageDigest));
        }
        return hexString.toString();
    } catch (Exception e) {
        throw new RuntimeException("sha1 failed");
    }
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<ul>
<li>将工程打包成war，上传到SAE完成部署，启动应用</li>
</ul>


<h2>启用开发者模式</h2>

<ul>
<li>进到微信公众平台的开发者中心，点击服务器配置那一行后面的启用按钮，如果服务器正常启动的话，就可以看到启用成功的提示了。</li>
</ul>


<p>{% img /images/post/2015-2/wechat_start.png %}</p>

<p>更多代码可以看这里: <a href="https://github.com/zhaozhiming/wechat-blog%EF%BC%8C%E8%A7%89%E5%BE%97%E5%A5%BD%E7%9A%84%E8%AF%9D%E8%AF%B7Star%E4%B8%80%E4%B8%8B%E5%90%A7%EF%BC%8C%E8%B0%A2%E8%B0%A2">https://github.com/zhaozhiming/wechat-blog%EF%BC%8C%E8%A7%89%E5%BE%97%E5%A5%BD%E7%9A%84%E8%AF%9D%E8%AF%B7Star%E4%B8%80%E4%B8%8B%E5%90%A7%EF%BC%8C%E8%B0%A2%E8%B0%A2</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何重构一个圈复杂度超30的类]]></title>
    <link href="http://zhaozhiming.github.io/blog/2013/10/08/how-to-refactor-a-class-which-cyclomatic-complexity-over-30/"/>
    <updated>2013-10-08T20:43:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2013/10/08/how-to-refactor-a-class-which-cyclomatic-complexity-over-30</id>
    <content type="html"><![CDATA[<p>下面的类是一个老系统的代码，现在放到sonar上面进行扫描，扫出来的结果发现复杂度超过了30。</p>

<p>代码复杂度是指代码中的分支数量，比如有一个if分支，代码复杂度就加1，如果if中有“||”或者“&amp;&amp;”那么代码复杂度就加2，for和while同理。一般复杂度超过10的类就算是比较复杂的了，而这个类的复杂度竟然达到了30，代码的糟糕程度可见一斑，现在我们就来重构一下这个类的代码。</p>

<!--more-->


<p>原始文件在<strong><a href="https://github.com/zhaozhiming/zhaozhiming.github.com/blob/source/source/file/SomeClient(old).java">这里</a>。</strong><br/>
重构开始吧！</p>

<h2>多处String类型非空判断</h2>

<p>{% codeblock lang:java %}
if (StringUtil.isEmpty(username))</p>

<pre><code>throw new ICRClientException("username can not be null");
</code></pre>

<p>if (StringUtil.isEmpty(password))</p>

<pre><code>throw new ICRClientException("password can not be null");
</code></pre>

<p>if (udto == null)</p>

<pre><code>throw new ICRClientException("ICRUploadDTO can not be null");
</code></pre>

<p>{% endcodeblock %}</p>

<p>重构之后：</p>

<p>{% codeblock lang:java %}
//将原来的地方替换为
checkStringParamEmpty(username, &ldquo;username&rdquo;);
checkStringParamEmpty(password, &ldquo;password&rdquo;);
checkStringParamEmpty(udto.getUrlPath(), &ldquo;urlPath&rdquo;);
&hellip;
//新增一个方法
private void checkStringParamEmpty(String value, String name) throws ICRClientException {</p>

<pre><code>if (StringUtil.isEmpty(value)) {
    throw new ICRClientException(name + " can not be null");
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>原代码中不止这3个参数的校验，还有很多，越多参数的校验，我们重构后的复杂度就会越低。</p>

<p><strong>代码复杂度变化：原来是3，修改后为1。</strong></p>

<h2>多String值判断</h2>

<p>{% codeblock lang:java %}
if (!udto.getPriority().equals(&ldquo;0&rdquo;) &amp;&amp; !udto.getPriority().equals(&ldquo;1&rdquo;)</p>

<pre><code>&amp;&amp; !udto.getPriority().equals("2") &amp;&amp; !udto.getPriority().equals("3"))
</code></pre>

<p>throw new ICRClientException(&ldquo;priority must be 0/&frac12;/3&rdquo;);
{% endcodeblock %}</p>

<p>重构之后：</p>

<p>{% codeblock lang:java %}
//将原来代码替换为
checkValueWithinList(udto.getPriority());
&hellip;
//新增一个方法：
private void checkValueWithinList(String priority) throws ICRClientException {</p>

<pre><code>if (!Arrays.asList("0", "1", "2", "3").contains(priority)) {
    throw new ICRClientException("priority must be 0/1/2/3");
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p><strong>代码复杂度变化：原来是4，修改后为1。</strong></p>

<h2>对list的非空判断</h2>

<p>{% codeblock lang:java %}
if (list == null || list.size() == 0)</p>

<pre><code>throw new ICRClientException("list can not be null");
</code></pre>

<p>{% endcodeblock %}</p>

<p>重构之后：</p>

<p>{% codeblock lang:java %}
//将原来的代码替换为
checkValueWithinList(udto.getPriority());
&hellip;
//新增一个方法
private void checkListNoNull(List list) throws ICRClientException {</p>

<pre><code>if (list.isEmpty()) throw new ICRClientException("list can not be null");
</code></pre>

<p>}
{% endcodeblock %}</p>

<p><strong>代码复杂度变化：原来是2，修改后为1。</strong></p>

<h2>多个catch的内容相同</h2>

<p>{% codeblock lang:java %}
int code = 0;
try {</p>

<pre><code>code = httpClient.executeMethod(post);
</code></pre>

<p>} catch (HttpException e) {</p>

<pre><code>throw new ICRClientException(e.getMessage(), e);
</code></pre>

<p>} catch (IOException e) {</p>

<pre><code>throw new ICRClientException(e.getMessage(), e);
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>重构之后：</p>

<p>{% codeblock lang:java %}
//将原来的地方替换为
int code = executeHttpClient(httpClient, post);
&hellip;
//新增一个方法
private int executeHttpClient(HttpClient httpClient, PostMethod post) throws ICRClientException {</p>

<pre><code>int code;
try {
    code = httpClient.executeMethod(post);
} catch (Exception e) {
    throw new ICRClientException(e.getMessage(), e);
}
return code;
</code></pre>

<p>}
{% endcodeblock %}</p>

<p><strong>代码复杂度变化：原来是2，修改后为1。</strong></p>

<h2>if判断结果复杂化</h2>

<p>{% codeblock lang:java %}
 if (code == 200) {</p>

<pre><code>try {
    if (post.getResponseBodyAsString().equals("ok")) {
        return true;
    }
} catch (IOException e) {
    throw new ICRClientException(e.getMessage(), e);
}
return false;
</code></pre>

<p>} else if (code == 500) {</p>

<pre><code>throw new ICRClientException(post.getResponseBodyAsString());
</code></pre>

<p>} else {</p>

<pre><code>throw new ICRClientException(code + ":" + post.getStatusText());
</code></pre>

<p>}         <br/>
{% endcodeblock %}</p>

<p>重构之后:</p>

<p>{% codeblock lang:java %}
//将原来代码替换为
return returnFinialResult(post, code);
&hellip;
//新增一个方法
private boolean returnFinialResult(PostMethod post, int code) throws ICRClientException, IOException {</p>

<pre><code>if (code == 500) throw new ICRClientException(post.getResponseBodyAsString());
if (code != 200) throw new ICRClientException(code + ":" + post.getStatusText());

try {
    return post.getResponseBodyAsString().equals("ok");
} catch (IOException e) {
    throw new ICRClientException(e.getMessage(), e);
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p><strong>代码复杂度变化：原来是4，修改后为3。</strong></p>

<h2>本地变量始终不为null</h2>

<p>{% codeblock lang:java %}
public boolean uploadToICR(String username, String password, ICRUploadDTO udto) throws ICRClientException {</p>

<pre><code>HttpClient httpClient = null;
PostMethod post = null;
httpClient = new HttpClient();
//some code here
…
} finally {
    if (post != null) {
        post.releaseConnection();
    }
    if (httpClient != null) {
        httpClient.getHttpConnectionManager().closeIdleConnections(0);
    }
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>重构之后：</p>

<p>{% codeblock lang:java %}
public boolean uploadToICR(String username, String password, ICRUploadDTO udto) throws ICRClientException {</p>

<pre><code>HttpClient httpClient = new HttpClient();
PostMethod post = null;
//some code here
…
} finally {
    if (post != null) {
        post.releaseConnection();
    }
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p><strong>代码复杂度变化：原来是1，修改后为0。</strong></p>

<h2>读取IO流的方法，为什么要自己实现？</h2>

<p>{% codeblock lang:java %}
private byte[] readData(InputStream ins) throws IOException {</p>

<pre><code>byte[] buf = new byte[2048];
int count = 0;
int len = 0;
byte data[] = new byte[2048];
byte[] result = null;
try {
    while ((len = ins.read(data, 0, 2048)) != -1) {
        int newcount = count + len;
        if (newcount &gt; buf.length) {
            byte newbuf[] = new byte[Math
                    .max(buf.length &lt;&lt; 1, newcount)];
            System.arraycopy(buf, 0, newbuf, 0, count);
            buf = newbuf;
        }
        System.arraycopy(data, 0, buf, count, len);
        count = newcount;
    }
    result = new byte[count];
    System.arraycopy(buf, 0, result, 0, count);

} finally {
    ins.close();
}
return result;
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>在原代码里面自己实现了一个对读取IO流字节的方法，这个可以使用apache-io或者guava的API代替：</p>

<p>{% codeblock lang:java %}
//使用apache io API的实现：
byte[] bytes = IOUtils.toByteArray(inputStream);
//使用guava API的实现：
byte[] bytes1 = ByteStreams.toByteArray(inputStream);
{% endcodeblock %}</p>

<p><strong>代码复杂度变化：原来是很多，修改后为0。</strong></p>

<p>最终重构后的版本见<strong><a href="https://github.com/zhaozhiming/zhaozhiming.github.com/blob/source/source/file/SomeClient(new).java">这里</a></strong>，最后的代码复杂度从原来的30降到了3。<br/>
代码写的比较仓促，没有写单元测试，其实最好的做法是在重构之前先写好单元测试，然后再慢慢修改原来的代码，每修改一处地方跑一遍单元测试，这样可以保证你的重构没有破坏原来的代码逻辑。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[单例模式的5种形式]]></title>
    <link href="http://zhaozhiming.github.io/blog/2012/12/20/5-type-of-singleton-pattern/"/>
    <updated>2012-12-20T17:53:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2012/12/20/5-type-of-singleton-pattern</id>
    <content type="html"><![CDATA[<p>有过编程经验的朋友都知道设计模式中的单例模式，最近又重新看了一遍设计模式，今天将单例模式的几种形式介绍一下：</p>

<!--more-->


<p></p>

<h3>1、懒汉形式（延迟加载）</h3>

<p>{% codeblock Singleton.java lang:java %}
public class Singleton{</p>

<pre><code>private static Singleton singleton;

private Singleton() {
}

public synchronized static Single newInstance() {
    if (singleton== null) {
        singleton= new Singleton();
    }
    return singleton;
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>这个是标准的单例模式，通过newInstance里面的判断来进行延迟加载单例对象，这里加了synchronized关键字可以避免多线程问题，但会影响程序性能。</p>

<h3>2、饿汉形式（贪婪加载）</h3>

<p>{% codeblock Singleton.java lang:java %}
public class Singleton {</p>

<pre><code>private static Singleton singleton= new Singleton();

private singleton() {
}

public static Singleton newInstance() {
    return singleton;
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>在单例对象声明的时候就直接初始化对象，可以避免多线程问题，但是如果对象初始化比较复杂，会导致程序初始化缓慢。</p>

<h3>3、双重检查加锁</h3>

<p>{% codeblock Singleton.java lang:java %}
public class Singleton {</p>

<pre><code>private volatile static Singleton singleton;

private Singleton() {
}

public static Singleton newInstance() {
    if (singleton == null) {
        synchronized (Singleton.class) {
            if (singleton == null) {
                singleton = new Singleton();
            }
        }
    }
    return singleton;
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>这个是懒汉形式的加强版，将synchronized关键字移到了newInstance方法里面，同时将singleton对象加上volatile关键字，这种方式既可以避免多线程问题，又不会降低程序的性能。但volatile关键字也有一些性能问题，不建议大量使用。</p>

<h3>4、Lazy initialization holder class</h3>

<p>{% codeblock Singleton.java lang:java %}
public class Singleton {</p>

<pre><code>private static class SingletonHolder {
    private static Singleton singleton = new Singleton();
}

private Singleton() {
}

public static Singleton newInstance() {
    return SingletonHolder.singleton;
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>这里创建了一个内部静态类，通过内部类的机制使得单例对象可以延迟加载，同时内部类相当于是外部类的静态部分，所以可以通过jvm来保证其线程安全。这种形式比较推荐。</p>

<h3>5、枚举</h3>

<p>{% codeblock Singleton.java lang:java %}
public enum Singleton {</p>

<pre><code>singleton
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>单因素的枚举类已经实现了单例，这种方法更加简单。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Array类处理基本数组对象]]></title>
    <link href="http://zhaozhiming.github.io/blog/2012/05/22/use-array-deal-with-base-type-in-java/"/>
    <updated>2012-05-22T14:35:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2012/05/22/use-array-deal-with-base-type-in-java</id>
    <content type="html"><![CDATA[<p>java里面的Arrays类有个asList方法，参数是1或多个Object对象，如果传入一个Object数组，则可以将该数组转化为List，但如果传入的是一个基本类型的数据（int,long,short 等），则无法将数组转换成正确的list，测试代码如下：</p>

<!--more-->


<p>
{% codeblock Main.java lang:java %}</p>

<pre><code>public static void main(String[] args) {
    List&lt;int[]&gt; ints = asList(new int[]{1, 2});
    System.out.println(ints.size());  //1

    List&lt;Integer&gt; integers = asList(new Integer[]{1, 2});
    System.out.println(integers.size()); //2
}
</code></pre>

<p>{% endcodeblock %}</p>

<p>asList会将整个基本类型数组作为一个Object对象放到list里面，所以第一个List的size只有1。</p>

<p>如何将基本类型数组装换为一个list呢？最简单暴力的方法就是遍历整个基本类型数组，再逐一往list里面添加。但这种方法不适用所有基本类型，需要为每种基本类型写一个方法。</p>

<p>{% codeblock Main.java lang:java %}</p>

<pre><code>public List&lt;Integer&gt; arrayToList(int[] ints) {
    List&lt;Integer&gt; intList = new ArrayList&lt;Integer&gt;();
    for (int anInt : ints) {
        intList.add(anInt);
    }
    return intList;
}

public List&lt;Long&gt; arrayToList(Long[] longs) {
    List&lt;Long&gt; longList = new ArrayList&lt;Long&gt;();
    for (long anLong : longs) {
        longList.add(anLong);
    }
    return longList;
}
</code></pre>

<p>　　&hellip;..other arrayToList method
{% endcodeblock %}</p>

<p>重复代码会很多是吧，如何消除呢？下面就是帖子的重点了，利用Array类进行操作。</p>

<p>Array类有几个方法比较常用：</p>

<ul>
<li>public static int getLength(java.lang.Object array)：获取数组对象的长度。</li>
<li>public static java.lang.Object get(java.lang.Object array, int index)：根据下标获取数组对象的元素。</li>
<li>public static void set(java.lang.Object array, int index, java.lang.Object value)：根据下标插入数组对象元素。</li>
</ul>


<p>于是上面那些方法就可以用一个方法搞定了，如下：</p>

<p>{% codeblock Main.java lang:java %}</p>

<pre><code>public static void main(String[] args) {
    int[] ints = {1, 2};
    long[] longs = {1L, 2L, 3L};
    char[] chars = {'a', 'b', 'c', 'd'};

    System.out.println(arrayToList(ints).size()); //2
    System.out.println(arrayToList(longs).size()); //3
    System.out.println(arrayToList(chars).size()); //4
}

public static List&lt;Object&gt; arrayToList(Object array) {
    List&lt;Object&gt; list = new ArrayList&lt;Object&gt;();
    int length = Array.getLength(array);
    for (int i = 0; i &lt; length; i++) {
        list.add(Array.get(array, i));
    }
    return list;
}
</code></pre>

<p>{% endcodeblock %}</p>
]]></content>
  </entry>
  
</feed>
