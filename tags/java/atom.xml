<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: java | Hacker and Geeker's Way]]></title>
  <link href="http://zhaozhiming.github.io/tags/java/atom.xml" rel="self"/>
  <link href="http://zhaozhiming.github.io/"/>
  <updated>2013-08-24T09:10:37+08:00</updated>
  <id>http://zhaozhiming.github.io/</id>
  <author>
    <name><![CDATA[赵芝明]]></name>
    <email><![CDATA[kingzzm1982@sina.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[单例模式的5种形式]]></title>
    <link href="http://zhaozhiming.github.io/blog/2012/12/20/5-type-of-singleton-pattern/"/>
    <updated>2012-12-20T17:53:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2012/12/20/5-type-of-singleton-pattern</id>
    <content type="html"><![CDATA[<p>有过编程经验的朋友都知道设计模式中的单例模式，最近又重新看了一遍设计模式，今天将单例模式的几种形式介绍一下：</p>

<h3>1、懒汉形式（延迟加载）</h3>

<p>{% codeblock Singleton.java lang:java %}
public class Singleton{</p>

<pre><code>private static Singleton singleton;

private Singleton() {
}

public synchronized static Single newInstance() {
    if (singleton== null) {
        singleton= new Singleton();
    }
    return singleton;
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>这个是标准的单例模式，通过newInstance里面的判断来进行延迟加载单例对象，这里加了synchronized关键字可以避免多线程问题，但会影响程序性能。</p>

<h3>2、饿汉形式（贪婪加载）</h3>

<p>{% codeblock Singleton.java lang:java %}
public class Singleton {</p>

<pre><code>private static Singleton singleton= new Singleton();

private singleton() {
}

public static Singleton newInstance() {
    return singleton;
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>在单例对象声明的时候就直接初始化对象，可以避免多线程问题，但是如果对象初始化比较复杂，会导致程序初始化缓慢。</p>

<h3>3、双重检查加锁</h3>

<p>{% codeblock Singleton.java lang:java %}
public class Singleton {</p>

<pre><code>private volatile static Singleton singleton;

private Singleton() {
}

public static Singleton newInstance() {
    if (singleton == null) {
        synchronized (Singleton.class) {
            if (singleton == null) {
                singleton = new Singleton();
            }
        }
    }
    return singleton;
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>这个是懒汉形式的加强版，将synchronized关键字移到了newInstance方法里面，同时将singleton对象加上volatile关键字，这种方式既可以避免多线程问题，又不会降低程序的性能。但volatile关键字也有一些性能问题，不建议大量使用。</p>

<h3>4、Lazy initialization holder class</h3>

<p>{% codeblock Singleton.java lang:java %}
public class Singleton {</p>

<pre><code>private static class SingletonHolder {
    private static Singleton singleton = new Singleton();
}

private Singleton() {
}

public static Singleton newInstance() {
    return SingletonHolder.singleton;
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>这里创建了一个内部静态类，通过内部类的机制使得单例对象可以延迟加载，同时内部类相当于是外部类的静态部分，所以可以通过jvm来保证其线程安全。这种形式比较推荐。</p>

<h3>5、枚举</h3>

<p>{% codeblock Singleton.java lang:java %}
public enum Singleton {</p>

<pre><code>singleton
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>单因素的枚举类已经实现了单例，这种方法更加简单。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Array类处理基本数组对象]]></title>
    <link href="http://zhaozhiming.github.io/blog/2012/05/22/use-array-deal-with-base-type-in-java/"/>
    <updated>2012-05-22T14:35:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2012/05/22/use-array-deal-with-base-type-in-java</id>
    <content type="html"><![CDATA[<p>java里面的Arrays类有个asList方法，参数是1或多个Object对象，如果传入一个Object数组，则可以将该数组转化为List，但如果传入的是一个基本类型的数据（int,long,short 等），则无法将数组转换成正确的list，测试代码如下：</p>

<p>{% codeblock Main.java lang:java %}</p>

<pre><code>public static void main(String[] args) {
    List&lt;int[]&gt; ints = asList(new int[]{1, 2});
    System.out.println(ints.size());  //1

    List&lt;Integer&gt; integers = asList(new Integer[]{1, 2});
    System.out.println(integers.size()); //2
}
</code></pre>

<p>{% endcodeblock %}</p>

<p>asList会将整个基本类型数组作为一个Object对象放到list里面，所以第一个List的size只有1。</p>

<p>如何将基本类型数组装换为一个list呢？最简单暴力的方法就是遍历整个基本类型数组，再逐一往list里面添加。但这种方法不适用所有基本类型，需要为每种基本类型写一个方法。</p>

<p>{% codeblock Main.java lang:java %}</p>

<pre><code>public List&lt;Integer&gt; arrayToList(int[] ints) {
    List&lt;Integer&gt; intList = new ArrayList&lt;Integer&gt;();
    for (int anInt : ints) {
        intList.add(anInt);
    }
    return intList;
}

public List&lt;Long&gt; arrayToList(Long[] longs) {
    List&lt;Long&gt; longList = new ArrayList&lt;Long&gt;();
    for (long anLong : longs) {
        longList.add(anLong);
    }
    return longList;
}
</code></pre>

<p>　　&hellip;..other arrayToList method
{% endcodeblock %}</p>

<p>重复代码会很多是吧，如何消除呢？下面就是帖子的重点了，利用Array类进行操作。</p>

<p>Array类有几个方法比较常用：</p>

<ul>
<li>public static int getLength(java.lang.Object array)：获取数组对象的长度。</li>
<li>public static java.lang.Object get(java.lang.Object array, int index)：根据下标获取数组对象的元素。</li>
<li>public static void set(java.lang.Object array, int index, java.lang.Object value)：根据下标插入数组对象元素。</li>
</ul>


<p>于是上面那些方法就可以用一个方法搞定了，如下：</p>

<p>{% codeblock Main.java lang:java %}</p>

<pre><code>public static void main(String[] args) {
    int[] ints = {1, 2};
    long[] longs = {1L, 2L, 3L};
    char[] chars = {'a', 'b', 'c', 'd'};

    System.out.println(arrayToList(ints).size()); //2
    System.out.println(arrayToList(longs).size()); //3
    System.out.println(arrayToList(chars).size()); //4
}

public static List&lt;Object&gt; arrayToList(Object array) {
    List&lt;Object&gt; list = new ArrayList&lt;Object&gt;();
    int length = Array.getLength(array);
    for (int i = 0; i &lt; length; i++) {
        list.add(Array.get(array, i));
    }
    return list;
}
</code></pre>

<p>{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[junit4与junt3并存时产生的问题]]></title>
    <link href="http://zhaozhiming.github.io/blog/2012/04/16/some-problems-when-use-junit3-and-junt4-at-the-same-time/"/>
    <updated>2012-04-16T15:54:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2012/04/16/some-problems-when-use-junit3-and-junt4-at-the-same-time</id>
    <content type="html"><![CDATA[<p>目前的项目里用junit写单元测试，使用的是junit4，由于大部分开发之前使用的都是junit3，对junit4还不是很熟悉，所以出现了junit3和4混合使用的情况，导致发生了一些问题，这里列举一下。</p>

<p><strong>1.测试类继承了TestCase，方法名是test开头，加Ignore标签，这时Ignore标签失效。错误代码示例：</strong></p>

<p>{% codeblock test.java lang:java %}
public MyClassTest extends TestCase {</p>

<pre><code>@Test
@Ignore
public void testMyMethod() throws Exception {
    // some code
}
</code></pre>

<p>}
{% endcodeblock %}<br/>
在junit3里，测试类必须继承TestCase，方法必须是以test开头；而在junit4里面，无需继承TestCase类，方法名也不需要test开头，只需要在每个方法前加上@Test标签即可。如果是继承TestCase，方法名以test开头，则junit会认为是junt3的写法，而使得junit4的标签失效。</p>

<p><strong>2.测试类继承了TestCase，方法前加上@Test标签，方法名不以test开头，该方法不会被junit执行。</strong></p>

<p>{% codeblock test.java lang:java %}
public MyClassTest extends TestCase {</p>

<pre><code>@Test
public void should_test_my_method() throws Exception {
    // some code
}
</code></pre>

<p>}
{% endcodeblock %}  <br/>
用于使用了@Test标签，则方法名可以不需以test开头，但该测试类由于继承了TestCase，所以默认是使用了junit3的契约，所以方法名必须以test开头，否则junit不认，即使是加上了@Test标签。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java通过class文件得到所在jar包]]></title>
    <link href="http://zhaozhiming.github.io/blog/2012/03/16/java-get-the-jar-file-by-the-class-file-of-jar/"/>
    <updated>2012-03-16T18:04:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2012/03/16/java-get-the-jar-file-by-the-class-file-of-jar</id>
    <content type="html"><![CDATA[<p>今天遇到一个问题，需要通过知道的class文件得到该文件所在的jar包，试过很多办法都不行，最后在网上找到了一个解决办法，如下：<br/>
{% codeblock demo.java lang:java %}
String path = XXX.class.getProtectionDomain().getCodeSource().getLocation().getFile();
File jarFile = new File(path);
{% endcodeblock %}</p>

<p>其中的XXX指已经知道的类名，然后通过后面的方法可以直接获取到JAR包，具体这些方法是干嘛的，下来研究后再补充。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在ant编译java文件时产生debug信息]]></title>
    <link href="http://zhaozhiming.github.io/blog/2012/03/06/generate-debug-info-when-use-ant-compile-java-file/"/>
    <updated>2012-03-06T17:41:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2012/03/06/generate-debug-info-when-use-ant-compile-java-file</id>
    <content type="html"><![CDATA[<p>使用ant编译java文件时，如果没有设置debug属性，则不会产生编译信息，ant的默认设置是不打印编译信息。</p>

<p>如果想在编译过程中显示编译信息，需设置debug属性为true，并且设置debugLevel，如下代码所示：</p>

<p>{% codeblock ant file &ndash; build.xml lang:xml %}
<javac ... debug="true" debuglevel="lines, vars, source">
{% endcodeblock %}</p>

<p>ant的官方文档：</p>

<table>
<thead>
<tr>
<th> debug       </th>
<th>  Indicates whether source should be compiled with debug information; defaults to off. If set to off, -g:none will be passed on the command line for compilers that support it (for other compilers, no command line argument will be used). If set to true, the value of the debuglevel attribute determines the command line argument.  </th>
<th> No  </th>
</tr>
</thead>
<tbody>
<tr>
<td>debuglevel</td>
<td>  Keyword list to be appended to the -g command-line switch. This will be ignored by all implementations except modern, classic(ver >= 1.2) and jikes. Legal values are none or a comma-separated list of the following keywords: lines, vars, and source. If debuglevel is not specified, by default, nothing will be appended to -g. If debug is not turned on, this attribute will be ignored. </td>
<td>  </td>
</tr>
</tbody>
</table>


<p>这里要注意的是如果设置debug属性为true，但是没有设置debuglevel属性，编译时还是不会打印信息，因为debuglevel的默认值是none，只有单独设置为lines, vars, source或其组合才会打印出信息。</p>
]]></content>
  </entry>
  
</feed>
