<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: refactor | Hacker and Geeker's Way]]></title>
  <link href="http://zhaozhiming.github.io/tags/refactor/atom.xml" rel="self"/>
  <link href="http://zhaozhiming.github.io/"/>
  <updated>2015-09-23T11:54:46+08:00</updated>
  <id>http://zhaozhiming.github.io/</id>
  <author>
    <name><![CDATA[赵芝明]]></name>
    <email><![CDATA[kingzzm1982@sina.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[如何重构一个圈复杂度超30的类]]></title>
    <link href="http://zhaozhiming.github.io/blog/2013/10/08/how-to-refactor-a-class-which-cyclomatic-complexity-over-30/"/>
    <updated>2013-10-08T20:43:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2013/10/08/how-to-refactor-a-class-which-cyclomatic-complexity-over-30</id>
    <content type="html"><![CDATA[<p>下面的类是一个老系统的代码，现在放到sonar上面进行扫描，扫出来的结果发现复杂度超过了30。</p>

<p>代码复杂度是指代码中的分支数量，比如有一个if分支，代码复杂度就加1，如果if中有“||”或者“&amp;&amp;”那么代码复杂度就加2，for和while同理。一般复杂度超过10的类就算是比较复杂的了，而这个类的复杂度竟然达到了30，代码的糟糕程度可见一斑，现在我们就来重构一下这个类的代码。</p>

<!--more-->


<p>原始文件在<strong><a href="https://github.com/zhaozhiming/zhaozhiming.github.com/blob/source/source/file/SomeClient(old).java">这里</a>。</strong><br/>
重构开始吧！</p>

<h2>多处String类型非空判断</h2>

<p>{% codeblock lang:java %}
if (StringUtil.isEmpty(username))</p>

<pre><code>throw new ICRClientException("username can not be null");
</code></pre>

<p>if (StringUtil.isEmpty(password))</p>

<pre><code>throw new ICRClientException("password can not be null");
</code></pre>

<p>if (udto == null)</p>

<pre><code>throw new ICRClientException("ICRUploadDTO can not be null");
</code></pre>

<p>{% endcodeblock %}</p>

<p>重构之后：</p>

<p>{% codeblock lang:java %}
//将原来的地方替换为
checkStringParamEmpty(username, &ldquo;username&rdquo;);
checkStringParamEmpty(password, &ldquo;password&rdquo;);
checkStringParamEmpty(udto.getUrlPath(), &ldquo;urlPath&rdquo;);
&hellip;
//新增一个方法
private void checkStringParamEmpty(String value, String name) throws ICRClientException {</p>

<pre><code>if (StringUtil.isEmpty(value)) {
    throw new ICRClientException(name + " can not be null");
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>原代码中不止这3个参数的校验，还有很多，越多参数的校验，我们重构后的复杂度就会越低。</p>

<p><strong>代码复杂度变化：原来是3，修改后为1。</strong></p>

<h2>多String值判断</h2>

<p>{% codeblock lang:java %}
if (!udto.getPriority().equals(&ldquo;0&rdquo;) &amp;&amp; !udto.getPriority().equals(&ldquo;1&rdquo;)</p>

<pre><code>&amp;&amp; !udto.getPriority().equals("2") &amp;&amp; !udto.getPriority().equals("3"))
</code></pre>

<p>throw new ICRClientException(&ldquo;priority must be 0/&frac12;/3&rdquo;);
{% endcodeblock %}</p>

<p>重构之后：</p>

<p>{% codeblock lang:java %}
//将原来代码替换为
checkValueWithinList(udto.getPriority());
&hellip;
//新增一个方法：
private void checkValueWithinList(String priority) throws ICRClientException {</p>

<pre><code>if (!Arrays.asList("0", "1", "2", "3").contains(priority)) {
    throw new ICRClientException("priority must be 0/1/2/3");
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p><strong>代码复杂度变化：原来是4，修改后为1。</strong></p>

<h2>对list的非空判断</h2>

<p>{% codeblock lang:java %}
if (list == null || list.size() == 0)</p>

<pre><code>throw new ICRClientException("list can not be null");
</code></pre>

<p>{% endcodeblock %}</p>

<p>重构之后：</p>

<p>{% codeblock lang:java %}
//将原来的代码替换为
checkValueWithinList(udto.getPriority());
&hellip;
//新增一个方法
private void checkListNoNull(List list) throws ICRClientException {</p>

<pre><code>if (list.isEmpty()) throw new ICRClientException("list can not be null");
</code></pre>

<p>}
{% endcodeblock %}</p>

<p><strong>代码复杂度变化：原来是2，修改后为1。</strong></p>

<h2>多个catch的内容相同</h2>

<p>{% codeblock lang:java %}
int code = 0;
try {</p>

<pre><code>code = httpClient.executeMethod(post);
</code></pre>

<p>} catch (HttpException e) {</p>

<pre><code>throw new ICRClientException(e.getMessage(), e);
</code></pre>

<p>} catch (IOException e) {</p>

<pre><code>throw new ICRClientException(e.getMessage(), e);
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>重构之后：</p>

<p>{% codeblock lang:java %}
//将原来的地方替换为
int code = executeHttpClient(httpClient, post);
&hellip;
//新增一个方法
private int executeHttpClient(HttpClient httpClient, PostMethod post) throws ICRClientException {</p>

<pre><code>int code;
try {
    code = httpClient.executeMethod(post);
} catch (Exception e) {
    throw new ICRClientException(e.getMessage(), e);
}
return code;
</code></pre>

<p>}
{% endcodeblock %}</p>

<p><strong>代码复杂度变化：原来是2，修改后为1。</strong></p>

<h2>if判断结果复杂化</h2>

<p>{% codeblock lang:java %}
 if (code == 200) {</p>

<pre><code>try {
    if (post.getResponseBodyAsString().equals("ok")) {
        return true;
    }
} catch (IOException e) {
    throw new ICRClientException(e.getMessage(), e);
}
return false;
</code></pre>

<p>} else if (code == 500) {</p>

<pre><code>throw new ICRClientException(post.getResponseBodyAsString());
</code></pre>

<p>} else {</p>

<pre><code>throw new ICRClientException(code + ":" + post.getStatusText());
</code></pre>

<p>}         <br/>
{% endcodeblock %}</p>

<p>重构之后:</p>

<p>{% codeblock lang:java %}
//将原来代码替换为
return returnFinialResult(post, code);
&hellip;
//新增一个方法
private boolean returnFinialResult(PostMethod post, int code) throws ICRClientException, IOException {</p>

<pre><code>if (code == 500) throw new ICRClientException(post.getResponseBodyAsString());
if (code != 200) throw new ICRClientException(code + ":" + post.getStatusText());

try {
    return post.getResponseBodyAsString().equals("ok");
} catch (IOException e) {
    throw new ICRClientException(e.getMessage(), e);
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p><strong>代码复杂度变化：原来是4，修改后为3。</strong></p>

<h2>本地变量始终不为null</h2>

<p>{% codeblock lang:java %}
public boolean uploadToICR(String username, String password, ICRUploadDTO udto) throws ICRClientException {</p>

<pre><code>HttpClient httpClient = null;
PostMethod post = null;
httpClient = new HttpClient();
//some code here
…
} finally {
    if (post != null) {
        post.releaseConnection();
    }
    if (httpClient != null) {
        httpClient.getHttpConnectionManager().closeIdleConnections(0);
    }
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>重构之后：</p>

<p>{% codeblock lang:java %}
public boolean uploadToICR(String username, String password, ICRUploadDTO udto) throws ICRClientException {</p>

<pre><code>HttpClient httpClient = new HttpClient();
PostMethod post = null;
//some code here
…
} finally {
    if (post != null) {
        post.releaseConnection();
    }
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p><strong>代码复杂度变化：原来是1，修改后为0。</strong></p>

<h2>读取IO流的方法，为什么要自己实现？</h2>

<p>{% codeblock lang:java %}
private byte[] readData(InputStream ins) throws IOException {</p>

<pre><code>byte[] buf = new byte[2048];
int count = 0;
int len = 0;
byte data[] = new byte[2048];
byte[] result = null;
try {
    while ((len = ins.read(data, 0, 2048)) != -1) {
        int newcount = count + len;
        if (newcount &gt; buf.length) {
            byte newbuf[] = new byte[Math
                    .max(buf.length &lt;&lt; 1, newcount)];
            System.arraycopy(buf, 0, newbuf, 0, count);
            buf = newbuf;
        }
        System.arraycopy(data, 0, buf, count, len);
        count = newcount;
    }
    result = new byte[count];
    System.arraycopy(buf, 0, result, 0, count);

} finally {
    ins.close();
}
return result;
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>在原代码里面自己实现了一个对读取IO流字节的方法，这个可以使用apache-io或者guava的API代替：</p>

<p>{% codeblock lang:java %}
//使用apache io API的实现：
byte[] bytes = IOUtils.toByteArray(inputStream);
//使用guava API的实现：
byte[] bytes1 = ByteStreams.toByteArray(inputStream);
{% endcodeblock %}</p>

<p><strong>代码复杂度变化：原来是很多，修改后为0。</strong></p>

<p>最终重构后的版本见<strong><a href="https://github.com/zhaozhiming/zhaozhiming.github.com/blob/source/source/file/SomeClient(new).java">这里</a></strong>，最后的代码复杂度从原来的30降到了3。<br/>
代码写的比较仓促，没有写单元测试，其实最好的做法是在重构之前先写好单元测试，然后再慢慢修改原来的代码，每修改一处地方跑一遍单元测试，这样可以保证你的重构没有破坏原来的代码逻辑。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[for循环重复代码的重构]]></title>
    <link href="http://zhaozhiming.github.io/blog/2012/06/16/refactor-code-in-loop-block/"/>
    <updated>2012-06-16T16:39:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2012/06/16/refactor-code-in-loop-block</id>
    <content type="html"><![CDATA[<p><strong>DRY（don&rsquo;t repeat yourself）</strong>，重复往往是代码腐烂的开始，我们一般的处理手法是将重复的代码提取成一个方法，然后用新方法替换掉原来的代码。</p>

<!--more-->


<p>
但是对于for循环里面的重复代码要如何处理呢？比如有下面2个方法：</p>

<p>{% codeblock A.class lang:java %}</p>

<pre><code>public boolean methodA(List&lt;String&gt; list) {
    for(String string : list) {
        if (string.startWith("A")) {
            return true;
        } 
    }
    return false;
}

public boolean methodB(List&lt;String&gt; list) {
    for(String string : list) {
        if (string.endWith("B")) {
            return true;
        } 
    }
    return false;
}
</code></pre>

<p>{% endcodeblock %}</p>

<p>2个方法极其相似，唯一不同的地方只有 if 里面的判断条件。要如何去除这里的重复呢？提取for里面的代码？虽然能去除一部分，但for这个循环体的代码不能一起去掉，而且要是for里面的代码复杂一点，这个方法就不适用了。我今天想介绍自己最近用的比较多的一种重构手法：<strong>用模板方法去除for循环的重复代码。</strong></p>

<p>模板方法大家都知道，我可以先建1个抽象类和2个子类要代替这2个方法，但在java1.5+以后，我们可以用enum（枚举）来轻易实现模板方法。重构后的代码如下：</p>

<p>{% codeblock For.class lang:java %}
enum For {</p>

<pre><code>    METHOD_A {
        @Override
        protected boolean match(String string) {
            return string.startsWith("A");
        }
    }, METHOD_B {
        @Override
        protected boolean match(String string) {
            return string.endsWith("B");
        }
    };

    public boolean method(List&lt;String&gt; list) {
        for(String string : list) {
            if(match(string)) {
                return true;
            }
        }
        return false;
    }

    protected abstract boolean match(String string);
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>这里将相同的代码写成一个公共方法，不同的代码提取成一个抽象方法，让子类去具体实现。这样就实现了相同代码和不同代码的分离了。由于使用了enum，使得我们的创建类的代价为最小，只需一个enum类就搞定整个模板方法。</p>

<p>这里只是抛砖引玉，我相信肯定其他人一定还有更好的方法，希望和大家一起共同探讨。</p>
]]></content>
  </entry>
  
</feed>
