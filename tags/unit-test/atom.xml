<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: unit test | Hacker and Geeker's Way]]></title>
  <link href="http://zhaozhiming.github.io/tags/unit-test/atom.xml" rel="self"/>
  <link href="http://zhaozhiming.github.io/"/>
  <updated>2015-09-23T11:45:18+08:00</updated>
  <id>http://zhaozhiming.github.io/</id>
  <author>
    <name><![CDATA[赵芝明]]></name>
    <email><![CDATA[kingzzm1982@sina.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[基于Spring MVC做单元测试（二）——使用JMockit]]></title>
    <link href="http://zhaozhiming.github.io/blog/2014/06/17/spring-mvc-unit-test-part-2/"/>
    <updated>2014-06-17T12:24:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2014/06/17/spring-mvc-unit-test-part-2</id>
    <content type="html"><![CDATA[<p>上一篇Post讲了如何使用Spring的Test框架来进行单元测试，但在运行单元测试的时候有一个问题，就是每次跑单元测试都需要加载一下配置文件，或者启动web容器，这样的单元测试跑起来就不能达到快的目的。下面再介绍一下通过JMockit这个Java Mock工具来进行spring的单元测试，其特点是不需指定spring的配置文件，任何对象都可以mock出来并进行关联。</p>

<!--more-->


<p></p>

<h2>Controller</h2>

<p>首先我们还是来看一下使用了JMockit的Controller单元测试是怎么写的，Controller的功能代码可以查看上一篇post。</p>

<p>{% codeblock lang:java %}
import com.odde.mail.model.Result;
import com.odde.mail.service.MailService;
import mockit.Expectations;
import mockit.Injectable;
import mockit.Tested;
import mockit.integration.junit4.JMockit;
import org.junit.Test;
import org.junit.runner.RunWith;</p>

<p>import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.assertThat;</p>

<p>@RunWith(JMockit.class)
public class MailControllerTest {</p>

<pre><code>@Tested
MailController mailController;

@Injectable
private MailService mailService;

@Test
public void should_return_status_success_when_send_mail_success() throws Exception {
    new Expectations() { {
        mailService.send("test@test.com", "test", "test");
        result = new Result("成功");
    } };

    String result = mailController.send("test@test.com", "test", "test");

    assertThat(result, is("{\"status\":\"成功\"}"));
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<ul>
<li>@RunWith(JMockit.class): 指定单元测试的执行类为JMockit.class;</li>
<li>@Tested: 这个Annotate是指被测试类，在这个测试案例中我们要测试的是MailController，所以我们给其打上这个标签;</li>
<li>@Injectable: 这个Annotate可以将对象进行mock并自动关联到被测试类，而不需要通过其他文件类似spring的配置文件等来进行关联;</li>
<li>@Expectations: mock对象mailService的send方法，让其返回一个Result对象;</li>
</ul>


<p>做完上面这些基本就可以了，后面的被测方法调用和验证都跟原来的一样。这样看起来是不是比原来的单元测试代码少了一些，也更简洁了一些，最重要的一点是这样的单元测试不依赖spring的bean定义文件，不需要启动web服务，执行起来速度很快。</p>

<h2>Service</h2>

<p>再来看一下Service的单元测试要怎么改写，同样Service的功能代码可以看上一篇Post。</p>

<p>{% codeblock lang:java %}
import com.odde.mail.model.Recipient;
import com.odde.mail.model.Result;
import com.odde.mail.repo.RecipientRepository;
import mockit.Injectable;
import mockit.NonStrictExpectations;
import mockit.Tested;
import mockit.integration.junit4.JMockit;
import org.junit.Test;
import org.junit.runner.RunWith;</p>

<p>import java.util.List;</p>

<p>import static java.util.Arrays.asList;
import static org.hamcrest.core.Is.is;
import static org.junit.Assert.assertThat;</p>

<p>@RunWith(JMockit.class)
public class RecipientServiceTest {</p>

<pre><code>@Tested
private RecipientService recipientService;

@Injectable
private RecipientRepository recipientRepository;

@Test
public void should_return_success_when_add_recipient_not_exist() throws Exception {
    Result result = recipientService.add("Tom", "test@test.com");
    assertThat(result.getStatus(), is("成功"));
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>相对Controller Test这里少了一步对recipientRepository对象findByEmail方法的mock，因为如果不通过Expectations进行方法mock的话，方法会默认返回null，而我们要测试的场景正是需要findByEmail方法返回null，所以mock方法这一步我们也省了。<br/>
改写后的整体代码也比原来的少了很多，而且速度更快。</p>

<h2>适当使用Mock框架</h2>

<p>JMockit功能非常强大，不仅可以轻松处理上面的这些测试场景，还可以对static,final,private等方法进行mock，可以让你的单元测试毫无阻碍的进行。<br/>
但是如果过度的使用Mock框架，会让功能代码的坏味道被掩盖。本来单元测试的设计可以让你发现功能代码上的一些设计是否合理，比如有没有紧耦合等，但使用JMockit可以让你在设计不合理的代码上也可以轻松地进行单元测试，这样你就很难发现功能代码上的问题了。<br/>
所以建议JMockit等类似的mock框架还是要谨慎使用，首先要保证功能代码设计合理，满足面向对象设计的要求，再来考虑提高单元测试效率的问题。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基于Spring MVC做单元测试（一）——使用Spring Test框架]]></title>
    <link href="http://zhaozhiming.github.io/blog/2014/06/16/spring-mvc-unit-test-part-1/"/>
    <updated>2014-06-16T10:54:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2014/06/16/spring-mvc-unit-test-part-1</id>
    <content type="html"><![CDATA[<p>最近用Spring Mvc框架做了几个小项目，但都没有做单元测试，最近想恶补一下这方面的东西，包括基于Spring的单元测试，自动化测试和JS单元测试。今天先讲一下基于Spring框架的单元测试，测试使用的是Spring自带的test组件，再结合Mockito一起编写测试案例，以下示例会包括Controller和Service，由于Repository是基于Spring JPA，没有自己的逻辑，所以这里就不涉及Repository的单元测试，以后有需要再介绍。</p>

<!--more-->


<p></p>

<h2>Controller</h2>

<p>首先看一下Controller的代码（如下），代码比较简单，就是接收前端发过来的一些参数，通过这些参数直接调用Service的方法。</p>

<p>{% codeblock lang:java %}
import com.odde.mail.model.Result;
import com.odde.mail.service.MailService;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.codehaus.jackson.map.ObjectMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;</p>

<p>import static java.lang.String.format;</p>

<p>@Controller
@RequestMapping(&ldquo;/mail&rdquo;)
public class MailController {</p>

<pre><code>private static final Log log = LogFactory.getLog(MailController.class);
private final ObjectMapper mapper = new ObjectMapper();

@Autowired
private MailService mailService;

@RequestMapping(value = "/send", method = RequestMethod.POST, produces = "text/plain;charset=UTF-8")
public
@ResponseBody
String send(@RequestParam("recipients") String recipients,
            @RequestParam("subject") String subject,
            @RequestParam("content") String content) throws Exception {
    log.debug("mail controller send start");
    log.debug(format("recipients:%s", recipients));
    log.debug(format("subject:%s", subject));
    log.debug(format("content:%s", content));
    Result mailResult = mailService.send(recipients, subject, content);
    String result = mapper.writeValueAsString(mailResult);
    log.debug(format("result:%s", result));
    log.debug("mail controller send finish");
    return result;
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>再来看对应的单元测试:</p>

<p>{% codeblock lang:java %}
import com.odde.mail.model.Result;
import com.odde.mail.service.MailService;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.web.WebAppConfiguration;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;</p>

<p>import static org.hamcrest.CoreMatchers.is;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;</p>

<p>@RunWith(SpringJUnit4ClassRunner.class)
@WebAppConfiguration
@ContextConfiguration(&ldquo;file:src/main/webapp/WEB-INF/mvc-dispatcher-servlet.xml&rdquo;)
public class MailControllerTest {</p>

<pre><code>private MockMvc mockMvc;

@Mock
private MailService mailService;

@InjectMocks
MailController mailController;

@Before
public void setup() {
    MockitoAnnotations.initMocks(this);
    this.mockMvc = MockMvcBuilders.standaloneSetup(mailController).build();
}

@Test
public void should_return_status_success_when_send_mail_success() throws Exception {
    when(mailService.send("test@test.com", "test", "test")).thenReturn(new Result("成功"));

    mockMvc.perform(post("/mail/send")
            .param("recipients", "test@test.com")
            .param("subject", "test")
            .param("content", "test"))
            .andDo(print())
            .andExpect(status().isOk()).andExpect(content().string(is("{\"status\":\"" + result + "\"}")));

    verify(mailService).send("test@test.com", "test", "test");
}
</code></pre>

<p>{% endcodeblock %}</p>

<h4>首先是Spring的几个Annotate</h4>

<ul>
<li>RunWith(SpringJUnit4ClassRunner.class): 表示使用Spring Test组件进行单元测试;</li>
<li>WebAppConfiguration: 使用这个Annotate会在跑单元测试的时候真实的启一个web服务，然后开始调用Controller的Rest API，待单元测试跑完之后再将web服务停掉;</li>
<li>ContextConfiguration: 指定Bean的配置文件信息，可以有多种方式，这个例子使用的是文件路径形式，如果有多个配置文件，可以将括号中的信息配置为一个字符串数组来表示;</li>
</ul>


<h4>然后是Mockito的Annotate</h4>

<ul>
<li>Mock: 如果该对象需要mock，则加上此Annotate;</li>
<li>InjectMocks: 使mock对象的使用类可以注入mock对象，在上面这个例子中，mock对象是MailService，使用了MailService的是MailController，所以在Controller加上该Annotate;</li>
</ul>


<h4>Setup方法</h4>

<ul>
<li><code>MockitoAnnotations.initMocks(this)</code>: 将打上Mockito标签的对象起作用，使得Mock的类被Mock，使用了Mock对象的类自动与Mock对象关联。</li>
<li><code>mockMvc</code>: 细心的朋友应该注意到了这个对象，这个对象是Controller单元测试的关键，它的初始化也是在setup方法里面。</li>
</ul>


<h4>Test Case</h4>

<ul>
<li>首先mock了MailService的send方法，让其返回一个成功的Result对象。</li>
<li><code>mockMvc.perform</code>: 发起一个http请求。</li>
<li><code>post(url)</code>: 表示一个post请求，url对应的是Controller中被测方法的Rest url。</li>
<li><code>param(key, value)</code>: 表示一个request parameter，方法参数是key和value。</li>
<li><code>andDo（print()）</code>: 表示打印出request和response的详细信息，便于调试。</li>
<li><code>andExpect（status().isOk()）</code>: 表示期望返回的Response Status是200。</li>
<li><code>andExpect（content().string(is（expectstring））</code>: 表示期望返回的Response Body内容是期望的字符串。</li>
</ul>


<p>使用print打印处理的信息类似下面显示的内容:
{% codeblock lang:xml %}
MockHttpServletRequest:</p>

<pre><code>     HTTP Method = POST
     Request URI = /mail/send
      Parameters = {recipients=[test@test.com], subject=[test], content=[test]}
         Headers = {}

         Handler:
            Type = com.odde.mail.controller.MailController
          Method = public java.lang.String com.odde.mail.controller.MailController.send(java.lang.String,java.lang.String,java.lang.String) throws java.lang.Exception

           Async:
</code></pre>

<p>   Was async started = false</p>

<pre><code>    Async result = null
</code></pre>

<p>  Resolved Exception:</p>

<pre><code>            Type = null

    ModelAndView:
       View name = null
            View = null
           Model = null

        FlashMap:
</code></pre>

<p>MockHttpServletResponse:</p>

<pre><code>          Status = 200
   Error message = null
         Headers = {Content-Type=[text/plain;charset=UTF-8], Content-Length=[19]}
    Content type = text/plain;charset=UTF-8
            Body = {"status":"成功"}
   Forwarded URL = null
  Redirected URL = null
         Cookies = []
</code></pre>

<p>{% endcodeblock %}</p>

<h2>Service</h2>

<p>照例我们先看一下Service的功能代码，代码也比较简单，就是调用Repository做一些增删改查的动作。</p>

<p>{% codeblock lang:java %}
import com.odde.mail.model.Recipient;
import com.odde.mail.model.Result;
import com.odde.mail.repo.RecipientRepository;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;</p>

<p>import java.util.List;</p>

<p>@Service
public class RecipientService {</p>

<pre><code>@Autowired
private RecipientRepository recipientRepository;

public Result add(String username, String email) {
    Recipient recipient = recipientRepository.findByEmail(email);
    Result result;
    if (recipient == null) {
        recipientRepository.save(new Recipient(username, email));
        result = new Result("成功");
    } else {
        result = new Result("失败");
    }
    return result;
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>再来看对应的测试代码:</p>

<p>{% codeblock lang:java %}
import com.odde.mail.model.Recipient;
import com.odde.mail.repo.RecipientRepository;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</p>

<p>import java.util.List;</p>

<p>import static java.util.Arrays.asList;
import static org.hamcrest.core.Is.is;
import static org.junit.Assert.assertThat;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyString;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;</p>

<p>@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(&ldquo;file:src/main/webapp/WEB-INF/mvc-dispatcher-servlet.xml&rdquo;)
public class RecipientServiceTest {</p>

<pre><code>@Mock
private RecipientRepository recipientRepository;

@InjectMocks
private RecipientService recipientService;

@Before
public void setup() {
    MockitoAnnotations.initMocks(this);
}

@Test
public void should_return_success_when_add_recipient_not_exist() throws Exception {
    when(recipientRepository.findByEmail(anyString())).thenReturn(null);
    when(recipientRepository.save(any(Recipient.class))).thenReturn(null);

    assertThat(recipientService.add("Tom", "test@test.com").getStatus(), is("成功"));
    verify(recipientRepository).findByEmail(anyString());
    verify(recipientRepository).save(any(Recipient.class));
}
</code></pre>

<p>{% endcodeblock %}</p>

<p>Service的单元测试就比较简单了，大部分内容都在Controller里面讲过，不同的地方就是Controller是使用mockMvc对象来模拟Controler的被测方法，而在Service的单元测试中则是直接调用Service的方法（比如上面例子中的findByEmail和add）。</p>

<h2>Reponsitory</h2>

<p>最后再说一下Reponsitory的单元测试，刚才讲过这里不涉及这块的介绍，因为Reponsitory没有具体的实现代码，基本上调用的是Spring JPA的功能。</p>

<p>{% codeblock lang:java %}
import com.odde.mail.model.Recipient;
import org.springframework.data.jpa.repository.JpaRepository;</p>

<p>public interface RecipientRepository extends JpaRepository&lt;Recipient, Long> {</p>

<pre><code>public Recipient findByEmail(String email);
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>如果你的项目里面有自定义的Reponsitory具体实现，则需要做单元测试，这个可以上网自行搜索相关资料。</p>
]]></content>
  </entry>
  
</feed>
