<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: enzyme | Hacker and Geeker's Way]]></title>
  <link href="http://zhaozhiming.github.io/tags/enzyme/atom.xml" rel="self"/>
  <link href="http://zhaozhiming.github.io/"/>
  <updated>2018-02-13T09:24:19+08:00</updated>
  <id>http://zhaozhiming.github.io/</id>
  <author>
    <name><![CDATA[赵芝明]]></name>
    <email><![CDATA[kingzzm1982@sina.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[如何运行 react16 之后测试]]></title>
    <link href="http://zhaozhiming.github.io/blog/2017/11/08/run-react-test-with-react-version-16/"/>
    <updated>2017-11-08T20:36:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2017/11/08/run-react-test-with-react-version-16</id>
    <content type="html"><![CDATA[<p>{% img /images/post/2017/11/react-test.png 400 300 %}</p>

<p>React 升级到版本 16 之后，各方面都有不少改进，最重要的是完全向后兼容，功能代码几乎不用怎么修改就可以使用新版本。但是测试代码就不一定了，如果你是使用 <code>enzyme</code> 跑测试的话，以前的测试可能会跑不起来，那么需要如何修改呢？下面我们就来看一下吧。</p>

<!--more-->


<h2>一个简单的测试用例</h2>

<p>让我们来看一个简单的测试，这里面用到了测试 React 组件时常用的 <code>enzyme</code> 包和一个将 <code>enzyme</code> 对象转成 json 的工具<code>enzyme-to-json</code>。</p>

<p>可以暂时不管该测试对应的功能代码是怎么样的，因为校验的结果是组件快照。</p>

<p>{% codeblock lang:js %}
// Demo.js
import React from &lsquo;react&rsquo;;</p>

<p>export default () => <div>Hello World</div>;</p>

<p>// Demo.test.js
import React from &lsquo;react&rsquo;;
import { shallow } from &lsquo;enzyme&rsquo;;
import toJson from &lsquo;enzyme-to-json&rsquo;;
import Demo from &lsquo;./Demo&rsquo;;</p>

<p>describe(&lsquo;Demo Component&rsquo;, () => {
  it(&lsquo;should render correctly&rsquo;, () => {</p>

<pre><code>const wrapper = shallow(&lt;Demo /&gt;);
expect(toJson(wrapper)).toMatchSnapshot();
</code></pre>

<p>  });
});</p>

<p>{% endcodeblock %}</p>

<h2>React16 之前</h2>

<p>在升级 React16 之前，我们依赖的第三方库版本如下，跑这个测试是完全没有问题的。</p>

<ul>
<li>react: 15.4.2</li>
<li>react-dom: 15.4.2</li>
<li>enzyme: 2.8.2</li>
<li>enzyme-to-json: 1.5.1</li>
<li>react-addons-test-utils: 15.4.2</li>
</ul>


<p>{% codeblock lang:bash %}
PASS  src/Demo.test.js
  Demo Component</p>

<pre><code>✓ should render correctly (12ms)
</code></pre>

<p>Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Snapshots:   1 passed, 1 total
{% endcodeblock %}</p>

<h2>React16 之后</h2>

<p>但是升级 React16 之后，这个测试就跑不过了，报以下的错误：</p>

<ul>
<li>react: 15.4.2 => 16.0.0</li>
<li>react-dom: 15.4.2 => 16.0.0</li>
</ul>


<p>{% codeblock lang:bash %}
FAIL  src/Demo.test.js
  ● Test suite failed to run</p>

<pre><code>Cannot find module 'react-dom/lib/ReactTestUtils' from 'index.js'

  at Resolver.resolveModule (node_modules/jest-resolve/build/index.js:179:17)
  at Object.&lt;anonymous&gt; (node_modules/react-addons-test-utils/index.js:1:107)
</code></pre>

<p>Test Suites: 1 failed, 1 total
Tests:       0 total
Snapshots:   0 total
{% endcodeblock %}</p>

<h2>enzyme 的版本升级</h2>

<p>通过报错信息可以发现 React 的一些测试 API 发生了变化，那要如何修正呢？其实在 React 升级到版本 16 以后，<code>enzyme</code> 也对自身做了一次大的重构，我们来看看要怎么使用重构后的<code>enzyme</code>。</p>

<ul>
<li>首先升级 <code>enzyme</code> 的版本到最新版本</li>
<li>然后再安装 <code>enzyme-adapter-react-16</code> 这个包（待会讲这个包是做什么的），原来的 <code>react-addons-test-utils</code> 包可以删掉，新版的 <code>enzyme</code> 已经不需要了</li>
<li>最后在测试的全局配置中增加以下代码（如果是用 <code>create-react-app</code> 创建项目的话，可以在 <code>src/setupTests.js</code>里面修改）</li>
</ul>


<p>{% codeblock lang:js %}
import Enzyme from &lsquo;enzyme&rsquo;;
import Adapter from &lsquo;enzyme-adapter-react-16&rsquo;;</p>

<p>Enzyme.configure({ adapter: new Adapter() });
{% endcodeblock %}</p>

<p>OK！原来的测试通过了！</p>

<p>新版的<code>enzyme</code> 拆分出来了多个 adapter 包，用来支持多种 React 版本，下面是版本对照表：</p>

<table>
<thead>
<tr>
<th></th>
<th align="center"> Enzyme Adapter Package </th>
<th align="center"> React semver compatibility </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="center"> <code>enzyme-adapter-react-16</code> </td>
<td align="center"> <code>^16.0.0</code></td>
</tr>
<tr>
<td></td>
<td align="center"> <code>enzyme-adapter-react-15</code> </td>
<td align="center"> <code>^15.5.0</code></td>
</tr>
<tr>
<td></td>
<td align="center"> <code>enzyme-adapter-react-15.4</code> </td>
<td align="center"> <code>15.0.0-0 - 15.4.x</code></td>
</tr>
<tr>
<td></td>
<td align="center"> <code>enzyme-adapter-react-14</code> </td>
<td align="center"> <code>^0.14.0</code></td>
</tr>
<tr>
<td></td>
<td align="center"> <code>enzyme-adapter-react-13</code> </td>
<td align="center"> <code>^0.13.0</code></td>
</tr>
</tbody>
</table>


<h2>疑难问题</h2>

<p>虽然测试现在已经跑通了，但是你可能会遇到下面这个警告：</p>

<p>{% codeblock lang:bash %}
console.error node_modules/fbjs/lib/warning.js:33</p>

<pre><code>Warning: React depends on requestAnimationFrame. Make sure that you load a polyfill in older browsers. http://fb.me/react-polyfills
</code></pre>

<p> PASS  src/Demo.test.js
  Demo Component</p>

<pre><code>✓ should render correctly (8ms)
</code></pre>

<p>Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Snapshots:   1 passed, 1 total
{% endcodeblock %}</p>

<p>原因是测试用到的<code>jsdom</code> 包还没有提供<code>requestAnimationFrame</code>，所以会报这个警告。</p>

<p>具体内容可以看<a href="https://github.com/facebookincubator/create-react-app/issues/3199">这个 ISSUE</a>，<code>create-react-app</code>已经做了相应的修复，修改内容可以看看<a href="https://github.com/facebookincubator/create-react-app/pull/3340">这个 PR</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用AVA和Enzyme测试React组件（三）]]></title>
    <link href="http://zhaozhiming.github.io/blog/2016/03/29/use-ava-and-enzyme-to-test-react-component-part3/"/>
    <updated>2016-03-29T20:42:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2016/03/29/use-ava-and-enzyme-to-test-react-component-part3</id>
    <content type="html"><![CDATA[<p>{% img /images/post/2016/03/react.png %}</p>

<p><strong>React组件的测试要点</strong>：React组件要怎么测试，有哪些需要注意的地方，今天我们通过一些例子来说明。</p>

<!--more-->


<p></p>

<h2>render逻辑的测试</h2>

<p>React中存在逻辑的地方有一部分是在render方法中，React通过props或state的值可以render出不同的页面，所以我们可以通过设置不同的props值来测试是否能render出我们期望的页面。比如有下面这样的一个组件：</p>

<p>{% codeblock lang:js %}
class Footer extends Component {
  renderFooterButtons(completedCount, clearCompleted) {</p>

<pre><code>// 测试点1
if (completedCount &gt; 0) {
  return (
    &lt;button className="clear-completed" onClick={ () =&gt; clearCompleted() }&gt;Clear completed&lt;/button&gt;
  );
}
</code></pre>

<p>  }</p>

<p>  render() {</p>

<pre><code>const { todos, actions, onShow } = this.props;
const { clearCompleted } = actions;
const activeCount = todos.reduce((count, todo) =&gt; todo.completed ? count : count + 1, 0);
const completedCount = todos.length - activeCount;
return (
  &lt;footer className="footer"&gt;
    &lt;span className="todo-count"&gt;&lt;strong&gt;{activeCount}&lt;/strong&gt; item left&lt;/span&gt;
    &lt;ul className="filters"&gt;
      // 测试点2
      {[SHOW_ALL, SHOW_ACTIVE, SHOW_COMPLETED].map(filter =&gt;
        &lt;li key={filter}&gt;
          &lt;a className={classnames({ selected: filter === this.props.filter })}
            style={{ cursor: 'pointer' }}
            onClick={ () =&gt; onShow(filter) }&gt;{FILTER_TITLES[filter]}&lt;/a&gt;
        &lt;/li&gt;
      )}
    &lt;/ul&gt;
    {this.renderFooterButtons(completedCount, clearCompleted)}
  &lt;/footer&gt;
);
</code></pre>

<p>  }
}
{% endcodeblock %}</p>

<p>可以看到这个组件其实是比较简单的，在一个<code>footer</code>标签里面有个<code>span</code>和一个<code>ul</code>，<code>ul</code>里面有一些<code>li</code>，最下面是个<code>button</code>。</p>

<ul>
<li>在最上面有一个render button的方法，这个方法存在逻辑判断，如果completedCount大于0，则render一个button出来，否则不render button，这里是我们第一个测试点。测试代码如下，分别测试render和不render的情况：</li>
</ul>


<p>{% codeblock lang:js %}
const props = {
  todos: [], // 空的数组
  actions: {</p>

<pre><code>clearCompleted: sinon.spy(), // mock方法
</code></pre>

<p>  },
  onShow: sinon.spy(), // mock方法
  filter: &lsquo;SHOW_ALL&rsquo;,
};</p>

<p>test(&lsquo;do not render button&rsquo;, t => {
  const wrapper = shallow(<Footer {...props} />);
  t.is(wrapper.find(&lsquo;button&rsquo;).length, 0);
});</p>

<p>test(&lsquo;render button correctly&rsquo;, t => {
  const wrapper = shallow(<Footer {...props} />);
  wrapper.setProps({ todos: [{ completed: true }] });
  t.is(wrapper.find(&lsquo;button&rsquo;).length, 1);
});
{% endcodeblock %}</p>

<p>要让completedCount不大于0，只要给个空的todos集合就可以了，如果要大于0的话，则需要在todos里面添加一个<code>completed</code>为true的对象，这里需要搞清楚completedCount的声明逻辑。</p>

<ul>
<li>第二个测试点是map方法里面的逻辑，因为是从一个有3个元素的数组里面做map，所以可以校验是否确实render出来3个<code>li</code>，以及其中某个<code>li</code>链接的class和文本内容。</li>
</ul>


<p>{% codeblock lang:js %}
test(&lsquo;render 3 li correctly&rsquo;, t => {
  const wrapper = shallow(<Footer {...props} />);
  wrapper.setProps({ todos: [{ completed: true }] });
  t.is(wrapper.find(&lsquo;li&rsquo;).length, 3);
  t.is(wrapper.find(&lsquo;a.selected&rsquo;).length, 1);
  t.is(wrapper.find(&lsquo;a.selected&rsquo;).text(), &lsquo;All&rsquo;);
});
{% endcodeblock %}</p>

<p>可以看到通过enzyme的text方法可以很方便地得到<code>a</code>标签的文本内容。</p>

<p>这个组件其实还继续做测试，比如<code>span</code>里面的render逻辑等，但这里就不详细举例了。</p>

<h2>组件的事件逻辑</h2>

<p>除了在render方法中有逻辑以外，在组件的事件中也会存在逻辑，要测试这部分代码，我们需要模拟触发组件的事件。请看下面这个组件：</p>

<p>{% codeblock lang:js %}
class TodoInput extends Component {
  constructor(props, context) {</p>

<pre><code>super(props, context);
this.state = {
  text: this.props.text || '',
};
</code></pre>

<p>  }</p>

<p>  handleChange(e) {</p>

<pre><code>this.setState({ text: e.target.value });
</code></pre>

<p>  }</p>

<p>  handleBlur(e) {</p>

<pre><code>if (!this.props.newTodo) {
  this.props.onSave(e.target.value.trim());
}
</code></pre>

<p>  }</p>

<p>  render() {</p>

<pre><code>return (
  &lt;input className={
    classnames({
      edit: this.props.editing,
      'new-todo': this.props.newTodo,
    })}
    type="text"
    placeholder={this.props.placeholder}
    autoFocus="true"
    value={this.state.text}
    onBlur={this.handleBlur.bind(this)}
    onChange={this.handleChange.bind(this)}
  /&gt;
);
</code></pre>

<p>  }
}
{% endcodeblock %}</p>

<p>可以看到这个组件的render方法里面没有什么逻辑，只有一个<code>input</code>标签，但是在标签中存在了<code>change</code>和<code>blur</code>事件，组件的逻辑隐藏在对应的事件方法中。</p>

<ul>
<li>首先是对<code>change</code>事件的测试，我们可以看到<code>handleChange</code>方法其实是修改state里面text的值，所以测试代码可以这样写：</li>
</ul>


<p>{% codeblock lang:js %}
const props = {
  text: &lsquo;foo&rsquo;,
  placeholder: &lsquo;foo placeholder&rsquo;,
  editing: false,
  newTodo: false,
  onSave: sinon.spy(),
};</p>

<p>test(&lsquo;input change value correctly&rsquo;, t => {
  const wrapper = shallow(<TodoInput {...props} />);
  wrapper.find(&lsquo;input&rsquo;).simulate(&lsquo;change&rsquo;, { target: { value: &lsquo;bar&rsquo; } });
  t.is(wrapper.state(&lsquo;text&rsquo;), &lsquo;bar&rsquo;);
});
{% endcodeblock %}</p>

<p>通过调用<code>simulate</code>方法对<code>change</code>事件进行模拟，然后调用<code>state</code>方法对组件的state进行校验。</p>

<ul>
<li>接着我们测试<code>blur</code>事件，<code>handleBlur</code>方法先做判断，如果为真则调用props中的<code>onSave</code>方法，我们可以用sinon来mock onSave方法，校验其调用次数。</li>
</ul>


<p>{% codeblock lang:js %}
test(&lsquo;input blur correctly&rsquo;, t => {
  const wrapper = shallow(<TodoInput {...props} />);
  wrapper.find(&lsquo;input&rsquo;).simulate(&lsquo;blur&rsquo;, { target: { value: &lsquo;bar&rsquo; } });
  t.is(props.onSave.callCount, 1);
{% endcodeblock %}</p>

<p>模拟事件触发的方法差不多，都是传入事件名和所需的方法对象就可以了，这里校验<code>onSave</code>是否被调用了1次。</p>

<p>在写单元测试的时候，有一点要注意的是要避免过度测试，因为测试代码也是需要维护的，如果测试过多过细，那一旦生产代码有所改变，就可能会修改很多测试代码，需要开发人员需要在质量和开发效率上面做好均衡。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用AVA和Enzyme测试React组件（二）]]></title>
    <link href="http://zhaozhiming.github.io/blog/2016/03/29/use-ava-and-enzyme-to-test-react-component-part2/"/>
    <updated>2016-03-29T20:42:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2016/03/29/use-ava-and-enzyme-to-test-react-component-part2</id>
    <content type="html"><![CDATA[<p>{% img /images/post/2016/03/airbnb.png 400 300 %}</p>

<p>Enzyme是<a href="http://www.airbnb.com/">Airbnb</a>公司推出的一个针对React组件的测试工具。Airbnb我觉得是国外继Google和Facebook之后技术实力十分强大的一家科技公司，有很多开源项目获得广大开发人员的认可，Enzyme就是其中的一个。</p>

<!--more-->


<p></p>

<h2>React的测试方式</h2>

<p>Facebook在推出React的时候也推出一个测试套件，可以使用shallow render（浅渲染）和renderIntoDocument（完整渲染）的方式对React组件进行渲染，然后通过查找DOM来做测试结果校验。两者的主要区别是shallow render只渲染出组件的第一层DOM，其嵌套的DOM不会渲染出来，这样渲染的效率更高，单元测试的速度更快，在做单元测试的时候建议使用shallow render的方式。</p>

<p>Enzyme对Facebook的测试套件做了封装，并提供了一套API来让开发者做React单元测试的时候更加方便，下面的例子可以对比使用了Enzyme前后的区别。</p>

<p>使用Enzyme前：<br/>
{% codeblock lang:js %}
const output = setup({&hellip;props});
const ul = output.props.children;
const li = ul.props.children;
const a = li.props.children;
express(a.size).to.be.equal(1);
{% endcodeblock %}</p>

<p>使用Enzyme后：<br/>
{% codeblock lang:js %}
const wrapper = shallow(<Foo {...props} />);
express(wrapper.find(&lsquo;a&rsquo;).length).to.be.equal(1);
{% endcodeblock %}</p>

<p>最明显的变化是测试代码变少了，原来需要逐层查找DOM，现在只需要一个<code>find()</code>方法就可以搞定。</p>

<h2>Shallow Rendering &amp; Full DOM Rendering</h2>

<p>Enzyme针对这两种渲染方式都提供了各自一套API方法，但其实这2套API的方法差不多相同，只有个别方法不一样。</p>

<p>{% codeblock lang:js %}
.find(selector) => ShallowWrapper
.children() => ShallowWrapper
.parent() => ShallowWrapper
.closest(selector) => ShallowWrapper
.unmount() => ShallowWrapper
.text() => String
.state([key]) => Any
.simulate(event[, data]) => ShallowWrapper
.setState(nextState) => ShallowWrapper
.setProps(nextProps) => ShallowWrapper
.debug() => String
{% endcodeblock %}</p>

<p>这里只列出了一小部分API，不但可以通过find方法查找DOM元素，还可以模拟DOM的事件，比如Click，Change等。</p>

<h2>常用的方法</h2>

<ul>
<li>find方法</li>
</ul>


<p>find方法可以让你方便的查找到DOM元素，支持通过class名称查找，html标签查找，id查找，甚至是自定义组件的查找等。</p>

<p>{% codeblock lang:js %}
const wrapper = shallow(<MyComponent />);
expect(wrapper.find(&lsquo;.foo&rsquo;)).to.have.length(1);
// compound selector
expect(wrapper.find(&lsquo;div.some-class&rsquo;)).to.have.length(3);
// CSS id selector
expect(wrapper.find(&lsquo;#foo&rsquo;)).to.have.length(1);
// Component
expect(wrapper.find(Foo)).to.have.length(1);
{% endcodeblock %}</p>

<ul>
<li>simulate方法</li>
</ul>


<p>simulate方法让你可以模拟DOM元素的事件，传入参数是事件名和事件参数。</p>

<p>{% codeblock lang:js %}
const wrapper = shallow(<MyComponent />);
wrapper.find(&lsquo;a&rsquo;).simulate(&lsquo;click&rsquo;);
wrapper.find(&lsquo;a&rsquo;).simulate(&lsquo;change&rsquo;, { target: { value: &lsquo;foo&rsquo; } });
{% endcodeblock %}</p>

<ul>
<li>debug方法</li>
</ul>


<p>debug方法可以让你打印出组件的DOM信息，方便测试遇到问题进行调试。</p>

<p>{% codeblock lang:js %}
const wrapper = shallow(<Book title="Huckleberry Finn" />);
console.log(wrapper.debug());</p>

<p>Outputs to console:</p>

<div>
 <h1 className="title">Huckleberry Finn</h1>
</div>


<p>{% endcodeblock %}</p>

<ul>
<li>props和state等方法</li>
</ul>


<p>对应React组件的props和state，Enzyme也有一些方法可以让你set和get其中的值，对于重置React组件的状态非常有用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用AVA和Enzyme测试React组件（一）]]></title>
    <link href="http://zhaozhiming.github.io/blog/2016/03/28/use-ava-and-enzyme-to-test-react-component-part1/"/>
    <updated>2016-03-28T20:20:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2016/03/28/use-ava-and-enzyme-to-test-react-component-part1</id>
    <content type="html"><![CDATA[<p>{% img /images/post/2016/03/ava.png 400 300 %}</p>

<p>React的出现让页面的测试发生了变化，原来一些耗时耗性能的自动化测试可以转化成快速的单元测试，今天介绍一下如何做React的单元测试，以及AVA和Enzyme的使用。</p>

<!--more-->


<p></p>

<h2><a href="https://github.com/sindresorhus/ava">AVA</a>是什么</h2>

<p>AVA是一个JS的单元测试框架，与其他测试框架相比最大的特点是可以并发运行测试，并行地执行每个测试文件，让CPU的利用率达到最大化。有个项目使用AVA让单元测试的执行时间从31秒（原来是用Mocha）下降到11秒。另外AVA的团队也是几个开源社区的大神，为首的<a href="https://github.com/sindresorhus">sindresorhus</a>是github上获得星星最多的人。</p>

<h2>为什么选择AVA</h2>

<p>前端也有很多不错的测试框架，比如<a href="https://github.com/mochajs/mocha">Mocha</a>、<a href="https://testanything.org/">Tap</a>和<a href="https://github.com/substack/tape">Tape</a>等，但AVA这个后起之秀是青出于蓝而胜于蓝，除了上面说的并发测试这个优点外，还有配置简单，多种报告，环境隔离等优点。Mocha的作者<a href="https://github.com/tj">TJ</a>也是个牛人，他对AVA推崇有加，说如果让他来重新开发Mocha的话他也会按照AVA这种思路来做。</p>

<h2>AVA的语法</h2>

<p>{% codeblock lang:js %}
import test from &lsquo;ava&rsquo;;</p>

<p>test(&lsquo;my first test&rsquo;, t => {
  t.same([1, 2], [1, 2]);
});
{% endcodeblock %}</p>

<p>test方法可以带一个字符串的标题和一个回调函数，这个回调函数就是你的测试代码，使用过其他测试框架的开发人员可以很快熟悉它的API并写出自己的测试。</p>

<h2>AVA的配置</h2>

<p>AVA的配置也十分简单，虽然Mocha的配置也不复杂，但相对于后者AVA的配置特点是灵活和集中，你可以用多种方式来配置AVA，就拿配置Babel来说，你可以将Babel配置一起写在<code>package.json</code>里面，也可以将Babel配置写在原来的Babel配置文件中，而在<code>package.json</code>文件里面写上<code>babel: inherit</code>的配置就可以了。</p>

<p>{% codeblock lang:json %}
{
  &ldquo;babel&rdquo;: {</p>

<pre><code>"presets": [
  "es2015",
  "stage-0",
  "react"
]
</code></pre>

<p>  },
  &ldquo;ava&rdquo;: {</p>

<pre><code>"babel": "inherit",
</code></pre>

<p>  },
}
{% endcodeblock %}</p>

<h2>AVA的断言</h2>

<p>AVA内置了断言库，几个常用的断言方法已经可以满足大部分的断言需求，无需再用其他的断言库。</p>

<p>{% codeblock lang:js %}
.pass([message])
.fail([message])
.ok(value, [message])
.notOk(value, [message])
.true(value, [message])
.false(value, [message])
.is(value, expected, [message])
.not(value, expected, [message])
.same(value, expected, [message])
.notSame(value, expected, [message])
.throws(function|promise, [error, [message]])
.notThrows(function|promise, [message])
.regex(contents, regex, [message])
.ifError(error, [message])
{% endcodeblock %}</p>

<p>当然你也可以集成其他的第三方断言库，比如<a href="http://chaijs.com/">chai</a>，但这样的话你可能就使用不到测试方法中<code>t</code>这个测试对象了。</p>

<p>{% codeblock lang:js %}
import { exppect } from &lsquo;chai&rsquo;;
import test from &lsquo;ava&rsquo;;</p>

<p>test(&lsquo;my first test&rsquo;, t => {
  expect([1, 2]).to.deep.equal([1, 2]);
});
{% endcodeblock %}</p>

<h2>AVA的多种支持</h2>

<ul>
<li>支持Promise</li>
</ul>


<p>{% codeblock lang:js %}
test(t => {
  return somePromise().then(result => {</p>

<pre><code>t.is(result, 'unicorn');
</code></pre>

<p>  });
});
{% endcodeblock %}</p>

<ul>
<li>支持Async</li>
</ul>


<p>{% codeblock lang:js %}
test(async t => {
  const value = await promiseFn();
  t.true(value);
});
{% endcodeblock %}</p>

<ul>
<li>支持Callback</li>
</ul>


<p>{% codeblock lang:js %}
test.cb(t => {
  fs.readFile(&lsquo;data.txt&rsquo;, t.end);
});
{% endcodeblock %}</p>

<p>现在有了async和promise一般不推荐再使用callback，AVA的callback支持是为了方便测试使用了callback的遗留代码。<br/>
<strong>注意，测试callback需要调用<code>t.end</code>方法来结束测试。</strong></p>

<h2>隔离环境</h2>

<p>AVA会为每个测试环境单独启动一个进程来跑测试，这样的好处就保证了每个测试文件的环境不会受到其他测试文件的影响，也要求你写测试的时候更注重原子性，要求测试不依赖其他测试的运行结果或者测试数据，让测试具有独立性。</p>

<p>但并发测试也会带来一些测试方法上的改变，比如说以前串行测试要测试文件的IO操作，可能会临时创建一个文件来进行读写，串行测试时由于每个测试都是顺序进行的，所以只需要一个文件就可以满足需求。但如果是并发测试，一个临时文件可能会被多个测试同时进行读写，这样就会导致冲突，最好的做法是为每个测试都单独创建一个临时文件来做测试。</p>
]]></content>
  </entry>
  
</feed>
