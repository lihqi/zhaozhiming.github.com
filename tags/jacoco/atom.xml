<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: jacoco | Hacker and Geeker's Way]]></title>
  <link href="http://zhaozhiming.github.io/tags/jacoco/atom.xml" rel="self"/>
  <link href="http://zhaozhiming.github.io/"/>
  <updated>2018-02-13T09:24:19+08:00</updated>
  <id>http://zhaozhiming.github.io/</id>
  <author>
    <name><![CDATA[赵芝明]]></name>
    <email><![CDATA[kingzzm1982@sina.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Jacoco的原理]]></title>
    <link href="http://zhaozhiming.github.io/blog/2012/12/07/the-elements-of-jacoco/"/>
    <updated>2012-12-07T19:47:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2012/12/07/the-elements-of-jacoco</id>
    <content type="html"><![CDATA[<h2>覆盖率计数器</h2>

<p>Jacoco使用一系列的不同的计数器来做覆盖率的度量计算。所有这些计数器都是从java的class文件中获取信息，这些class文件可以（可选）包含调试的信息在里面。即使在没有源码的情况下，这种方法也可以实时有效地对应用程序进行度量和分析。在大部分情况下，收集到的信息可以映射到源码，可视化到每一行代码的粒度。但这种方法还是有一些限制。这些class文件必须使用调试信息来编译，这样才可以计算行的覆盖率和提供出源码的高亮。但不是所有的JAVA语言的结构都可以直接编译成一致的二进制代码。在这种情况下，java 编译器会创建所谓的“合成”代码，会导致产生一些不期望得到的覆盖率结果。</p>

<!--more-->


<p></p>

<h4>指令（C0 Coverage）</h4>

<p>Jacoco最小的计数单元是单个java二进制代码指令。指令覆盖率提供了代码是否被执行的信息。这个度量完全独立源码格式，并且总是可用，即使class文件里面没有调试信息。</p>

<h4>分支（C1 Coverage）</h4>

<p>Jacoco也计算分支的覆盖率，包括所有的if和switch语句。这个度量计算一个方法里面的总分支数，确定执行和不执行的分支数量。分支覆盖率总是可用的，即使class文件里面没有调试信息。注意异常处理是不在分支度量里面统计的。</p>

<p>如果class文件使用调试信息编译的话，产生的覆盖率可以映射到源码行并且高亮提示：</p>

<ul>
<li>没有覆盖：在这一行中没有分支被执行（红色方块）</li>
<li>部分覆盖：这一行的分支中只有一部分被执行（黄色方块）</li>
<li>完全覆盖：这一行的所有分支都被执行（绿色方块）</li>
</ul>


<h4>圈复杂度</h4>

<p>Jacoco同样可以为每一个非抽象方法计算复杂度，最终计算出类、包和组的复杂度。根据由McCabe1996圈复杂度的定义是，在（线性）组合中，计算在一个方法里面所有可能路径的最小数目。所以复杂度可以作为度量单元测试是否有完全覆盖所有场景的一个依据。复杂度即使是在没有调试信息的情况下也可以计算。</p>

<p>圈复杂度V（G）的正式定义是基于方法的控制流图的有向图表示：</p>

<p>v(G) = E &ndash; N + 2</p>

<p>E是边界的数量，N是节点的数量。Jacoco 基于下面的方程来计算复杂度，B是分支的数量，D是决策点的数量：</p>

<p>v(G) = B &ndash; D + 1</p>

<p>基于每个分支的被覆盖情况，Jacoco也为每个方法计算覆盖和缺失的复杂度。缺失的复杂度同样表示测试案例没有完全覆盖到这个模块。注意Jacoco不将异常处理作为分支，try/catch块也同样不增加复杂度。</p>

<h4>行</h4>

<p>所有的class文件使用debug信息编译之后，就可以计算行的覆盖率信息。一行源代码是否被执行，要看这一行中是否至少有一个指令被执行。</p>

<p>由于实际上一行代码一般被编译成多个二进制代码指令，这样源码在高亮显示时，会显示成3种不同的状态：</p>

<ul>
<li>没有覆盖：这一行中没有指令被执行（红色背景）</li>
<li>部分覆盖：这一行中只有一部分指令被执行（黄色背景）</li>
<li>完全覆盖：这一行中所有指令都被覆盖（绿色背景</li>
</ul>


<h4>方法</h4>

<p>每一个非抽象方法至少包含一个指令。一个方法是否执行取决于方法中是否有至少一个指令被执行。在Jacoco中，构造器和静态初始化同样会像方法一样统计。其中一些方法可能没有可以直接对应的源码，比如默认构造器或常量的初始化命令。</p>

<h4>类</h4>

<p>一个方法是否执行取决于类中是否有至少一个方法被执行。注意Jacoco认为构造器和静态初始化都是方法。Java的接口一般包含静态初始化，所以接口也同样被认为是可执行的类。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在jenkins和sonar中集成jacoco(四)--在sonar中集成jacoco]]></title>
    <link href="http://zhaozhiming.github.io/blog/2012/12/02/use-jacoco-in-jenkins-and-sonar-part-4/"/>
    <updated>2012-12-02T14:46:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2012/12/02/use-jacoco-in-jenkins-and-sonar-part-4</id>
    <content type="html"><![CDATA[<p>首先要得到之前的单元测试和集成测试的覆盖率文件，还有对应的class文件以及单元测试的覆盖率报告，材料准备齐全之后，使用如下命令：</p>

<!--more-->


<p>{% codeblock build.xml lang:xml %}
<taskdef uri="antlib:org.sonar.ant" resource="org/sonar/ant/antlib.xml"></p>

<pre><code>    &lt;classpath path="${env.SONAR-ANT-TASK.JAR}"/&gt;
&lt;/taskdef&gt;

&lt;target name="sonar"&gt;
    &lt;sonar:sonar key="${sonar.project.key}" version="${sonar.project.version}" xmlns:sonar="antlib:org.sonar.ant"&gt;
        &lt;sources&gt;
            &lt;path location="${src.dir}" /&gt;
        &lt;/sources&gt;

        &lt;property key="sonar.projectName" value="jacoco_demo" /&gt;
        &lt;property key="sonar.sourceEncoding" value="UTF-8" /&gt;
        &lt;property key="sonar.dynamicAnalysis" value="reuseReports" /&gt;
        &lt;property key="sonar.surefire.reportsPath" value="${junit.dir}" /&gt;
        &lt;property key="sonar.core.codeCoveragePlugin" value="jacoco" /&gt;
        &lt;property key="sonar.jacoco.reportPath" value="${basedir}/ut.exec" /&gt;
        &lt;property key="sonar.jacoco.itReportPath" value="${basedir}/uat.exec" /&gt;

        &lt;tests&gt;
            &lt;path location="${src.test.dir}" /&gt;
        &lt;/tests&gt;

        &lt;binaries&gt;
            &lt;path location="${build.src.class}" /&gt;
            &lt;path location="${build.test.class}" /&gt;
        &lt;/binaries&gt;

        &lt;libraries&gt;
            &lt;path location="${build.lib.dir}" /&gt;
        &lt;/libraries&gt;
    &lt;/sonar:sonar&gt;
&lt;/target&gt;
</code></pre>

<p>{% endcodeblock %}</p>

<p>参数解释：</p>

<ul>
<li>sonar.dynamicAnalysis是指单元测试报告的生成方式，值为reuseReports是指给出生成好的单元测试报告路径。</li>
<li>sonar.surefire.reportsPath是指单元测试报告的路径。</li>
<li>sonar.core.codeCoveragePlugin是覆盖率插件，有jacoco,cobetura等。</li>
<li>sonar.jacoco.reportPath是单元测试覆盖率文件的路径。</li>
<li>sonar.jacoco.itReportPath是集成测试覆盖率文件的路径。</li>
</ul>


<p>更多参数可以参考这里：<a href="http://docs.codehaus.org/display/SONAR/Code+Coverage+by+Unit+Tests">单元测试</a>，<a href="http://docs.codehaus.org/display/SONAR/Code+Coverage+by+Integration+Tests">集成测试</a><br/>
在sonar 3.3的版本会自动将单元测试和集成测试的覆盖率合并，最后附上sonar上的覆盖率显示：</p>

<p>{% img /images/post/2012112914305954.png %}<br/>
{% img /images/post/2012112914311753.png %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在jenkins和sonar中集成jacoco(三)--使用jacoco收集集成测试的覆盖率]]></title>
    <link href="http://zhaozhiming.github.io/blog/2012/12/01/use-jacoco-in-jenkins-and-sonar-part-3/"/>
    <updated>2012-12-01T14:45:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2012/12/01/use-jacoco-in-jenkins-and-sonar-part-3</id>
    <content type="html"><![CDATA[<p>我们系统使用weblogic做服务器，集成测试框架使用的是junit+selenium。</p>

<p>首先，要把jacoco的jacocoagent.jar包放到部署应用的服务器上，接着在系统服务的JAVA_OPTIONS 后面添加如下参数：</p>

<!--more-->


<p>
{% codeblock lang:sh %}
-javaagent:[yourpath/]jacocoagent.jar=includes=com.xxx.xxx.*,output=tcpserver,address=xxx.xxx.xxx.xxx,port=xxxxx
{% endcodeblock %}</p>

<p>参数解释：</p>

<ol>
<li>前面的yourpath是放jacocoagent.jar文件的目录路径；</li>
<li>includes是指要收集哪些类（注意不要关写包名，最后要写.*)，不写的话默认是*，会收集应用服务上所有的类，包括服务器和其他中间件的类，一般要过滤；</li>
<li>output有4个值，分别是file,tcpserver,tcpclient,mbean，默认是file。使用file的方式只有在停掉应用服务的时候才能产生覆盖率文件，而使用tcpserver的方式可以在不停止应用服务的情况下下载覆盖率文件，后面会介绍如何使用dump方法来得到覆盖率文件。</li>
<li>address是ip， port是端口，这是使用tcpserver方式需要的2个参数，也是后面dump方法要用到的。（这里的address我只能使用服务器的ip，如果使用其他ip，服务启动时会报错。）</li>
</ol>


<p>更多参数可以参考<a href="http://www.eclemma.org/jacoco/trunk/doc/agent.html">java agent</a>。<br/>
配置完应用服务的JAVA_OPTIONS之后，启动服务器，然后可以开始跑你的集成测试，跑完之后，实际上jacocoagent已经将覆盖率数据记录下来了，我们可以使用下面的ant任务来dump出覆盖率文件：</p>

<p>{% codeblock build.xml lang:xml %}
　 <target name="downloadUatCoverageData"></p>

<pre><code>    &lt;jacoco:dump address="xxx.xxx.xxx.xxx" port="xxxx" reset="true" destfile="${basedir}/uat.exec" append="false"/&gt;
&lt;/target&gt;
</code></pre>

<p>{% endcodeblock %}</p>

<p>这里的address和port是刚才在JAVA_OPTIONS里面写的address和port的值，destfile是指生成的覆盖率文件路径。</p>

<p><strong>注意，这里虽然得到了集成测试的覆盖率文件，但是需要应用服务器上的类文件才能产出相应的覆盖率报告，如果类文件是其他JVM编译的，产出的报告覆盖率是0%。</strong></p>

<p>有2种方法可以得到覆盖率文件所需的class文件：</p>

<ol>
<li>将应用服务部署的包（ear或war或jar）包下载下来之后解压，即可得到对应的class文件；</li>
<li>在前面做单元测试之后，可以将class文件打成一个zip包，然后上传到服务器，最后在需要的时候去服务器上取。</li>
</ol>


<p>得到集成测试的覆盖率文件之后，结合之前取到的单元测试覆盖率文件，我们可以将2个文件合并，得到综合的覆盖率文件，命令如下：</p>

<p>{% codeblock build.xml lang:xml %}
　<target name="mergeCoverage"></p>

<pre><code>    &lt;jacoco:merge destfile="merged.exec"&gt;
        &lt;fileset dir="${basedir}" includes="*.exec"/&gt;
    &lt;/jacoco:merge&gt;
</code></pre>

<p>   </target>
{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在jenkins和sonar中集成jacoco(二)--在jenkins中生成jacoco覆盖率报告]]></title>
    <link href="http://zhaozhiming.github.io/blog/2012/11/30/use-jacoco-in-jenkins-and-sonar-part-2/"/>
    <updated>2012-11-30T14:45:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2012/11/30/use-jacoco-in-jenkins-and-sonar-part-2</id>
    <content type="html"><![CDATA[<p>先要在jenkins上安装jacoco的插件，安装完成之后在job的配置项中可以增加这个选项：</p>

<!--more-->


<p>{% img /images/post/2012112911555041.png %}<br/>
{% img /images/post/2012112911561356.png %}</p>

<p>第一个录入框是你的覆盖率文件（exec），第二个是class文件目录，第三个是源代码文件目录。</p>

<p>配置好了之后进行构建，构建完成之后job首页就会出现覆盖率的趋势图，鼠标点击趋势图可以看到覆盖率详情，包括具体覆盖率数据和源码的覆盖率情况：</p>

<p>趋势图<br/>
{% img /images/post/2012112911373757.png 趋势图 %}</p>

<p>覆盖率详情  <br/>
{% img /images/post/2012112911394918.png 覆盖率详情 %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在jenkins和sonar中集成jacoco(一)--使用jacoco收集单元测试的覆盖率]]></title>
    <link href="http://zhaozhiming.github.io/blog/2012/11/29/use-jacoco-in-jenkins-and-sonar-part-1/"/>
    <updated>2012-11-29T14:45:00+08:00</updated>
    <id>http://zhaozhiming.github.io/blog/2012/11/29/use-jacoco-in-jenkins-and-sonar-part-1</id>
    <content type="html"><![CDATA[<p>之前系统的持续集成覆盖率工具使用的是cobetura，使用的过程中虽然没什么问题，但感觉配置比较麻烦，现在准备改用jacoco这个覆盖率工具来代替它。接下来我介绍一下jenkins配置jacoco，并且在sonar显示单元测试和集成测试覆盖率的过程。</p>

<p>用jacoco来实现单元测试的覆盖率比较简单，在ant脚本中先增加下面的任务：</p>

<!--more-->


<p>
{% codeblock build.xml lang:xml %}
<taskdef uri="antlib:org.jacoco.ant" resource="org/jacoco/ant/antlib.xml"></p>

<pre><code>    &lt;classpath path="${basedir}/jacoco_lib/jacocoant.jar" /&gt;
</code></pre>

<p></taskdef>
{% endcodeblock %}</p>

<p>这里要引入jacoco的jar包jacocoant.jar，增加了这个命令之后，将原有的单元测试任务用 jacoco:coverage包括起来，实例代码如下：</p>

<p>{% codeblock build.xml lang:xml %}
<target name="unitTest" depends="test_compile"></p>

<pre><code>    &lt;mkdir dir="${junit.dir}"/&gt;
    &lt;jacoco:coverage destfile="${basedir}/ut.exec"&gt;
        &lt;junit fork="true" forkmode="once" printsummary="on" failureproperty="unit.test.failure"&gt;
            &lt;classpath&gt;
                &lt;pathelement location="${build.class}"/&gt;
                &lt;fileset dir="${build.lib.dir}"/&gt;
            &lt;/classpath&gt;

            &lt;formatter type="xml"/&gt;
            &lt;batchtest todir="${junit.dir}"&gt;
                &lt;fileset dir="${src.test.dir}"&gt;
                    &lt;include name="**/*Test.java"/&gt;
                &lt;/fileset&gt;
            &lt;/batchtest&gt;
        &lt;/junit&gt;
    &lt;/jacoco:coverage&gt;
</code></pre>

<p>　　　　<!-- 其他内容 -->
</target>
{% endcodeblock %}</p>

<p>jacoco:coverage的destfile参数是指生成的覆盖率文件路径，不写默认文件名为jacoco.exec。另外在forkmode这个参数设置为once，可以提高你的单元测试的执行效率。</p>

<p>这样跑完单元测试后，就会在指定路径下生成覆盖率文件ut.exec（或默认的jacoco.exec，在工程根目录下）。</p>

<p>如果要在本地生成jacoco的覆盖率报告，可以增加如下任务：</p>

<p>{% codeblock build.xml lang:xml %}
<target name="jacocoReport"></p>

<pre><code>    &lt;delete dir="${basedir}/jacoco"/&gt;
    &lt;mkdir dir="${result.jacoco.report.dir}/ut"/&gt;
    &lt;jacoco:report&gt;
        &lt;executiondata&gt;
            &lt;file file="${basedir}/ut.exec"/&gt;
        &lt;/executiondata&gt;

        &lt;structure name="jacoco_demo"&gt;
            &lt;classfiles&gt;
                &lt;fileset dir="${build.dir}"/&gt;
            &lt;/classfiles&gt;
            &lt;sourcefiles encoding="UTF-8"&gt;
                &lt;fileset dir="${src.dir}"/&gt;
            &lt;/sourcefiles&gt;
        &lt;/structure&gt;
        &lt;html destdir="${result.jacoco.report.dir}/ut"/&gt;
    &lt;/jacoco:report&gt;      
</code></pre>

<p></target>
{% endcodeblock %}</p>

<p>生成覆盖率报告需要覆盖率文件（exec）、源码、编译后的class文件。这里导出的格式是html，还有xml和cvs 2种格式可以导出，具体参考<a href="http://www.eclemma.org/jacoco/trunk/doc/ant.html#report">jacoco:report</a>。<br/>
注意，这里的class文件和exec文件必须用同一个jvm执行，如果是用JVM A来编译class文件，然后用JVM B来生成覆盖率文件，生成出来的报告覆盖率会为0%。<strong>这一点对生成集成测试的覆盖率特别重要。</strong></p>
]]></content>
  </entry>
  
</feed>
